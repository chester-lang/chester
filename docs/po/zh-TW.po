msgid ""
msgstr ""
"Project-Id-Version: The Chester Programming Language\n"
"POT-Creation-Date: 2025-05-15T16:13:17+12:00\n"
"PO-Revision-Date: 2025-05-01 20:10+1200\n"
"Last-Translator:  <email@address.com>\n"
"Language-Team: Language zh-TW\n"
"Language: zh-TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: src/SUMMARY.md:1
msgid "https://github.com/rust-lang-nursery/mdBook/issues/677"
msgstr "https://github.com/rust-lang-nursery/mdBook/issues/677"

#: src/SUMMARY.md:2 src/index.md:1
msgid "Chester"
msgstr "Chester"

#: src/SUMMARY.md:3 src/dev/index.md:1
msgid "Chester Development Documentation"
msgstr "Chester 開發文檔"

#: src/SUMMARY.md:4 src/dev/TODO.md:1
msgid "TODO"
msgstr "待辦事項"

#: src/SUMMARY.md:5 src/dev/compiler-backend.md:1
msgid "Chester Compiler Backend Architecture"
msgstr "Chester 編譯器後端架構"

#: src/SUMMARY.md:6 src/dev/development.md:1
msgid "Development Memo"
msgstr "開發備忘錄"

#: src/SUMMARY.md:7 src/dev/devlog.md:1
msgid "Development Log"
msgstr "開發日誌"

#: src/SUMMARY.md:8 src/dev/effects-implementation-plan.md:1
msgid "Effect System Implementation Plan"
msgstr "效果系統實現計劃"

#: src/SUMMARY.md:9 src/dev/effects-system.md:1
msgid "Effect System Design"
msgstr "效果系統設計"

#: src/SUMMARY.md:10 src/dev/elaboration-system.md:1
msgid "Chester Elaboration System"
msgstr ""

#: src/SUMMARY.md:11 src/dev/intellij-idea.md:1
msgid "Intellij Idea configurations"
msgstr ""

#: src/SUMMARY.md:12 src/dev/js2py.md:1
msgid "JavaScript to Python Conversion Process"
msgstr "JavaScript 到 Python 的轉換過程"

#: src/SUMMARY.md:13 src/dev/reader.md:1
msgid "Chester Reader Architecture"
msgstr "Chester 讀取器架構"

#: src/SUMMARY.md:14 src/dev/scalablytyped-bindings.md:1
msgid "ScalablyTyped Bindings Guide"
msgstr "ScalablyTyped 綁定指南"

#: src/SUMMARY.md:15 src/dev/tyck-improvement-proposal.md:1
msgid "Comprehensive Type System Improvement Proposal"
msgstr "全面的類型系統改進提案"

#: src/SUMMARY.md:16 src/dev/type-checking-system.md:1
msgid "Type Checking System: Propagator Network and Design"
msgstr "類型檢查系統：傳播器網絡和設計"

#: src/SUMMARY.md:17 src/dev/typescript-backend.md:1
msgid "TypeScript Backend Implementation"
msgstr "TypeScript 後端實現"

#: src/SUMMARY.md:18 src/dev/union_types_progress.md:1
#, fuzzy
msgid "Union Types Implementation"
msgstr "TypeScript 後端實現"

#: src/SUMMARY.md:19 src/guide/index.md:1
msgid "Chester Guide"
msgstr "Chester 指南"

#: src/SUMMARY.md:20 src/guide/Record.md:1
msgid "Record Syntax in Chester"
msgstr "Chester 的記錄語法"

#: src/SUMMARY.md:21 src/dev/compiler-backend.md:198 src/guide/statements.md:1
msgid "Statements"
msgstr "語句"

#: src/SUMMARY.md:22 src/guide/syntax-grammar.md:1
msgid "Chester Syntax Grammar (BNF-like)"
msgstr "Chester 語法文法 (類 BNF)"

#: src/SUMMARY.md:23 src/guide/trait-and-interface.md:1
msgid "Traits and Interfaces in Chester"
msgstr "Chester 中的特質和介面"

#: src/index.md:3
msgid ""
"Welcome to the Chester Programming Language documentation! Chester is a "
"modern, expressive language designed to combine the best features of "
"functional and object-oriented programming paradigms."
msgstr ""
"歡迎來到 Chester 程式語言文件！Chester 是一種現代、表達力強的程式語言，旨在結"
"合函數式和物件導向程式設計的最佳特性。"

#: src/index.md:5
msgid ""
"This programming language is under active development and not ready for use. "
"Many important features are not implemented yet, including some described in "
"this documentation."
msgstr ""
"此程式語言正在積極開發中，尚未準備好供使用。許多重要功能尚未實現，包括本文件"
"中描述的一些功能。"

#: src/index.md:7
msgid "What is Chester?"
msgstr "Chester 是什麼？"

#: src/index.md:9
msgid ""
"Chester is a statically-typed language that aims to provide a balance "
"between expressiveness and safety. It draws inspiration from languages like "
"Scala, Haskell, and Rust, while introducing its own unique features."
msgstr ""
"Chester 是一種靜態類型語言，旨在提供表達力和安全性的平衡。它從像 Scala、"
"Haskell 和 Rust 的語言中汲取靈感，同時引入了自己的獨特功能。"

#: src/index.md:11
msgid "Some key characteristics of Chester include:"
msgstr "Chester 的一些關鍵特性包括："

#: src/index.md:13
msgid "Strong type system with type inference"
msgstr "強大的類型系統和類型推斷"

#: src/index.md:14
msgid "Support for both functional and object-oriented programming styles"
msgstr "支援函數式和物件導向程式設計風格"

#: src/index.md:15
msgid "Pattern matching and algebraic data types"
msgstr "模式匹配和代數數據類型"

#: src/index.md:16
msgid "Effect system for managing side effects"
msgstr "效果系統用於管理副作用"

#: src/index.md:17
msgid "Unicode support, allowing for expressive identifiers"
msgstr "Unicode 支援，允許表達性識別符"

#: src/index.md:19
msgid "A Glimpse of Chester"
msgstr "Chester 的一瞥"

#: src/index.md:21
msgid ""
"Let's take a look at a simple Chester program to get a feel for the language:"
msgstr "讓我們看看一個簡單的 Chester 程式來感受一下這種語言："

#: src/index.md:23
msgid ""
"```chester,playground,editable\n"
"module 😿😿;\n"
"\n"
"def me: String = \"インターネット・エンジェル\";\n"
"```"
msgstr ""
"```chester,playground,editable\n"
"module 😿😿;\n"
"\n"
"def me: String = \"インターネット・エンジェル\";\n"
"```"

#: src/dev/index.md:3
msgid ""
"This section contains technical documentation for Chester's implementation "
"details and development notes."
msgstr "本節包含 Chester 實現細節和開發說明的技術文檔。"

#: src/dev/index.md:5
msgid "These documents are made for both llm and human."
msgstr ""

#: src/dev/index.md:7
msgid "Documentation Structure"
msgstr "文檔結構"

#: src/dev/index.md:9
msgid ""
"We use [mdBook](https://rust-lang.github.io/mdBook/) for organizing and "
"presenting our documentation. The documentation is structured as follows:"
msgstr ""
"我們使用 [mdBook](https://rust-lang.github.io/mdBook/) 來組織和展示我們的文"
"檔。文檔結構如下："

#: src/dev/index.md:11
msgid "Documentation Management"
msgstr "文檔管理"

#: src/dev/index.md:13
msgid "The documentation structure is managed through several tools:"
msgstr "文檔結構通過以下幾種工具進行管理："

#: src/dev/index.md:15
msgid "**SUMMARY.md Generation**:"
msgstr "**SUMMARY.md 生成**："

#: src/dev/index.md:16
msgid ""
"The `SUMMARY.md` file is automatically generated using the `dev.sh` script"
msgstr "`SUMMARY.md` 文件是使用 `dev.sh` 腳本自動生成的"

#: src/dev/index.md:17
msgid "To update the summary: `cd docs && ./dev.sh summary`"
msgstr "更新摘要：`cd docs && ./dev.sh summary`"

#: src/dev/index.md:18
msgid "Do not edit `SUMMARY.md` directly as changes will be overwritten"
msgstr "請勿直接編輯 `SUMMARY.md`，因為變更將被覆蓋"

#: src/dev/index.md:20
msgid "**Building Documentation**:"
msgstr "**構建文檔**："

#: src/dev/index.md:21
msgid "Use mdBook to build and preview changes"
msgstr "使用 mdBook 構建和預覽變更"

#: src/dev/index.md:22
msgid "The `dev.sh` script provides various documentation management commands"
msgstr "`dev.sh` 腳本提供各種文檔管理命令"

#: src/dev/index.md:24
msgid "Contributing"
msgstr "貢獻"

#: src/dev/index.md:26
msgid "When adding new development documentation:"
msgstr "添加新的開發文檔時："

#: src/dev/index.md:28
msgid ""
"Create your markdown file in the appropriate subdirectory under `docs/src/"
"dev/`"
msgstr "在 `docs/src/dev/` 下的適當子目錄中創建您的 markdown 文件"

#: src/dev/index.md:29
msgid "Place development-related documentation in the `dev/` directory"
msgstr "將開發相關文檔放在 `dev/` 目錄中"

#: src/dev/index.md:30
msgid "Follow the existing documentation style and structure"
msgstr "遵循現有的文檔風格和結構"

#: src/dev/index.md:31
msgid "Include code examples where appropriate"
msgstr "在適當的地方包含代碼示例"

#: src/dev/index.md:32
msgid "Update this README.md if adding new major components"
msgstr "添加新的主要組件時更新此 README.md"

#: src/dev/index.md:33
msgid "Run `./dev.sh summary` to update the documentation structure"
msgstr "運行 `./dev.sh summary` 來更新文檔結構"

#: src/dev/TODO.md:3
msgid "parse a.b."
msgstr "解析 a.b."

#: src/dev/TODO.md:5
msgid "`import a.b.{x,y};`"
msgstr "`import a.b.{x,y};`"

#: src/dev/TODO.md:7
msgid "prompt"
msgstr "提示詞"

#: src/dev/TODO.md:9
msgid ""
"create a concise prompt introducing the language so that large langiage "
"model can read and write chester"
msgstr ""
"創建一個簡潔的提示詞介紹該語言，使大型語言模型能夠閱讀和編寫 Chester 代碼"

#: src/dev/TODO.md:11
msgid "abstract syntax"
msgstr "抽象語法"

#: src/dev/TODO.md:13
msgid "maybe create a trait and let graalvm's syntax tree variant implement it"
msgstr "可能需要創建一個特質並讓 GraalVM 的語法樹變體實現它"

#: src/dev/TODO.md:15
msgid "block type leak"
msgstr "區塊類型洩漏"

#: src/dev/TODO.md:17
msgid "`{let a = Int; let b: a = 1; b}`"
msgstr "`{let a = Int; let b: a = 1; b}` // 區塊內部類型變量在外部仍可見"

#: src/dev/compiler-backend.md:3 src/dev/effects-system.md:5 src/dev/js2py.md:3
#: src/dev/reader.md:5 src/dev/typescript-backend.md:3
msgid "Overview"
msgstr "概述"

#: src/dev/compiler-backend.md:5
msgid ""
"This document outlines the backend architecture of the Chester compiler "
"system. The backend is responsible for transforming Chester's internal "
"representation into executable code for various target platforms."
msgstr ""
"本文檔概述了 Chester 編譯器系統的後端架構。後端負責將 Chester 的內部表示轉換"
"為各種目標平台的可執行代碼。"

#: src/dev/compiler-backend.md:7
msgid "Backend Pipeline"
msgstr "後端流水線"

#: src/dev/compiler-backend.md:9
msgid ""
"The Chester compiler backend follows a multi-phase code generation pipeline:"
msgstr "Chester 編譯器後端遵循多階段代碼生成流水線："

#: src/dev/compiler-backend.md:15
msgid "Backend Components"
msgstr "後端組件"

#: src/dev/compiler-backend.md:17
msgid "The backend is composed of several key components:"
msgstr "後端由幾個關鍵組件組成："

#: src/dev/compiler-backend.md:19
msgid "Target-Specific AST Generation"
msgstr "目標特定的 AST 生成"

#: src/dev/compiler-backend.md:21
msgid "Each target platform has a specialized AST generation phase:"
msgstr "每個目標平台都有一個專門的 AST 生成階段："

#: src/dev/compiler-backend.md:23
msgid ""
"**Target AST Construction**: Builds an AST specific to the target language"
msgstr "**目標 AST 構建**：構建特定於目標語言的 AST"

#: src/dev/compiler-backend.md:24
msgid "**Type Mapping**: Maps Chester types to target language types"
msgstr "**類型映射**：將 Chester 類型映射到目標語言類型"

#: src/dev/compiler-backend.md:25
msgid ""
"**Effect Translation**: Converts Chester effects to target language "
"constructs"
msgstr "**效果轉換**：將 Chester 效果轉換為目標語言結構"

#: src/dev/compiler-backend.md:26
msgid "**Standard Library Binding**: Connects to platform-specific libraries"
msgstr "**標準庫綁定**：連接到平台特定的庫"

#: src/dev/compiler-backend.md:28
msgid "Optimization Engine"
msgstr "優化引擎"

#: src/dev/compiler-backend.md:30
msgid "The backend applies target-specific optimizations:"
msgstr "後端應用目標特定的優化："

#: src/dev/compiler-backend.md:32
msgid "**Dead Code Elimination**: Removes unused code"
msgstr "**死碼消除**：移除未使用的代碼"

#: src/dev/compiler-backend.md:33
msgid "**Constant Folding**: Evaluates constant expressions at compile time"
msgstr "**常量折疊**：在編譯時計算常量表達式"

#: src/dev/compiler-backend.md:34
msgid ""
"**Inlining**: Replaces function calls with function bodies where beneficial"
msgstr "**內聯**：在有益的情況下用函數體替換函數調用"

#: src/dev/compiler-backend.md:35
msgid "**Specialization**: Creates specialized versions of generic functions"
msgstr "**特化**：為泛型函數創建特定版本"

#: src/dev/compiler-backend.md:36
msgid "**Tail Call Optimization**: Optimizes tail-recursive calls"
msgstr "**尾調用優化**：優化尾遞歸調用"

#: src/dev/compiler-backend.md:38
msgid "Code Generation"
msgstr "代碼生成"

#: src/dev/compiler-backend.md:40
msgid "The final phase transforms the optimized target AST to executable code:"
msgstr "最後階段將優化的目標 AST 轉換為可執行代碼："

#: src/dev/compiler-backend.md:42
msgid "**Pretty Printing**: Generates formatted source code"
msgstr "**美化輸出**：生成格式化的源代碼"

#: src/dev/compiler-backend.md:43
msgid ""
"**Native Code Generation**: For targets that compile directly to machine code"
msgstr "**原生代碼生成**：用於直接編譯到機器碼的目標"

#: src/dev/compiler-backend.md:44
msgid "**Bytecode Generation**: For VM-based targets like the JVM"
msgstr "**字節碼生成**：用於基於虛擬機的目標，如 JVM"

#: src/dev/compiler-backend.md:45
msgid "**Source Maps**: Generates debugging information"
msgstr "**源碼映射**：生成調試信息"

#: src/dev/compiler-backend.md:47
msgid "Supported Compiler Targets"
msgstr "支持的編譯器目標"

#: src/dev/compiler-backend.md:49
msgid ""
"Chester supports multiple compiler targets, each with its own backend "
"implementation:"
msgstr "Chester 支持多種編譯器目標，每種目標都有自己的後端實現："

#: src/dev/compiler-backend.md:51 src/dev/compiler-backend.md:135
msgid "JavaScript/TypeScript"
msgstr "JavaScript/TypeScript"

#: src/dev/compiler-backend.md:53
msgid ""
"The JavaScript/TypeScript target (`compiler/shared/src/main/scala/chester/"
"targets/js/AST.scala`) enables running Chester programs in web browsers and "
"Node.js."
msgstr ""
"JavaScript/TypeScript 目標（`compiler/shared/src/main/scala/chester/targets/"
"js/AST.scala`）使 Chester 程序能夠在網頁瀏覽器和 Node.js 中運行。"

#: src/dev/compiler-backend.md:55 src/dev/compiler-backend.md:93
#: src/dev/type-checking-system.md:51
msgid "Architecture"
msgstr "架構"

#: src/dev/compiler-backend.md:57
msgid "The JavaScript backend consists of:"
msgstr "JavaScript 後端包括："

#: src/dev/compiler-backend.md:59
msgid ""
"**AST Nodes**: Comprehensive representation of JavaScript/TypeScript "
"constructs"
msgstr "**AST 節點**：JavaScript/TypeScript 結構的全面表示"

#: src/dev/compiler-backend.md:60
msgid "**Type Translator**: Maps Chester types to TypeScript type annotations"
msgstr "**類型轉換器**：將 Chester 類型映射到 TypeScript 類型註解"

#: src/dev/compiler-backend.md:61
msgid ""
"**Effect Handler**: Implements Chester's effect system using JavaScript "
"promises"
msgstr ""
"**效果處理器**：使用 JavaScript 承諾（promises）實現 Chester 的效果系統"

#: src/dev/compiler-backend.md:62
msgid "**Module System**: Generates ES module exports and imports"
msgstr "**模塊系統**：生成 ES 模塊導出和導入"

#: src/dev/compiler-backend.md:64 src/dev/compiler-backend.md:102
msgid "Key Features"
msgstr "關鍵特性"

#: src/dev/compiler-backend.md:66
msgid "Complete JavaScript language support"
msgstr "完整的 JavaScript 語言支援"

#: src/dev/compiler-backend.md:67
msgid "TypeScript type annotations"
msgstr "TypeScript 類型註解"

#: src/dev/compiler-backend.md:68
msgid "ECMAScript module system"
msgstr "ECMAScript 模塊系統"

#: src/dev/compiler-backend.md:69
msgid "Web API integration"
msgstr "Web API 集成"

#: src/dev/compiler-backend.md:70
msgid "Sourcemap generation for debugging"
msgstr "用於調試的源碼映射生成"

#: src/dev/compiler-backend.md:72
msgid "JS AST Structure"
msgstr "JS AST 結構"

#: src/dev/compiler-backend.md:74
msgid "The JavaScript AST is implemented as a set of case classes:"
msgstr "JavaScript AST 是以一組 case class 的形式實現的："

#: src/dev/compiler-backend.md:87
msgid ""
"Each node includes a `toDoc` method for pretty printing and source "
"generation."
msgstr "每個節點都包含一個用於美化輸出和源代碼生成的 `toDoc` 方法。"

#: src/dev/compiler-backend.md:89
msgid "JVM (Java/Scala)"
msgstr "JVM (Java/Scala)"

#: src/dev/compiler-backend.md:91
msgid ""
"The JVM target enables integration with the Java ecosystem and leverages the "
"JVM runtime."
msgstr "JVM 目標實現了與 Java 生態系統的集成，並利用 JVM 運行時。"

#: src/dev/compiler-backend.md:95
msgid "The JVM backend consists of:"
msgstr "JVM 後端包含："

#: src/dev/compiler-backend.md:97
msgid "**Bytecode Generation**: Direct generation of JVM bytecode"
msgstr "**字節碼生成**：直接生成 JVM 字節碼"

#: src/dev/compiler-backend.md:98
msgid "**Class Builder**: Creates JVM class files"
msgstr "**類別構建器**：創建 JVM 類別文件"

#: src/dev/compiler-backend.md:99
msgid "**Runtime Library**: Core runtime support for Chester on JVM"
msgstr "**運行時庫**：JVM 上 Chester 的核心運行時支持"

#: src/dev/compiler-backend.md:100
msgid "**Java Interop**: Enables calling Java code from Chester"
msgstr "**Java 互操作**：實現從 Chester 調用 Java 代碼"

#: src/dev/compiler-backend.md:104
msgid "Java interoperability"
msgstr "Java 互操作性"

#: src/dev/compiler-backend.md:105
msgid "Scala library integration"
msgstr "Scala 庫集成"

#: src/dev/compiler-backend.md:106
msgid "JVM optimizations"
msgstr "JVM 優化"

#: src/dev/compiler-backend.md:107
msgid "Access to the Java standard library"
msgstr "訪問 Java 標準庫"

#: src/dev/compiler-backend.md:108
msgid "Advanced JVM optimizations (inlining, specialization)"
msgstr "高級 JVM 優化（內聯，特化）"

#: src/dev/compiler-backend.md:110 src/dev/compiler-backend.md:135
msgid "Native (Planned)"
msgstr "原生 (計劃中)"

#: src/dev/compiler-backend.md:112
msgid "A native code target is planned for high-performance applications."
msgstr "為高性能應用程序計劃了原生代碼目標。"

#: src/dev/compiler-backend.md:114
msgid "Potential Architecture"
msgstr "潛在架構"

#: src/dev/compiler-backend.md:116
msgid "The native backend will likely include:"
msgstr "原生後端可能包括："

#: src/dev/compiler-backend.md:118
msgid "**LLVM IR Generation**: Translation to LLVM intermediate representation"
msgstr "**LLVM IR 生成**：轉換為 LLVM 中間表示"

#: src/dev/compiler-backend.md:119
msgid "**Native Runtime**: Minimal runtime support library"
msgstr "**原生運行時**：最小運行時支持庫"

#: src/dev/compiler-backend.md:120
msgid "**ABI Compatibility**: Interoperability with C/C++ code"
msgstr "**ABI 兼容性**：與 C/C++ 代碼的互操作性"

#: src/dev/compiler-backend.md:121
msgid "**Platform Support**: Cross-compilation for different CPU architectures"
msgstr "**平台支持**：為不同 CPU 架構的交叉編譯"

#: src/dev/compiler-backend.md:123
msgid "Planned Features"
msgstr "計劃功能"

#: src/dev/compiler-backend.md:125
msgid "LLVM-based code generation"
msgstr ""

#: src/dev/compiler-backend.md:126
msgid "Native performance"
msgstr ""

#: src/dev/compiler-backend.md:127
msgid "Low-level memory control"
msgstr ""

#: src/dev/compiler-backend.md:128
msgid "System programming capabilities"
msgstr ""

#: src/dev/compiler-backend.md:129
msgid "Cross-platform support"
msgstr ""

#: src/dev/compiler-backend.md:131
msgid "Type System Mapping"
msgstr ""

#: src/dev/compiler-backend.md:133
msgid ""
"Chester's rich type system needs careful mapping to target language types:"
msgstr ""

#: src/dev/compiler-backend.md:135 src/dev/typescript-backend.md:34
msgid "Chester Type"
msgstr "Chester 類型"

#: src/dev/compiler-backend.md:135
msgid "JVM"
msgstr ""

#: src/dev/compiler-backend.md:137 src/dev/typescript-backend.md:36
msgid "Integer"
msgstr ""

#: src/dev/compiler-backend.md:137 src/dev/compiler-backend.md:138
#: src/dev/typescript-backend.md:36
msgid "number"
msgstr ""

#: src/dev/compiler-backend.md:137 src/dev/compiler-backend.md:138
msgid "scala.BigInt"
msgstr ""

#: src/dev/compiler-backend.md:137
msgid "int64_t"
msgstr ""

#: src/dev/compiler-backend.md:138
msgid "Natural"
msgstr ""

#: src/dev/compiler-backend.md:138
msgid "uint64_t"
msgstr ""

#: src/dev/compiler-backend.md:139 src/dev/typescript-backend.md:38
msgid "Boolean"
msgstr ""

#: src/dev/compiler-backend.md:139 src/dev/typescript-backend.md:38
msgid "boolean"
msgstr ""

#: src/dev/compiler-backend.md:139
msgid "scala.Boolean"
msgstr ""

#: src/dev/compiler-backend.md:139
msgid "bool"
msgstr ""

#: src/dev/compiler-backend.md:140 src/dev/typescript-backend.md:37
msgid "String"
msgstr ""

#: src/dev/compiler-backend.md:140 src/dev/typescript-backend.md:37
msgid "string"
msgstr ""

#: src/dev/compiler-backend.md:140
msgid "java.lang.String"
msgstr ""

#: src/dev/compiler-backend.md:140
msgid "std::string"
msgstr ""

#: src/dev/compiler-backend.md:141
msgid "Union Types (A"
msgstr ""

#: src/dev/compiler-backend.md:141
msgid "B)"
msgstr ""

#: src/dev/compiler-backend.md:141
msgid "A \\| B"
msgstr ""

#: src/dev/compiler-backend.md:141
msgid "Specialized classes"
msgstr ""

#: src/dev/compiler-backend.md:142 src/dev/typescript-backend.md:42
msgid "Record"
msgstr "記錄"

#: src/dev/compiler-backend.md:142
msgid "interface/class"
msgstr ""

#: src/dev/compiler-backend.md:142
msgid "case class"
msgstr ""

#: src/dev/compiler-backend.md:142
msgid "struct"
msgstr ""

#: src/dev/compiler-backend.md:143
msgid "Functions"
msgstr ""

#: src/dev/compiler-backend.md:143
msgid "function"
msgstr ""

#: src/dev/compiler-backend.md:143
msgid "Function objects"
msgstr ""

#: src/dev/compiler-backend.md:143
msgid "Function pointers"
msgstr ""

#: src/dev/compiler-backend.md:145
msgid "Effects Handling"
msgstr ""

#: src/dev/compiler-backend.md:147
msgid ""
"Chester's effect system is implemented differently for each target language:"
msgstr ""

#: src/dev/compiler-backend.md:149
msgid "**JavaScript/TypeScript**: Using promises or custom effect handlers"
msgstr ""

#: src/dev/compiler-backend.md:150
msgid "**JVM**: Using exceptions and monadic structures"
msgstr ""

#: src/dev/compiler-backend.md:151
msgid "**Native**: Using error codes or custom effect handling"
msgstr ""

#: src/dev/compiler-backend.md:153
msgid "Implementation Example: JavaScript Backend"
msgstr ""

#: src/dev/compiler-backend.md:155
msgid "JavaScript/TypeScript AST Example"
msgstr ""

#: src/dev/compiler-backend.md:157
msgid "The JavaScript target provides a good example of target-specific AST:"
msgstr ""

#: src/dev/compiler-backend.md:160
msgid "// Example: Function declaration in JavaScript AST"
msgstr ""

#: src/dev/compiler-backend.md:162
msgid "\"greet\""
msgstr ""

#: src/dev/compiler-backend.md:163 src/dev/compiler-backend.md:170
msgid "\"name\""
msgstr ""

#: src/dev/compiler-backend.md:169
msgid "\"Hello, \""
msgstr ""

#: src/dev/compiler-backend.md:177
msgid "This represents the TypeScript function:"
msgstr ""

#: src/dev/compiler-backend.md:179
msgid ""
"```typescript\n"
"function greet(name: string): string {\n"
"  return \"Hello, \" + name;\n"
"}\n"
"```"
msgstr ""

#: src/dev/compiler-backend.md:185
msgid "JavaScript AST Node Categories"
msgstr ""

#: src/dev/compiler-backend.md:187
msgid "The JavaScript AST supports a wide range of node types:"
msgstr ""

#: src/dev/compiler-backend.md:189 src/guide/syntax-grammar.md:18
msgid "Expressions"
msgstr "表達式"

#: src/dev/compiler-backend.md:191
msgid "**Literals**: Numbers, strings, booleans, null, BigInt, RegExp"
msgstr ""

#: src/dev/compiler-backend.md:192
msgid "**Identifiers**: Named references (typed and untyped)"
msgstr ""

#: src/dev/compiler-backend.md:193
msgid "**Operators**: Binary, logical, assignment, unary, update"
msgstr ""

#: src/dev/compiler-backend.md:194
msgid "**Function Expressions**: Regular functions and arrow functions"
msgstr ""

#: src/dev/compiler-backend.md:195
msgid "**Object and Array Expressions**: Object literals and array literals"
msgstr ""

#: src/dev/compiler-backend.md:196
msgid ""
"**Class Expressions**: Class definitions with inheritance and method "
"definitions"
msgstr ""

#: src/dev/compiler-backend.md:200
msgid "**Block Statements**: Groups of statements"
msgstr ""

#: src/dev/compiler-backend.md:201
msgid "**Expression Statements**: Expressions used as statements"
msgstr ""

#: src/dev/compiler-backend.md:202
msgid "**Control Flow Statements**: if/else, while, do-while, for, switch"
msgstr ""

#: src/dev/compiler-backend.md:203
msgid "**Declaration Statements**: let, const, var declarations"
msgstr ""

#: src/dev/compiler-backend.md:205
msgid "TypeScript Features"
msgstr ""

#: src/dev/compiler-backend.md:207
msgid "**Type Annotations**: For variables, parameters, return types"
msgstr ""

#: src/dev/compiler-backend.md:208
msgid "**Interface and Type Declarations**: For defining complex types"
msgstr ""

#: src/dev/compiler-backend.md:209
msgid "**Generics**: Type parameters for functions and classes"
msgstr ""

#: src/dev/compiler-backend.md:210
msgid "**Union and Intersection Types**: Type combinations"
msgstr ""

#: src/dev/compiler-backend.md:212
msgid "Build System Integration"
msgstr ""

#: src/dev/compiler-backend.md:214
msgid "The Chester compiler backend integrates with build systems through:"
msgstr ""

#: src/dev/compiler-backend.md:216
msgid "**SBT Plugin**: For JVM builds"
msgstr ""

#: src/dev/compiler-backend.md:217
msgid "**NPM Package**: For JavaScript/TypeScript integration"
msgstr ""

#: src/dev/compiler-backend.md:218
msgid "**CLI Interface**: For command-line usage"
msgstr ""

#: src/dev/compiler-backend.md:220
msgid "Future Directions"
msgstr ""

#: src/dev/compiler-backend.md:222
msgid "Planned improvements to the compiler backend include:"
msgstr ""

#: src/dev/compiler-backend.md:224
msgid "**WebAssembly Support**: Direct compilation to WebAssembly"
msgstr ""

#: src/dev/compiler-backend.md:225
msgid "**More Native Targets**: Support for various native platforms"
msgstr ""

#: src/dev/compiler-backend.md:226
msgid "**Interoperability Enhancements**: Better interop with target languages"
msgstr ""

#: src/dev/compiler-backend.md:227
msgid "**Performance Optimizations**: Target-specific optimizations"
msgstr ""

#: src/dev/compiler-backend.md:228
msgid "**Cross-Compilation**: Single-command compilation to multiple targets"
msgstr ""

#: src/dev/compiler-backend.md:229
msgid "**Advanced Optimizations**: Target-specific performance improvements"
msgstr ""

#: src/dev/compiler-backend.md:231 src/dev/union_types_progress.md:153
msgid "References"
msgstr "參考資料"

#: src/dev/compiler-backend.md:233
msgid ""
"JavaScript AST is inspired by the [ESTree Spec](https://github.com/estree/"
"estree)"
msgstr ""

#: src/dev/compiler-backend.md:234
msgid ""
"JVM codegen draws from [Scala 3 compiler techniques](https://github.com/"
"lampepfl/dotty)"
msgstr ""

#: src/dev/compiler-backend.md:235
msgid ""
"LLVM-based compilation follows the [LLVM Language Reference](https://"
"llvm.org/docs/LangRef.html)"
msgstr ""

#: src/dev/development.md:3
msgid ""
"NOTE THAT ALL CODE AND DOCUMENTS CAN AND WILL BE OUTDATED OR CONFLICTING. "
"ANALYSE INFORMATION AVAIABLE TO YOU CAREFULLY"
msgstr ""

#: src/dev/development.md:5
msgid "Documentation Guidelines"
msgstr ""

#: src/dev/development.md:7
msgid "**Avoid Meaningless Adjectives**"
msgstr ""

#: src/dev/development.md:8
msgid ""
"❌ **NEVER USE** subjective qualifiers like: \"better\", \"improved\", "
"\"good\", \"great\", \"enhanced\", \"advanced\", \"beautiful\", "
"\"powerful\", \"robust\", \"excellent\", \"high-quality\""
msgstr ""

#: src/dev/development.md:9
msgid "✅ **ALWAYS USE** factual, specific, measurable descriptions"
msgstr ""

#: src/dev/development.md:10
msgid "Describe concrete characteristics and behaviors"
msgstr ""

#: src/dev/development.md:11
msgid "Focus on correctness and functionality first"
msgstr ""

#: src/dev/development.md:13
msgid "**Focus on Facts**"
msgstr ""

#: src/dev/development.md:14
msgid "Document what something IS, not how \"good\" you think it is"
msgstr ""

#: src/dev/development.md:15
msgid "Identify concrete capabilities and limitations"
msgstr ""

#: src/dev/development.md:16
msgid ""
"Omit subjective assessments and emotional language (BUT EMPHASIZE ON WHAT "
"ALWAYS DID WRONG BY DEVELOPERS IS OK LIKE EMOJI EMPHASIZE AND UPPERCASE AND "
"**BOLD**)"
msgstr ""

#: src/dev/development.md:17
msgid "Avoid superlatives and value judgments"
msgstr ""

#: src/dev/development.md:19
msgid "**Eliminate Fluff Phrases**"
msgstr ""

#: src/dev/development.md:20
msgid "Remove sentences that don't add information"
msgstr ""

#: src/dev/development.md:21
msgid "Avoid concluding paragraphs that just say \"this is useful\""
msgstr ""

#: src/dev/development.md:22
msgid "Don't add generic statements about quality or value"
msgstr ""

#: src/dev/development.md:23
msgid ""
"Delete phrases like \"comprehensive framework\", \"elegant solution\", etc."
msgstr ""

#: src/dev/development.md:25
msgid "**Be Specific and Concrete**"
msgstr ""

#: src/dev/development.md:26
msgid ""
"Instead of \"improved performance\", describe the specific optimization "
"technique"
msgstr ""

#: src/dev/development.md:27
msgid ""
"Instead of \"enhanced error reporting\", specify exactly what information is "
"included in errors"
msgstr ""

#: src/dev/development.md:28
msgid "Replace \"powerful features\" with a specific list of capabilities"
msgstr ""

#: src/dev/development.md:30
msgid "Development Practices"
msgstr ""

#: src/dev/development.md:32
msgid "Planning Changes"
msgstr ""

#: src/dev/development.md:34
msgid "**Document Before Implementing**"
msgstr ""

#: src/dev/development.md:35
msgid ""
"Always document the steps you plan to take BEFORE making any code changes"
msgstr ""

#: src/dev/development.md:36
msgid "Break down complex changes into clearly defined smaller steps"
msgstr ""

#: src/dev/development.md:37
msgid "For each step, explain:"
msgstr ""

#: src/dev/development.md:38
msgid "What will be changed"
msgstr ""

#: src/dev/development.md:39
msgid "Why the change is needed"
msgstr ""

#: src/dev/development.md:40
msgid "How the change relates to the larger goal"
msgstr ""

#: src/dev/development.md:41
msgid "What tests will verify the change"
msgstr ""

#: src/dev/development.md:42
msgid "Review your plan for completeness before starting implementation"
msgstr ""

#: src/dev/development.md:43
msgid "Document any deviations from the plan that occur during implementation"
msgstr ""

#: src/dev/development.md:45
msgid "**Use Step-by-Step Implementation**"
msgstr ""

#: src/dev/development.md:46
msgid "After documenting your plan, implement one step at a time"
msgstr ""

#: src/dev/development.md:47
msgid "Run the full test suite (`sbt rootJVM/test`) after each step"
msgstr ""

#: src/dev/development.md:48
msgid "Commit logical units of work with clear messages"
msgstr ""

#: src/dev/development.md:49
msgid "Do not proceed to the next step until the current step passes all tests"
msgstr ""

#: src/dev/development.md:51
msgid "Making Changes"
msgstr ""

#: src/dev/development.md:53
msgid "**Keep Changes Small and Focused**"
msgstr ""

#: src/dev/development.md:54
msgid "Make one logical change at a time"
msgstr ""

#: src/dev/development.md:55
msgid "Break down large changes into smaller, independent steps"
msgstr ""

#: src/dev/development.md:56
msgid "Each change should be easily reviewable and testable"
msgstr ""

#: src/dev/development.md:58
msgid "**Testing Requirements**"
msgstr ""

#: src/dev/development.md:59
msgid "**ALWAYS use the following commands for running tests:**"
msgstr ""

#: src/dev/development.md:61
msgid "# Run all tests from the root project\n"
msgstr ""

#: src/dev/development.md:64
msgid "# Run a specific test class from the root project\n"
msgstr ""

#: src/dev/development.md:65 src/dev/development.md:288
#: src/dev/tyck-improvement-proposal.md:203
msgid "\"rootJVM/testOnly chester.tyck.FilesTyckTest\""
msgstr ""

#: src/dev/development.md:67
msgid "# You can also run tests for specific modules when needed\n"
msgstr ""

#: src/dev/development.md:72
msgid "# Run specific test classes in modules\n"
msgstr ""

#: src/dev/development.md:73
msgid "\"reader/testOnly chester.reader.ReaderTest\""
msgstr ""

#: src/dev/development.md:74 src/dev/development.md:113
msgid "\"semantic/testOnly chester.tyck.TheTyckTest\""
msgstr ""

#: src/dev/development.md:75
msgid "\"cli/testOnly chester.cli.CLITest\""
msgstr ""

#: src/dev/development.md:77
msgid ""
"**DO NOT** navigate into subdirectories to run tests (e.g., `cd reader && "
"sbt test`)"
msgstr ""

#: src/dev/development.md:78
msgid "**ALWAYS** run tests from the root project directory"
msgstr ""

#: src/dev/development.md:79 src/dev/development.md:291
msgid "⚠️ **CRITICAL: NEVER use the `-z` test filter option** ⚠️"
msgstr "⚠️ **關鍵：切勿使用 `-z` 測試過濾選項** ⚠️"

#: src/dev/development.md:80
msgid "`-z` is NOT the correct syntax for filtering tests in MUnit"
msgstr "`-z` 不是 MUnit 中過濾測試的正確語法"

#: src/dev/development.md:81
msgid "This option is broken and produces unreliable results"
msgstr "此選項已損壞並產生不可靠的結果"

#: src/dev/development.md:82
msgid "Tests may appear to pass when they actually fail"
msgstr "測試可能看起來通過，但實際上失敗了"

#: src/dev/development.md:83
msgid "This can lead to false confidence in your changes"
msgstr "這可能導致對您的更改產生錯誤的信心"

#: src/dev/development.md:84
msgid "ScalaTest uses `-z` for filtering, but MUnit uses `--tests=` instead"
msgstr "ScalaTest 使用 `-z` 進行過濾，但 MUnit 使用 `--tests=` 代替"

#: src/dev/development.md:85
msgid "⚠️ **IMPORTANT: Only use correct MUnit filter syntax with `--`** ⚠️"
msgstr "⚠️ **重要：僅使用帶有 `--` 的正確 MUnit 過濾語法** ⚠️"

#: src/dev/development.md:86
msgid "When filtering tests, always use proper MUnit syntax:"
msgstr "過濾測試時，始終使用正確的 MUnit 語法："

#: src/dev/development.md:87
msgid "**CORRECT MUnit syntax examples:**"
msgstr "**正確的 MUnit 語法示例：**"

#: src/dev/development.md:89
msgid "# Filter by test name\n"
msgstr "# 按測試名稱過濾\n"

#: src/dev/development.md:90
msgid "\"rootJVM/testOnly -- --tests=myTestName\""
msgstr ""

#: src/dev/development.md:92
msgid "# Filter by glob pattern\n"
msgstr "# 按全局模式過濾\n"

#: src/dev/development.md:93
msgid "\"rootJVM/testOnly -- *MyTest\""
msgstr ""

#: src/dev/development.md:95
msgid "**INCORRECT syntax from other frameworks (DO NOT USE):**"
msgstr "**來自其他框架的錯誤語法（不要使用）：**"

#: src/dev/development.md:97
msgid "# ScalaTest style (WRONG with MUnit)\n"
msgstr "# ScalaTest 風格（與 MUnit 一起使用是錯誤的）\n"

#: src/dev/development.md:98
msgid "\"rootJVM/testOnly -- -t MyTest\""
msgstr ""

#: src/dev/development.md:100
msgid "# JUnit style (WRONG with MUnit)\n"
msgstr "# JUnit 風格（與 MUnit 一起使用是錯誤的）\n"

#: src/dev/development.md:101
msgid "\"rootJVM/testOnly -- -n MyTest\""
msgstr ""

#: src/dev/development.md:103
msgid "# Custom incorrect style\n"
msgstr "# 自定義錯誤風格\n"

#: src/dev/development.md:104
msgid "\"rootJVM/testOnly -- -only file.chester\""
msgstr ""

#: src/dev/development.md:106
msgid "ALWAYS run `sbt rootJVM/test` before committing changes"
msgstr "提交更改前始終運行 `sbt rootJVM/test`"

#: src/dev/development.md:107
msgid "Fix any test failures before committing"
msgstr "提交前修復所有測試失敗"

#: src/dev/development.md:108
msgid "Add new tests for new functionality"
msgstr "為新功能添加新測試"

#: src/dev/development.md:109
msgid "Update existing tests when modifying behavior"
msgstr "修改行為時更新現有測試"

#: src/dev/development.md:110 src/dev/elaboration-system.md:232
msgid "Test both success and failure cases"
msgstr "測試成功和失敗的情況"

#: src/dev/development.md:111
msgid ""
"**💡 Development Tip:** For quickly adding and testing new type checking "
"scenarios during development, you can add code snippets to the `tests/"
"tyck.chester` file. To run _only_ these snippets for rapid feedback, use the "
"specific test class `chester.tyck.TheTyckTest`. **The correct command for "
"this specific development workflow is:**"
msgstr ""

#: src/dev/development.md:115
msgid ""
"This command targets the test directly within its module (`semantic`), "
"providing a faster feedback loop than running the full suite via `rootJVM/"
"test`. Note that `TheTyckTest` is designed for this temporary testing and is "
"often disabled (`doTest = false`) otherwise. Remember to use `sbt rootJVM/"
"test | cat` for final verification before committing."
msgstr ""

#: src/dev/development.md:116
msgid ""
"**📝 Post-Development Workflow:** Once the code in `tests/tyck.chester` "
"passes type checking with `TheTyckTest`:"
msgstr ""

#: src/dev/development.md:117
msgid "Move the `tests/tyck.chester` file to the main `tests/tyck/` directory."
msgstr ""

#: src/dev/development.md:118
msgid ""
"Give the file a descriptive name reflecting the feature tested (e.g., `union-"
"assignment.chester`)."
msgstr ""

#: src/dev/development.md:119
msgid ""
"Set the `doTest` flag in `semantic/jvm-native/src/test/scala/chester/tyck/"
"TheTyckTest.scala` to `false` to disable this specific test run until needed "
"again. (Note: Test suites like `FilesTyckTest` automatically discover files "
"in the `tests/tyck/` directory, so no explicit addition is needed)."
msgstr ""

#: src/dev/development.md:121
msgid "For parser changes:"
msgstr ""

#: src/dev/development.md:122
msgid "Many tests now run against both old and new readers (V1 and V2)"
msgstr ""

#: src/dev/development.md:123
msgid "Some complex tests currently only run against V1 (original reader)"
msgstr ""

#: src/dev/development.md:124
msgid "When adding new parser tests:"
msgstr ""

#: src/dev/development.md:125
msgid "Use `parseAndCheckBoth` by default for new tests"
msgstr ""

#: src/dev/development.md:126
msgid "Only use `parseAndCheck` if testing V1-specific features"
msgstr ""

#: src/dev/development.md:127
msgid "Document if test is V1-only and why"
msgstr ""

#: src/dev/development.md:128
msgid "Plan to migrate V1-only tests to V2 when ready"
msgstr ""

#: src/dev/development.md:129
msgid "Test function usage:"
msgstr ""

#: src/dev/development.md:130
msgid "`parseAndCheck`: V1 parser only"
msgstr ""

#: src/dev/development.md:131
msgid "`parseAndCheckBoth`: Both V1 and V2 parsers"
msgstr ""

#: src/dev/development.md:132
msgid "`parseAndCheckV1`: Deprecated alias for parseAndCheckBoth"
msgstr ""

#: src/dev/development.md:133
msgid "Recently migrated tests:"
msgstr ""

#: src/dev/development.md:134
msgid "Basic operator sequence tests"
msgstr ""

#: src/dev/development.md:135
msgid "Pattern matching tests with uniform symbol treatment"
msgstr ""

#: src/dev/development.md:136
msgid "Simple expression tests"
msgstr ""

#: src/dev/development.md:137
msgid "Function call tests"
msgstr ""

#: src/dev/development.md:138
msgid "Dot notation tests"
msgstr ""

#: src/dev/development.md:139
msgid "Object tests"
msgstr ""

#: src/dev/development.md:140
msgid "Tuple tests"
msgstr ""

#: src/dev/development.md:141
msgid "Vararg tests"
msgstr ""

#: src/dev/development.md:142
msgid "Floating-point number parsing tests"
msgstr ""

#: src/dev/development.md:143
msgid "List tests with mixed types"
msgstr ""

#: src/dev/development.md:144
msgid "Tests still needing migration:"
msgstr ""

#: src/dev/development.md:145
msgid "Complex operator sequences (prefix, mixfix)"
msgstr ""

#: src/dev/development.md:146
msgid "Telescope parsing"
msgstr ""

#: src/dev/development.md:147
msgid "Error handling"
msgstr ""

#: src/dev/development.md:148
msgid "Source position tracking"
msgstr ""

#: src/dev/development.md:149
msgid "For type checking changes:"
msgstr ""

#: src/dev/development.md:150
msgid "Test term preservation in elaborated results"
msgstr ""

#: src/dev/development.md:151
msgid "Test type-level computation works correctly"
msgstr ""

#: src/dev/development.md:152
msgid "Test error reporting is accurate"
msgstr ""

#: src/dev/development.md:153
msgid "Test edge cases and corner cases"
msgstr ""

#: src/dev/development.md:155
msgid "**Verify Changes with Git**"
msgstr ""

#: src/dev/development.md:157
msgid ""
"# After each change - ALWAYS use | cat to prevent terminal control issues:\n"
msgstr ""

#: src/dev/development.md:158
msgid "# Review what changed \n"
msgstr ""

#: src/dev/development.md:160
msgid "# Verify staged changes \n"
msgstr ""

#: src/dev/development.md:161
msgid "\"...\"     # Commit with clear message\n"
msgstr ""

#: src/dev/development.md:164
msgid ""
"⚠️ **Always append `| cat` to git diff commands to avoid paging issues.**"
msgstr ""

#: src/dev/development.md:166
msgid "**Change Verification Checklist**"
msgstr "**變更驗證檢查清單**"

#: src/dev/development.md:167
msgid "Changes are minimal and focused"
msgstr ""

#: src/dev/development.md:168
msgid "Git diff shows only intended changes"
msgstr ""

#: src/dev/development.md:169
msgid "Tests pass after changes"
msgstr ""

#: src/dev/development.md:170
msgid "Changes align with existing code style"
msgstr ""

#: src/dev/development.md:171
msgid "Review the git diff output carefully"
msgstr ""

#: src/dev/development.md:173
msgid "# Before committing, ALWAYS verify changes with:\n"
msgstr ""

#: src/dev/development.md:177
msgid ""
"💡 **WHY THIS MATTERS**: Failure to review diffs properly is the #1 cause of "
"accidental code deletions and introduction of subtle bugs."
msgstr ""

#: src/dev/development.md:178
msgid "Reviewing git diff output is essential for catching:"
msgstr ""

#: src/dev/development.md:179
msgid "Accidental deletions of important methods or logic"
msgstr ""

#: src/dev/development.md:180
msgid "Unintended modification of critical code"
msgstr ""

#: src/dev/development.md:181
msgid "Formatting changes that might impact behavior"
msgstr ""

#: src/dev/development.md:182
msgid "Changes to files you didn't intend to modify"
msgstr ""

#: src/dev/development.md:183
msgid "Pay special attention to large diffs that might hide important changes"
msgstr ""

#: src/dev/development.md:184
msgid "Verify no unrelated changes were included"
msgstr ""

#: src/dev/development.md:185
msgid ""
"When making multiple changes, review each file's diff separately for clarity"
msgstr ""

#: src/dev/development.md:187
msgid "**Post-Commit Verification**"
msgstr ""

#: src/dev/development.md:188
msgid ""
"**⚠️ MANDATORY**: Always verify your changes after committing with `git diff "
"HEAD^ HEAD | cat`"
msgstr ""

#: src/dev/development.md:189
msgid "Check the diff output carefully to ensure:"
msgstr ""

#: src/dev/development.md:190
msgid "No unintended changes were included"
msgstr ""

#: src/dev/development.md:191
msgid "All intended changes were properly committed"
msgstr ""

#: src/dev/development.md:192
msgid "File renames and deletions are correctly reflected"
msgstr ""

#: src/dev/development.md:193
msgid "No sensitive or debug code was accidentally committed"
msgstr ""

#: src/dev/development.md:194
msgid "No accidental deletions of important logic"
msgstr ""

#: src/dev/development.md:195
msgid "Verify the commit message accurately describes the changes"
msgstr ""

#: src/dev/development.md:196
msgid ""
"For complex changes involving multiple files, check each file's changes "
"individually"
msgstr ""

#: src/dev/development.md:198
msgid "**Git Command Tips**"
msgstr "**Git 命令技巧**"

#: src/dev/development.md:199
msgid "Always use `| cat` with git commands that might trigger paging:"
msgstr "始終在可能觸發分頁的 git 命令中使用 `| cat`："

#: src/dev/development.md:205
msgid "This ensures consistent output and avoids interactive paging"
msgstr "這確保了一致的輸出並避免了互動式分頁"

#: src/dev/development.md:207
msgid "Terminal Control with Git Commands"
msgstr "使用 Git 命令的終端控制"

#: src/dev/development.md:209
msgid "**⚠️ CRITICAL: ALWAYS Use `| cat` Suffix**"
msgstr "**⚠️ 關鍵: 始終使用 `| cat` 後綴**"

#: src/dev/development.md:210
msgid ""
"Git commands that might trigger paging or interactive prompts MUST ALWAYS "
"end with `| cat`"
msgstr "可能觸發分頁或互動提示的 Git 命令必須始終以 `| cat` 結尾"

#: src/dev/development.md:211
msgid "This is a MANDATORY practice, not a suggestion"
msgstr "這是強制性的做法，而不是建議"

#: src/dev/development.md:212
msgid "This ensures consistent output and prevents terminal control issues"
msgstr "這可確保輸出一致並防止終端控制問題"

#: src/dev/development.md:213
msgid ""
"Failure to use `| cat` is the leading cause of incomplete reviews and missed "
"errors"
msgstr "未使用 `| cat` 是導致審查不完整和錯過錯誤的主要原因"

#: src/dev/development.md:214 src/dev/devlog.md:357
#: src/dev/effects-system.md:25
msgid "Examples:"
msgstr "範例："

#: src/dev/development.md:224
msgid "**Common Git Operations**"
msgstr "**常見 Git 操作**"

#: src/dev/development.md:226
msgid "# Switching branches\n"
msgstr ""

#: src/dev/development.md:230
msgid "# Merging\n"
msgstr ""

#: src/dev/development.md:232
msgid "# If merge conflicts occur\n"
msgstr ""

#: src/dev/development.md:234
msgid "# Viewing changes\n"
msgstr ""

#: src/dev/development.md:239
msgid "# Committing\n"
msgstr ""

#: src/dev/development.md:241
msgid "\"type: description\""
msgstr ""

#: src/dev/development.md:244 src/dev/development.md:529
msgid "**Why This Matters**"
msgstr "**為什麼這很重要**"

#: src/dev/development.md:245
msgid "Prevents terminal from entering interactive mode"
msgstr "防止終端進入互動模式"

#: src/dev/development.md:246
msgid "Ensures consistent output formatting"
msgstr "確保輸出格式一致"

#: src/dev/development.md:247
msgid "Avoids getting stuck in pagers like `less`"
msgstr "避免卡在像 `less` 這樣的分頁器中"

#: src/dev/development.md:248
msgid "Makes automation and scripting more reliable"
msgstr "使自動化和腳本更可靠"

#: src/dev/development.md:250
msgid "Troubleshooting Development Issues"
msgstr "疑難排解開發問題"

#: src/dev/development.md:252
msgid "**Recovering from Broken Edit Tools**"
msgstr "**從損壞的編輯工具中恢復**"

#: src/dev/development.md:253
msgid ""
"If edit tools in your IDE or development environment are broken/"
"malfunctioning, you can use git to recover:"
msgstr ""

#: src/dev/development.md:255
msgid "# Discard changes to a specific file\n"
msgstr ""

#: src/dev/development.md:258
msgid "# Discard all changes in the working directory\n"
msgstr ""

#: src/dev/development.md:261
msgid "# Revert to a specific commit\n"
msgstr ""

#: src/dev/development.md:264
msgid ""
"This approach is especially useful when tools that normally handle editing "
"break unexpectedly"
msgstr ""

#: src/dev/development.md:265
msgid ""
"Always verify what you're checking out before executing the command to avoid "
"losing important changes"
msgstr ""

#: src/dev/development.md:267
msgid "AI Agent Testing Instructions"
msgstr "AI 代理測試說明"

#: src/dev/development.md:269
msgid "**Terminal Interruption Issues**"
msgstr "**終端中斷問題**"

#: src/dev/development.md:270
msgid "If you are an AI agent working on Chester code and notice:"
msgstr "如果你是一個處理 Chester 代碼的 AI 代理並注意到："

#: src/dev/development.md:271
msgid "Frequent `^C` characters appearing in command output"
msgstr "命令輸出中頻繁出現 `^C` 字符"

#: src/dev/development.md:272
msgid "Commands being interrupted prematurely"
msgstr "命令被提前中斷"

#: src/dev/development.md:273
msgid "Test results not displaying properly"
msgstr "測試結果顯示不正確"

#: src/dev/development.md:274
msgid "Terminal output being cut off"
msgstr "終端輸出被切斷"

#: src/dev/development.md:275
msgid "STOP attempting to run tests and:"
msgstr "停止嘗試運行測試並且："

#: src/dev/development.md:276
msgid "Inform the user about the terminal connection issues"
msgstr "告知用戶有關終端連接問題"

#: src/dev/development.md:277
msgid "Ask the user to run the tests manually"
msgstr "請用戶手動運行測試"

#: src/dev/development.md:278
msgid "Request that the user provide the test results"
msgstr "請用戶提供測試結果"

#: src/dev/development.md:279
msgid ""
"This indicates a problem with the terminal connection, not with the code "
"itself"
msgstr "這表示終端連接存在問題，而非代碼本身的問題"

#: src/dev/development.md:281
msgid "**Test Running Best Practices for AI Agents**"
msgstr "**AI 代理運行測試的最佳實踐**"

#: src/dev/development.md:282
msgid "**ALWAYS use these exact commands for running tests:**"
msgstr "**始終使用這些確切的命令來運行測試：**"

#: src/dev/development.md:284
msgid "# Run all tests\n"
msgstr ""

#: src/dev/development.md:287
msgid "# Run a specific test class (include quotation marks)\n"
msgstr ""

#: src/dev/development.md:290
msgid ""
"**NEVER** attempt to run tests with other project paths like `cli/test`, "
"`semantic/test`, etc."
msgstr ""
"**切勿**嘗試使用其他項目路徑（如 `cli/test`、`semantic/test` 等）來運行測試。"

#: src/dev/development.md:292
msgid ""
"Example of what NOT to do: `sbt \"rootJVM/testOnly "
"chester.tyck.FilesTyckTest -z myTest\"`"
msgstr ""

#: src/dev/development.md:293
msgid "The `-z` flag is completely broken and will cause misleading results"
msgstr ""

#: src/dev/development.md:294
msgid "Tests might appear to pass when they should fail"
msgstr ""

#: src/dev/development.md:295
msgid "Using `-z` will lead to incorrect conclusions about code behavior"
msgstr ""

#: src/dev/development.md:296
msgid "⚠️ **CRITICAL: NEVER use `--` to pass arguments to tests** ⚠️"
msgstr ""

#: src/dev/development.md:297
msgid "Example of what NOT to do: `sbt \"rootJVM/testOnly -- -t MyTest\"`"
msgstr ""

#: src/dev/development.md:298
msgid "This will cause tests to run incorrectly or not at all"
msgstr ""

#: src/dev/development.md:299
msgid "No arguments should be passed after the test class name"
msgstr ""

#: src/dev/development.md:300
msgid "Always run full test suites rather than individual tests when possible"
msgstr ""

#: src/dev/development.md:301
msgid "Verify that terminal commands execute completely before proceeding"
msgstr ""

#: src/dev/development.md:302
msgid "If a test command produces an error about not finding the test class:"
msgstr ""

#: src/dev/development.md:303
msgid "First try the full `rootJVM/test` command to run all tests"
msgstr ""

#: src/dev/development.md:304
msgid "Then check if the test class path is correct"
msgstr ""

#: src/dev/development.md:305
msgid "Do not experiment with different project paths"
msgstr ""

#: src/dev/development.md:306
msgid ""
"If tests are taking too long to complete, inform the user and suggest they "
"run the tests locally"
msgstr ""

#: src/dev/development.md:308
#, fuzzy
msgid "Term System Architecture"
msgstr "Chester 讀取器架構"

#: src/dev/development.md:310
msgid ""
"Chester uses a unified term representation architecture to support multiple "
"platforms:"
msgstr ""

#: src/dev/development.md:312
#, fuzzy
msgid "Term Definition Structure"
msgstr "文檔結構"

#: src/dev/development.md:314
msgid "**Unified Term Definition**"
msgstr ""

#: src/dev/development.md:315
msgid ""
"All term types are defined in a single file: `syntax/shared/src/main/scala/"
"chester/syntax/core/Term.scala`"
msgstr ""

#: src/dev/development.md:316
msgid ""
"This approach simplifies the codebase and eliminates the need for separate "
"platform-specific implementations"
msgstr ""

#: src/dev/development.md:317
msgid ""
"Each term type follows a consistent pattern with standard methods and field "
"annotations"
msgstr ""

#: src/dev/development.md:319
msgid "Import Guidelines"
msgstr ""

#: src/dev/development.md:321
msgid "**DO** use `import chester.syntax.core.*`"
msgstr ""

#: src/dev/development.md:322
msgid "This will give you access to all term implementations"
msgstr ""

#: src/dev/development.md:325 src/dev/development.md:338
msgid "// CORRECT"
msgstr ""

#: src/dev/development.md:327
msgid "// INCORRECT - unnecessarily specific imports"
msgstr ""

#: src/dev/development.md:333
msgid "Pattern Matching and Type Usage"
msgstr "模式匹配和類型使用"

#: src/dev/development.md:335
msgid "Use concrete term types directly for pattern matching:"
msgstr ""

#: src/dev/development.md:346
#, fuzzy
msgid "Term Type Implementation Pattern"
msgstr "效果系統實現計劃"

#: src/dev/development.md:348
msgid "All term types follow a consistent implementation pattern:"
msgstr ""

#: src/dev/development.md:352
msgid "// Use @child for term fields that should be traversed"
msgstr ""

#: src/dev/development.md:353
msgid "// Use @const for non-term fields "
msgstr ""

#: src/dev/development.md:358
msgid "// Pretty printing method"
msgstr ""

#: src/dev/development.md:360
#, fuzzy
msgid "\"ExampleTerm(\""
msgstr "範例"

#: src/dev/development.md:360 src/dev/development.md:389
msgid "\")\""
msgstr ""

#: src/dev/development.md:362
msgid "// Tree traversal method"
msgstr ""

#: src/dev/development.md:368
msgid "Adding New Term Types"
msgstr ""

#: src/dev/development.md:370
#, fuzzy
msgid "When adding a new term type:"
msgstr "添加新的開發文檔時："

#: src/dev/development.md:372
msgid "Add it directly to `Term.scala`"
msgstr ""

#: src/dev/development.md:373
#, fuzzy
msgid "Follow the existing pattern for similar term types"
msgstr "遵循現有的文檔風格和結構"

#: src/dev/development.md:374
msgid "Implement all required methods (`toDoc`, `descent`, etc.)"
msgstr ""

#: src/dev/development.md:375
msgid "Use correct field annotations (`@child`, `@const`)"
msgstr ""

#: src/dev/development.md:376
msgid "Extend the appropriate base type (e.g., `TypeTerm`, `ExprTerm`)"
msgstr ""

#: src/dev/development.md:378
msgid "Example: Adding a New Term Type"
msgstr ""

#: src/dev/development.md:380
msgid "For example, to add a new term type for union types:"
msgstr ""

#: src/dev/development.md:389
msgid "\"UnionType(\""
msgstr ""

#: src/dev/development.md:389
msgid "\", \""
msgstr ""

#: src/dev/development.md:395
#, fuzzy
msgid "Key Term Types"
msgstr "Chester 類型"

#: src/dev/development.md:397
msgid "The system includes several important term categories:"
msgstr ""

#: src/dev/development.md:399
msgid ""
"**Expression Terms**: Represent runtime values (variables, function calls, "
"literals)"
msgstr ""

#: src/dev/development.md:400
msgid ""
"**Type Terms**: Represent type information (primitive types, function types, "
"union types)"
msgstr ""

#: src/dev/development.md:401
msgid ""
"**Statement Terms**: Represent declarations and control flow (let/def "
"bindings, trait definitions)"
msgstr ""

#: src/dev/development.md:402
msgid "**Pattern Terms**: Represent pattern matching constructs"
msgstr ""

#: src/dev/development.md:403
msgid ""
"**Special Terms**: Represent special language constructs (holes, "
"placeholders)"
msgstr ""

#: src/dev/development.md:405
msgid "Each category has a base trait that defines its common behavior."
msgstr ""

#: src/dev/development.md:407
msgid "Why This Matters"
msgstr ""

#: src/dev/development.md:409
msgid ""
"**Simplified Architecture**: The unified term definition makes the codebase "
"more maintainable"
msgstr ""

#: src/dev/development.md:410
msgid ""
"**Cross-Platform Compatibility**: All platforms use the same term "
"representation"
msgstr ""

#: src/dev/development.md:411
msgid ""
"**Consistent Patterns**: All term types follow the same implementation "
"pattern"
msgstr ""

#: src/dev/development.md:412
msgid ""
"**Easier Extensions**: Adding new term types follows a clear and consistent "
"approach"
msgstr ""

#: src/dev/development.md:414
msgid "Elaboration and Reduction Strategy"
msgstr ""

#: src/dev/development.md:416
msgid "Reduction During Type Checking"
msgstr ""

#: src/dev/development.md:418
msgid "**Keep Original Forms**"
msgstr ""

#: src/dev/development.md:419
msgid "The elaborator MUST preserve original terms in the elaborated result"
msgstr ""

#: src/dev/development.md:420
msgid "NEVER reduce during elaboration"
msgstr ""

#: src/dev/development.md:421 src/dev/elaboration-system.md:220
msgid ""
"Only use reduction internally during type checking when absolutely necessary"
msgstr ""

#: src/dev/development.md:422
msgid "This makes the elaborated code identical to source code, making it:"
msgstr ""

#: src/dev/development.md:423
msgid "Easier to debug"
msgstr ""

#: src/dev/development.md:424
msgid "Easier to understand"
msgstr ""

#: src/dev/development.md:425
msgid "Better for error messages"
msgstr ""

#: src/dev/development.md:426
msgid "More suitable for further transformations"
msgstr ""

#: src/dev/development.md:428
msgid "**When to Reduce**"
msgstr ""

#: src/dev/development.md:429
msgid "Only TWO places should use reduction:"
msgstr ""

#: src/dev/development.md:430
msgid "Type equality checking in unification"
msgstr ""

#: src/dev/development.md:431
msgid "Field access checking on type-level terms"
msgstr ""

#: src/dev/development.md:432 src/dev/tyck-improvement-proposal.md:177
msgid "Use `ReduceMode.TypeLevel` for these internal reductions"
msgstr ""

#: src/dev/development.md:433
msgid "NEVER use reduction in elaborated results"
msgstr ""

#: src/dev/development.md:435
msgid "Example:"
msgstr "範例："

#: src/dev/development.md:437
msgid "// Original code"
msgstr ""

#: src/dev/development.md:441
msgid "// WRONG - reducing during elaboration:"
msgstr ""

#: src/dev/development.md:444
msgid "// RIGHT - keeping original term:"
msgstr ""

#: src/dev/development.md:447
msgid "// RIGHT - internal reduction only for field checking:"
msgstr ""

#: src/dev/development.md:450
msgid "// Use type-level reduction only for checking field existence"
msgstr ""

#: src/dev/development.md:451
msgid "// Keep original term in result"
msgstr ""

#: src/dev/development.md:452 src/dev/devlog.md:755 src/dev/devlog.md:764
#: src/dev/devlog.md:921
msgid "// ..."
msgstr ""

#: src/dev/development.md:456
msgid "Reduction Context and Type Checking"
msgstr ""

#: src/dev/development.md:458
msgid "**Reduction Context Setup**"
msgstr ""

#: src/dev/development.md:459
msgid ""
"Each `Context` instance provides its own reduction context via "
"`toReduceContext`"
msgstr ""

#: src/dev/development.md:460
msgid "This ensures consistent reduction behavior during type checking"
msgstr ""

#: src/dev/development.md:461
msgid "Allows for future extensions to reduction context"
msgstr ""

#: src/dev/development.md:463
msgid "**Type-Level Reduction**"
msgstr ""

#: src/dev/development.md:464
msgid "Only reduce type-level terms when necessary for type checking"
msgstr ""

#: src/dev/development.md:465 src/dev/tyck-improvement-proposal.md:170
msgid "Keep original terms in elaborated results"
msgstr ""

#: src/dev/development.md:466
msgid "Use `ReduceMode.TypeLevel` to control reduction behavior"
msgstr ""

#: src/dev/development.md:468
msgid "**Field Access Checking**"
msgstr ""

#: src/dev/development.md:469
msgid "Use type-level reduction to verify field existence"
msgstr ""

#: src/dev/development.md:470
msgid "Keep original terms in field access expressions"
msgstr ""

#: src/dev/development.md:471
msgid "Report errors using original terms for better error messages"
msgstr ""

#: src/dev/development.md:473
msgid "Common Pitfalls"
msgstr ""

#: src/dev/development.md:475
msgid "**Over-reduction**"
msgstr ""

#: src/dev/development.md:476
msgid "Don't reduce terms during elaboration"
msgstr ""

#: src/dev/development.md:477
msgid "Don't reduce terms when adding to context"
msgstr ""

#: src/dev/development.md:478
msgid "Only reduce when needed for type checking"
msgstr ""

#: src/dev/development.md:480
msgid "**Loss of Original Terms**"
msgstr ""

#: src/dev/development.md:481
msgid "Always preserve original terms in elaborated results"
msgstr ""

#: src/dev/development.md:482
msgid "Don't reflect internal reductions in output"
msgstr ""

#: src/dev/development.md:483
msgid "Keep source code structure intact"
msgstr ""

#: src/dev/development.md:485
msgid "**Incorrect Reduction Context**"
msgstr ""

#: src/dev/development.md:486
msgid "Always use proper reduction context from current context"
msgstr ""

#: src/dev/development.md:487
msgid "Don't create new reduction contexts unnecessarily"
msgstr ""

#: src/dev/development.md:488
msgid "Use consistent reduction mode for type checking"
msgstr ""

#: src/dev/development.md:490
msgid "Coding Conventions"
msgstr ""

#: src/dev/development.md:492
msgid "Imports"
msgstr ""

#: src/dev/development.md:494
msgid ""
"**Document Utilities:** When using utilities from the `chester.utils.doc` "
"package (such as `Doc`, `PrettierOptions`, or extension methods like "
"`render`), prefer using a single wildcard import: `import "
"chester.utils.doc.*`."
msgstr ""

#: src/dev/development.md:496
msgid "String Formatting and Internationalization"
msgstr ""

#: src/dev/development.md:498
msgid "**Use Template Strings for User-Facing Text**"
msgstr ""

#: src/dev/development.md:499
msgid ""
"ALWAYS use template strings (`t\"\"`) for user-facing messages, not string "
"interpolation (`s\"\"`)"
msgstr ""

#: src/dev/development.md:500
msgid ""
"ALWAYS use template strings (`t\"\"`) for plain user-facing text, even "
"without variables"
msgstr ""

#: src/dev/development.md:501
msgid "Always import the internationalization package: `import chester.i18n.*`"
msgstr ""

#: src/dev/development.md:502
msgid "This ensures proper internationalization and localization support"
msgstr ""

#: src/dev/development.md:504
msgid "// CORRECT - using template strings for user-facing text"
msgstr ""

#: src/dev/development.md:507
msgid "\"Alice\""
msgstr ""

#: src/dev/development.md:508
msgid "t\"Hello $username, welcome to Chester!\""
msgstr ""

#: src/dev/development.md:510
msgid "// CORRECT - using template strings for plain text without variables"
msgstr ""

#: src/dev/development.md:511
msgid "t\"Operation failed. Please try again.\""
msgstr ""

#: src/dev/development.md:513
msgid "// INCORRECT - using string interpolation for user-facing text"
msgstr ""

#: src/dev/development.md:514
msgid "s\"Hello $username, welcome to Chester!\""
msgstr ""

#: src/dev/development.md:516
msgid "// INCORRECT - using regular string literals for user-facing text"
msgstr ""

#: src/dev/development.md:517
msgid "\"Operation failed. Please try again.\""
msgstr ""

#: src/dev/development.md:520
msgid "**String Interpolation for Internal Use Only**"
msgstr ""

#: src/dev/development.md:521
msgid ""
"Only use string interpolation (`s\"\"`) for internal, non-user-facing strings"
msgstr ""

#: src/dev/development.md:522
msgid ""
"Examples include debug logging, internal identifiers, and non-displayed text"
msgstr ""

#: src/dev/development.md:524
msgid "// CORRECT - using string interpolation for internal/technical content"
msgstr ""

#: src/dev/development.md:525
msgid "s\"DEBUG: Processing request from $username with params $params\""
msgstr ""

#: src/dev/development.md:526
msgid "s\"${"
msgstr ""

#: src/dev/development.md:526
msgid "}_${"
msgstr ""

#: src/dev/development.md:526
msgid "}\""
msgstr ""

#: src/dev/development.md:530
msgid "Template strings enable automatic translation and localization"
msgstr ""

#: src/dev/development.md:531
msgid "They maintain consistent messaging across the application"
msgstr ""

#: src/dev/development.md:532
msgid "They allow for future language additions without code changes"
msgstr ""

#: src/dev/development.md:533
msgid "They ensure a better experience for non-English users"
msgstr ""

#: src/dev/development.md:535
msgid "Core Principles"
msgstr ""

#: src/dev/development.md:537
msgid "**Use C-style Braces**"
msgstr ""

#: src/dev/development.md:538
msgid "Always use braces for control structures, even for single-line blocks"
msgstr ""

#: src/dev/development.md:539
msgid "Opening brace on the same line"
msgstr ""

#: src/dev/development.md:540
msgid "Closing brace on its own line"
msgstr ""

#: src/dev/development.md:542 src/dev/development.md:563
#: src/dev/development.md:584 src/dev/development.md:598
#: src/dev/development.md:619 src/dev/development.md:648
msgid "// Good"
msgstr ""

#: src/dev/development.md:549
msgid "// Bad - No braces"
msgstr ""

#: src/dev/development.md:553
msgid "// Bad - Indentation-based syntax"
msgstr ""

#: src/dev/development.md:556
msgid "// Unclear scope"
msgstr ""

#: src/dev/development.md:559
msgid "**No Indentation-Based Syntax**"
msgstr ""

#: src/dev/development.md:560
msgid "Do not rely on indentation for scope"
msgstr ""

#: src/dev/development.md:561
msgid "Always use explicit braces to define scope"
msgstr ""

#: src/dev/development.md:572
msgid "// Bad - Indentation-based"
msgstr ""

#: src/dev/development.md:580
msgid "**Function Definitions**"
msgstr ""

#: src/dev/development.md:581
msgid "Opening brace on the same line as the function definition"
msgstr ""

#: src/dev/development.md:582
msgid "Use explicit return types"
msgstr ""

#: src/dev/development.md:586 src/dev/development.md:591
msgid "// implementation"
msgstr ""

#: src/dev/development.md:589 src/dev/development.md:608
#: src/dev/development.md:627 src/dev/development.md:655
msgid "// Bad"
msgstr ""

#: src/dev/development.md:594
msgid "**Pattern Matching**"
msgstr ""

#: src/dev/development.md:595
msgid "Use braces for case blocks"
msgstr ""

#: src/dev/development.md:596
msgid "Align case statements"
msgstr ""

#: src/dev/development.md:616
msgid "**For Comprehensions**"
msgstr ""

#: src/dev/development.md:617
msgid "Use braces instead of indentation"
msgstr ""

#: src/dev/development.md:634
msgid "Additional Guidelines"
msgstr ""

#: src/dev/development.md:636
msgid "Use parentheses for method calls even when they could be omitted"
msgstr ""

#: src/dev/development.md:637
msgid "Prefer multi-line formatting with braces for complex expressions"
msgstr ""

#: src/dev/development.md:638
msgid "Use explicit type annotations for public APIs"
msgstr ""

#: src/dev/development.md:639
msgid "Keep line length reasonable (max 120 characters)"
msgstr ""

#: src/dev/development.md:640
msgid "Use two-space indentation within braces"
msgstr ""

#: src/dev/development.md:642
msgid "Enum Usage"
msgstr ""

#: src/dev/development.md:644
msgid "**Prefer Enums Over String Literals**"
msgstr ""

#: src/dev/development.md:645
msgid "Use enums for representing categories, types, or states"
msgstr ""

#: src/dev/development.md:646
msgid "Never use string literals as pseudo-enums"
msgstr ""

#: src/dev/development.md:656
msgid "\"CELL\" // Using string literals as enum values"
msgstr ""

#: src/dev/development.md:659
msgid "**Enum Naming Conventions**"
msgstr ""

#: src/dev/development.md:660
msgid "Use PascalCase for enum type names"
msgstr ""

#: src/dev/development.md:661
msgid "Use PascalCase for enum values"
msgstr ""

#: src/dev/development.md:662
msgid "Keep enum names clear and descriptive"
msgstr ""

#: src/dev/development.md:664
msgid "**Enum Usage**"
msgstr ""

#: src/dev/development.md:665
msgid "Import enum values when needed"
msgstr ""

#: src/dev/development.md:666
msgid "Use qualified access for clarity in other contexts"
msgstr ""

#: src/dev/development.md:667
msgid "Use pattern matching for exhaustive handling"
msgstr ""

#: src/dev/development.md:669
msgid "// Good usage"
msgstr ""

#: src/dev/development.md:681
msgid "Debugging Practices"
msgstr ""

#: src/dev/development.md:683
msgid "**Understand Before Fixing**"
msgstr ""

#: src/dev/development.md:684
msgid ""
"Always understand the root cause of an issue before attempting to fix it"
msgstr ""

#: src/dev/development.md:685
msgid ""
"Use the Debug utility with appropriate categories to trace program execution"
msgstr ""

#: src/dev/development.md:686
msgid "Analyze call stacks to identify where issues occur"
msgstr ""

#: src/dev/development.md:687
msgid "Create minimal test cases that reproduce the issue"
msgstr ""

#: src/dev/development.md:689
msgid "**Systematic Debugging Process**"
msgstr ""

#: src/dev/development.md:690
msgid "Enable relevant debug logging (`Debug.enable(DebugCategory.XXX)`)"
msgstr ""

#: src/dev/development.md:691
msgid "Add strategic logging points to track object state and method execution"
msgstr ""

#: src/dev/development.md:692
msgid "Verify assumptions about code behavior using logs and assertions"
msgstr ""

#: src/dev/development.md:693
msgid "Isolate the issue by creating focused test cases"
msgstr ""

#: src/dev/development.md:694
msgid "Document your findings to help others understand the problem"
msgstr ""

#: src/dev/development.md:696
msgid "**Debug-First Approach**"
msgstr ""

#: src/dev/development.md:697
msgid "When facing complex issues, prioritize debugging over immediate fixes"
msgstr ""

#: src/dev/development.md:698
msgid ""
"Add temporary debugging code when needed, but mark it clearly and remove "
"when done"
msgstr ""

#: src/dev/development.md:699
msgid "Consider adding permanent debugging hooks for areas prone to issues"
msgstr ""

#: src/dev/development.md:700
msgid "Document debugging insights even if they seem obvious"
msgstr ""

#: src/dev/devlog.md:3
msgid "2025-04-24"
msgstr ""

#: src/dev/devlog.md:5
msgid "LexerV2 Parser Completion"
msgstr ""

#: src/dev/devlog.md:7
msgid "**Completed Implementation**:"
msgstr ""

#: src/dev/devlog.md:8
msgid "**Block Termination Pattern**"
msgstr ""

#: src/dev/devlog.md:9
msgid "Implemented robust `}\\n` pattern detection with context awareness"
msgstr ""

#: src/dev/devlog.md:10
msgid ""
"Added state tracking via `newLineAfterBlockMeansEnds` flag in LexerState"
msgstr ""

#: src/dev/devlog.md:11
msgid "Ensured consistent handling between V1/V2 parsers"
msgstr ""

#: src/dev/devlog.md:12
msgid "Preserved uniform symbol treatment principles"
msgstr ""

#: src/dev/devlog.md:14
msgid "**Object Expression Enhancements**"
msgstr ""

#: src/dev/devlog.md:15
msgid "Added comprehensive support for multiple key types:"
msgstr ""

#: src/dev/devlog.md:16 src/dev/reader.md:96
msgid "Identifier keys (e.g., `{ x = 1 }`)"
msgstr ""

#: src/dev/devlog.md:17 src/dev/reader.md:97
msgid "String literal keys (e.g., `{ \"x\" = 1 }`)"
msgstr ""

#: src/dev/devlog.md:18 src/dev/reader.md:98
msgid "Symbol literal keys (e.g., `{ 'x = 1 }`)"
msgstr ""

#: src/dev/devlog.md:19
msgid "Implemented support for both `=` and `=>` operators in object clauses"
msgstr ""

#: src/dev/devlog.md:20
msgid "Added proper field parsing with comma-separated clauses"
msgstr ""

#: src/dev/devlog.md:21
msgid "Enhanced error reporting for malformed objects"
msgstr ""

#: src/dev/devlog.md:23
msgid "**Comment Handling Optimization**"
msgstr ""

#: src/dev/devlog.md:24
msgid "Replaced recursive comment collection with more efficient methods"
msgstr ""

#: src/dev/devlog.md:25
msgid ""
"Implemented `skipComments()` and `pullComments()` for better performance"
msgstr ""

#: src/dev/devlog.md:26
msgid "Added metadata merging for proper comment preservation"
msgstr ""

#: src/dev/devlog.md:27
msgid "Ensured consistent handling across different parsing contexts"
msgstr ""

#: src/dev/devlog.md:29
msgid "**Function Call and Block Argument Improvements**"
msgstr ""

#: src/dev/devlog.md:30
msgid "Added special handling for blocks used as function arguments"
msgstr ""

#: src/dev/devlog.md:31
msgid ""
"Implemented context-aware parsing of function calls with block arguments"
msgstr ""

#: src/dev/devlog.md:32
msgid "Ensured proper metadata preservation for source positions"
msgstr ""

#: src/dev/devlog.md:33
msgid "Added consistent handling of nested function calls"
msgstr ""

#: src/dev/devlog.md:35 src/dev/devlog.md:145
msgid "**Implementation Strategy**:"
msgstr ""

#: src/dev/devlog.md:36
msgid "Used token-based state machine approach for better performance"
msgstr ""

#: src/dev/devlog.md:37 src/dev/devlog.md:147
msgid "Maintained uniform symbol treatment for all operators"
msgstr ""

#: src/dev/devlog.md:38
msgid "Implemented comprehensive error handling"
msgstr ""

#: src/dev/devlog.md:39
msgid "Added extensive debug logging for easier maintenance"
msgstr ""

#: src/dev/devlog.md:41 src/dev/devlog.md:849
msgid "**Completed Features**:"
msgstr "**已完成功能**："

#: src/dev/devlog.md:42 src/dev/devlog.md:153
msgid "✅ Block termination with context tracking"
msgstr ""

#: src/dev/devlog.md:43
msgid "✅ Object expressions with multiple key types"
msgstr ""

#: src/dev/devlog.md:44
msgid "✅ Comment preservation and optimization"
msgstr ""

#: src/dev/devlog.md:45
msgid "✅ Function call and block argument handling"
msgstr ""

#: src/dev/devlog.md:46
msgid ""
"✅ **⚠️ IMPORTANT**: Flat operator sequence representation without precedence "
"handling (intentional design principle, often misunderstood)"
msgstr ""

#: src/dev/devlog.md:48 src/dev/devlog.md:89 src/dev/devlog.md:122
#: src/dev/devlog.md:220 src/dev/devlog.md:560 src/dev/devlog.md:600
#: src/dev/devlog.md:631 src/dev/devlog.md:680 src/dev/devlog.md:937
#: src/dev/devlog.md:1544
msgid "**Files Modified**:"
msgstr ""

#: src/dev/devlog.md:49 src/dev/devlog.md:1545
msgid "`reader/shared/src/main/scala/chester/readerv2/LexerV2.scala`"
msgstr ""

#: src/dev/devlog.md:50
msgid "Documentation files"
msgstr ""

#: src/dev/devlog.md:52
msgid "2025-04-21"
msgstr ""

#: src/dev/devlog.md:54
msgid "Simplified Type Constraint System by Removing Hacky Approach"
msgstr ""

#: src/dev/devlog.md:56
msgid ""
"**Problem**: The previous approach for handling type constraints used a "
"complicated \"cell coverage\" system that felt like a hack. The "
"`AutoConnect` propagator and `createTermStructureConstraints` method added "
"unnecessary complexity and indirection to the type system."
msgstr ""

#: src/dev/devlog.md:58
msgid ""
"**Solution**: Completely redesigned the approach to directly handle type "
"relationships without intermediate propagators."
msgstr ""

#: src/dev/devlog.md:60
msgid "**Implementation Details**:"
msgstr "**實現細節**："

#: src/dev/devlog.md:61
msgid "**Removed Hacky Components**:"
msgstr ""

#: src/dev/devlog.md:62
msgid "Eliminated the `AutoConnect` propagator entirely"
msgstr ""

#: src/dev/devlog.md:63
msgid ""
"Removed `establishTypeConstraints` and all related \"cell coverage\" methods"
msgstr ""

#: src/dev/devlog.md:64
msgid "Simplified the code by removing several layers of indirection"
msgstr ""

#: src/dev/devlog.md:66
msgid "**Direct Type Relationship Handling**:"
msgstr ""

#: src/dev/devlog.md:67
msgid "Added direct connections between types directly during unification"
msgstr ""

#: src/dev/devlog.md:68
msgid "Created explicit relationships between union types and their components"
msgstr ""

#: src/dev/devlog.md:69
msgid "Connected function call components immediately when encountered"
msgstr ""

#: src/dev/devlog.md:70
msgid ""
"Simplified codebase by handling type constraints at the point where types "
"are created or unified"
msgstr ""

#: src/dev/devlog.md:72
msgid "**Improved Union Type Management**:"
msgstr ""

#: src/dev/devlog.md:73
msgid ""
"Enhanced handling of union-to-union subtyping with direct component "
"connections"
msgstr ""

#: src/dev/devlog.md:74
msgid "Improved union-to-specific and specific-to-union handling"
msgstr ""

#: src/dev/devlog.md:75
msgid "Created clearer, more maintainable code for union type relationships"
msgstr ""

#: src/dev/devlog.md:77
msgid "**Function Call Processing**:"
msgstr ""

#: src/dev/devlog.md:78
msgid "Implemented direct processing of function call components"
msgstr ""

#: src/dev/devlog.md:79
msgid "Added recursive handling for nested function calls"
msgstr ""

#: src/dev/devlog.md:80
msgid "Eliminated redundant constraint establishment code"
msgstr ""

#: src/dev/devlog.md:82 src/dev/devlog.md:127 src/dev/devlog.md:233
#: src/dev/devlog.md:645 src/dev/devlog.md:954 src/dev/devlog.md:972
#: src/dev/devlog.md:989 src/dev/devlog.md:1005 src/dev/devlog.md:1020
#: src/dev/devlog.md:1061 src/dev/devlog.md:1080 src/dev/devlog.md:1098
#: src/dev/devlog.md:1116 src/dev/devlog.md:1521
msgid "**Benefits**:"
msgstr ""

#: src/dev/devlog.md:83
msgid ""
"**Cleaner Code**: Removed a complicated system that was difficult to reason "
"about"
msgstr ""

#: src/dev/devlog.md:84
msgid ""
"**More Direct**: Handles type constraints at the point where types are "
"created or unified"
msgstr ""

#: src/dev/devlog.md:85
msgid ""
"**Better Maintainability**: Simpler, more understandable code with fewer "
"moving parts"
msgstr ""

#: src/dev/devlog.md:86
msgid ""
"**Less Indirection**: Eliminated multiple layers of function calls for basic "
"operations"
msgstr ""

#: src/dev/devlog.md:87
msgid ""
"**Same Functionality**: Maintains the same type checking capabilities with "
"cleaner implementation"
msgstr ""

#: src/dev/devlog.md:90 src/dev/devlog.md:123 src/dev/devlog.md:601
#: src/dev/devlog.md:681 src/dev/devlog.md:938
msgid "`semantic/shared/src/main/scala/chester/tyck/TyckPropagator.scala`"
msgstr ""

#: src/dev/devlog.md:91 src/dev/devlog.md:124 src/dev/devlog.md:602
#: src/dev/devlog.md:939
msgid "`semantic/shared/src/main/scala/chester/tyck/Elaborater.scala`"
msgstr ""

#: src/dev/devlog.md:93
msgid "**Verification**:"
msgstr ""

#: src/dev/devlog.md:94
msgid "All existing tests continue to pass"
msgstr ""

#: src/dev/devlog.md:95
msgid "Compiler successfully builds the project"
msgstr ""

#: src/dev/devlog.md:96
msgid "Type error reporting works as expected"
msgstr ""

#: src/dev/devlog.md:98
msgid "Replaced EnsureCellCoverage Hack with AutoConnect Propagator"
msgstr ""

#: src/dev/devlog.md:100 src/dev/devlog.md:570 src/dev/devlog.md:655
msgid "**Implemented Improvements**:"
msgstr ""

#: src/dev/devlog.md:101
msgid "**Replaced EnsureCellCoverage with AutoConnect**"
msgstr ""

#: src/dev/devlog.md:102
msgid ""
"Removed the old placeholder EnsureCellCoverage propagator that only marked "
"cells as covered"
msgstr ""

#: src/dev/devlog.md:103
msgid ""
"Implemented new AutoConnect propagator that establishes proper type "
"connections based on term structure"
msgstr ""

#: src/dev/devlog.md:104
msgid ""
"Added logic to analyze different term types (unions, intersections, function "
"calls) and create appropriate connections"
msgstr ""

#: src/dev/devlog.md:106
msgid "**Enhanced Cell Coverage Mechanisms**"
msgstr ""

#: src/dev/devlog.md:107
msgid ""
"Added support for creating proper connections between terms and their "
"components"
msgstr ""

#: src/dev/devlog.md:108
msgid ""
"Implemented smart term structure analysis to establish meaningful type "
"relationships"
msgstr ""

#: src/dev/devlog.md:109
msgid ""
"Added default value support for unconstrained type variables using Any type"
msgstr ""

#: src/dev/devlog.md:111
msgid "**Improved Function Call Handling**"
msgstr ""

#: src/dev/devlog.md:112
msgid "Added recursive connection for function calls and their arguments"
msgstr ""

#: src/dev/devlog.md:113
msgid ""
"Special handling for complex argument terms including nested function calls"
msgstr ""

#: src/dev/devlog.md:114
msgid ""
"Improved handling of CallingArgTerm to ensure all components are properly "
"connected"
msgstr ""

#: src/dev/devlog.md:116 src/dev/devlog.md:687
msgid "**Implementation Approach**:"
msgstr ""

#: src/dev/devlog.md:117
msgid "Replaced all EnsureCellCoverage instances with AutoConnect calls"
msgstr ""

#: src/dev/devlog.md:118
msgid "Updated Elaborater and TyckPropagator to use the new approach"
msgstr ""

#: src/dev/devlog.md:119
msgid "Added cell management helper methods and proper zonking support"
msgstr ""

#: src/dev/devlog.md:120
msgid "Added support for default values in unconstrained cells"
msgstr ""

#: src/dev/devlog.md:125
msgid ""
"`semantic/shared/src/main/scala/chester/utils/propagator/ProvideCellId.scala`"
msgstr ""

#: src/dev/devlog.md:128
msgid "Eliminated artificial cell coverage without meaningful constraints"
msgstr ""

#: src/dev/devlog.md:129
msgid "Improved type error detection through proper constraint checking"
msgstr ""

#: src/dev/devlog.md:130
msgid "Reduced conceptual complexity in the propagator network"
msgstr ""

#: src/dev/devlog.md:131
msgid "Enhanced maintainability as the type system evolves"
msgstr ""

#: src/dev/devlog.md:132
msgid "Fixed cell coverage issues for union types and other complex types"
msgstr ""

#: src/dev/devlog.md:134
msgid "2025-04-05"
msgstr ""

#: src/dev/devlog.md:136
msgid "LexerV2 Parser Enhancements"
msgstr ""

#: src/dev/devlog.md:138
msgid ""
"**Block Termination**: Implemented context tracking for `}\\n` pattern "
"detection, ensuring consistent handling between V1/V2 parsers while "
"preserving uniform symbol treatment"
msgstr ""

#: src/dev/devlog.md:139
msgid ""
"**Object Expressions**: Added support for identifier, string, and symbol "
"keys with both `=` and `=>` operators"
msgstr ""

#: src/dev/devlog.md:140
msgid "**Token Optimization**:"
msgstr ""

#: src/dev/devlog.md:141
msgid "Simplified token extractors using common helper methods"
msgstr ""

#: src/dev/devlog.md:142
msgid "Enhanced comment collection and attachment"
msgstr ""

#: src/dev/devlog.md:143
msgid "Improved handling of leading/trailing comments"
msgstr ""

#: src/dev/devlog.md:146
msgid "Added context tracking for block termination"
msgstr ""

#: src/dev/devlog.md:148
msgid "Enhanced object expression parsing"
msgstr ""

#: src/dev/devlog.md:149
msgid "Optimized token handling for better maintainability"
msgstr ""

#: src/dev/devlog.md:151
msgid "**Migration Status**:"
msgstr ""

#: src/dev/devlog.md:152
msgid "✅ Pattern matching with proper block handling"
msgstr ""

#: src/dev/devlog.md:154
msgid "✅ Basic object expressions"
msgstr ""

#: src/dev/devlog.md:155
msgid "✅ Comment preservation"
msgstr ""

#: src/dev/devlog.md:156
msgid "🟡 Complex object expressions (in progress)"
msgstr ""

#: src/dev/devlog.md:157
msgid "🔴 Source maps and error recovery (planned)"
msgstr ""

#: src/dev/devlog.md:159
msgid "**Modified**: `LexerV2.scala`, documentation files"
msgstr ""

#: src/dev/devlog.md:161
msgid "2025-03-14"
msgstr ""

#: src/dev/devlog.md:163
msgid "Parser Improvements and Refactoring"
msgstr ""

#: src/dev/devlog.md:164 src/dev/devlog.md:884
msgid "**Completed Improvements**:"
msgstr ""

#: src/dev/devlog.md:165
msgid "**Operator Precedence Enhancement**"
msgstr ""

#: src/dev/devlog.md:166
msgid "**Issue**: Complex operator sequences not handled correctly"
msgstr ""

#: src/dev/devlog.md:167
msgid "**Improvement**: Added operator precedence table and parsing logic"
msgstr ""

#: src/dev/devlog.md:168
msgid "**Benefits**: Better handling of complex expressions"
msgstr ""

#: src/dev/devlog.md:169
msgid "**Implementation**: Added precedence table and parsing logic"
msgstr ""

#: src/dev/devlog.md:171
msgid "**Whitespace Handling Enhancement**"
msgstr ""

#: src/dev/devlog.md:172
msgid "**Issue**: Inconsistent whitespace handling"
msgstr ""

#: src/dev/devlog.md:173
msgid "**Improvement**: Added dedicated whitespace parsing"
msgstr ""

#: src/dev/devlog.md:174
msgid "**Benefits**: More consistent parsing behavior"
msgstr ""

#: src/dev/devlog.md:175
msgid "**Implementation**: Added whitespace parsing logic"
msgstr ""

#: src/dev/devlog.md:177
msgid "**Error Recovery Enhancement**"
msgstr ""

#: src/dev/devlog.md:178
msgid "**Issue**: Parser failed on first error"
msgstr ""

#: src/dev/devlog.md:179
msgid "**Improvement**: Added error recovery mechanisms"
msgstr ""

#: src/dev/devlog.md:180
msgid "**Benefits**: Better error reporting and recovery"
msgstr ""

#: src/dev/devlog.md:181
msgid "**Implementation**: Added error recovery logic"
msgstr ""

#: src/dev/devlog.md:183
msgid "**Token Type Enhancement**"
msgstr ""

#: src/dev/devlog.md:184
msgid "**Issue**: Limited token type support"
msgstr ""

#: src/dev/devlog.md:185
msgid "**Improvement**: Added more token types"
msgstr ""

#: src/dev/devlog.md:186
msgid "**Benefits**: Better token categorization"
msgstr ""

#: src/dev/devlog.md:187
msgid "**Implementation**: Added new token types"
msgstr ""

#: src/dev/devlog.md:189
msgid "**Source Position Tracking**"
msgstr ""

#: src/dev/devlog.md:190
msgid "**Issue**: Inaccurate error locations"
msgstr ""

#: src/dev/devlog.md:191
msgid "**Improvement**: Enhanced position tracking"
msgstr ""

#: src/dev/devlog.md:192
msgid "**Benefits**: Better error messages"
msgstr ""

#: src/dev/devlog.md:193
msgid "**Implementation**: Added position tracking"
msgstr ""

#: src/dev/devlog.md:195
msgid "**Test Coverage Enhancement**"
msgstr ""

#: src/dev/devlog.md:196
msgid "**Issue**: Limited test coverage"
msgstr ""

#: src/dev/devlog.md:197
msgid "**Improvement**: Added more test cases"
msgstr ""

#: src/dev/devlog.md:198
msgid "**Benefits**: Better code quality"
msgstr ""

#: src/dev/devlog.md:199
msgid "**Implementation**: Added test cases"
msgstr ""

#: src/dev/devlog.md:201
msgid "**Uniform Operator Handling**"
msgstr ""

#: src/dev/devlog.md:202
msgid "**Issue**: Special case handling for \"=>\" operator"
msgstr ""

#: src/dev/devlog.md:203
msgid "**Improvement**: Removed special cases, unified operator parsing"
msgstr ""

#: src/dev/devlog.md:204
msgid "**Benefits**: More consistent operator handling"
msgstr ""

#: src/dev/devlog.md:205 src/dev/devlog.md:214 src/dev/devlog.md:959
#: src/dev/devlog.md:977 src/dev/devlog.md:993 src/dev/devlog.md:1009
#: src/dev/devlog.md:1024 src/dev/devlog.md:1066 src/dev/devlog.md:1085
#: src/dev/devlog.md:1103 src/dev/devlog.md:1121
msgid "**Implementation**:"
msgstr "**實作**："

#: src/dev/devlog.md:206
msgid "Removed special case in `parseOperator()`"
msgstr ""

#: src/dev/devlog.md:207
msgid "Now using StringBuilder for all operators"
msgstr ""

#: src/dev/devlog.md:208
msgid "All tests passing"
msgstr ""

#: src/dev/devlog.md:210
msgid "**LexerV2 Optimization and Refactoring**"
msgstr ""

#: src/dev/devlog.md:211
msgid "**Issue**: Code duplication and maintainability issues"
msgstr ""

#: src/dev/devlog.md:212
msgid "**Improvement**: Restructured for modularity and conciseness"
msgstr ""

#: src/dev/devlog.md:213
msgid "**Benefits**: Better code organization and maintainability"
msgstr ""

#: src/dev/devlog.md:215
msgid "Extracted repeated logic into helper methods"
msgstr ""

#: src/dev/devlog.md:216
msgid "Improved state management"
msgstr ""

#: src/dev/devlog.md:217
msgid "Fixed compilation error (replaced advance() with state.advance())"
msgstr ""

#: src/dev/devlog.md:218
msgid ""
"Remaining warnings about unused private members and pattern match "
"exhaustiveness"
msgstr ""

#: src/dev/devlog.md:221 src/dev/devlog.md:837 src/dev/devlog.md:1492
msgid "`reader/src/main/scala/chester/readerv2/LexerV2.scala`"
msgstr ""

#: src/dev/devlog.md:222
msgid "`reader/src/main/scala/chester/readerv2/Tokenizer.scala`"
msgstr ""

#: src/dev/devlog.md:223
msgid "**Tests**: All existing tests passing"
msgstr ""

#: src/dev/devlog.md:225
msgid "V1/V2 Semantic Consistency"
msgstr ""

#: src/dev/devlog.md:226 src/dev/devlog.md:240 src/dev/devlog.md:249
msgid "**Implementation Plan**:"
msgstr "**實現計劃**："

#: src/dev/devlog.md:227
msgid ""
"Analyze test files still using `parseAndCheck` to identify semantic "
"differences"
msgstr ""

#: src/dev/devlog.md:228
msgid "Prioritize addressing the complex operator sequence handling first"
msgstr ""

#: src/dev/devlog.md:229
msgid "Implement proper handling for prefix and mixfix operators in V2"
msgstr ""

#: src/dev/devlog.md:230
msgid "Test and verify with existing test cases"
msgstr ""

#: src/dev/devlog.md:231
msgid "Update tests to use `parseAndCheckBoth` once they pass"
msgstr ""

#: src/dev/devlog.md:232
msgid "Document any intentional semantic differences that won't be addressed"
msgstr ""

#: src/dev/devlog.md:234
msgid "More consistent parsing behavior between V1 and V2"
msgstr ""

#: src/dev/devlog.md:235
msgid "Higher confidence in V2 parser for all use cases"
msgstr ""

#: src/dev/devlog.md:236
msgid "Easier migration path from V1 to V2"
msgstr ""

#: src/dev/devlog.md:237
msgid "More tests running against both parsers"
msgstr ""

#: src/dev/devlog.md:239
msgid "Object Expressions"
msgstr ""

#: src/dev/devlog.md:241
msgid "Review current object parsing implementation"
msgstr ""

#: src/dev/devlog.md:242
msgid "Identify missing features compared to V1"
msgstr ""

#: src/dev/devlog.md:243
msgid "Implement support for complex object syntax"
msgstr ""

#: src/dev/devlog.md:244
msgid "Test with a variety of object expressions"
msgstr ""

#: src/dev/devlog.md:246
msgid "Telescope Parsing"
msgstr ""

#: src/dev/devlog.md:247
msgid "**Issue**: Telescope parsing is not yet implemented in V2"
msgstr ""

#: src/dev/devlog.md:248
msgid ""
"**Improvement**: Implement telescope parsing in V2 to match V1 semantics"
msgstr ""

#: src/dev/devlog.md:250
msgid "Analyze V1 telescope parsing implementation"
msgstr ""

#: src/dev/devlog.md:251
msgid "Design and implement equivalent functionality in V2"
msgstr ""

#: src/dev/devlog.md:252
msgid "Test with existing telescope tests"
msgstr ""

#: src/dev/devlog.md:254
msgid "Block Termination and Newline Handling in V2 Parser"
msgstr ""

#: src/dev/devlog.md:256
msgid "Problem Analysis:"
msgstr ""

#: src/dev/devlog.md:257
msgid ""
"When examining why the pattern matching test fails with V2 parser, I "
"identified several issues:"
msgstr ""

#: src/dev/devlog.md:259
msgid "**Newline Handling:**"
msgstr ""

#: src/dev/devlog.md:260
msgid ""
"V1 parser has implicit newline handling that affects expression termination"
msgstr ""

#: src/dev/devlog.md:261
msgid "This is particularly important for blocks that end with `}`"
msgstr ""

#: src/dev/devlog.md:262
msgid ""
"V2 parser needs to check for `Token.Newline` after a block and terminate "
"expressions appropriately"
msgstr ""

#: src/dev/devlog.md:263
msgid "This affects the `parseRest` method in `LexerV2.scala`"
msgstr ""

#: src/dev/devlog.md:265
msgid "**Pattern Matching Block Structure:**"
msgstr ""

#: src/dev/devlog.md:266
msgid "Pattern matching has a unique structure: `identifier match { ... }`"
msgstr ""

#: src/dev/devlog.md:267
msgid ""
"The V2 parser needs a general approach to handle this construct without "
"introducing special cases"
msgstr ""

#: src/dev/devlog.md:268
msgid ""
"The challenge is maintaining uniform handling while correctly parsing "
"pattern matching"
msgstr ""

#: src/dev/devlog.md:270
msgid "**Test Compatibility:**"
msgstr ""

#: src/dev/devlog.md:271
msgid "Many tests use `parseAndCheckBoth` which runs both V1 and V2 parsers"
msgstr ""

#: src/dev/devlog.md:272
msgid ""
"Tests with newlines after blocks fail because V2 doesn't terminate "
"expressions correctly"
msgstr ""

#: src/dev/devlog.md:273
msgid "Pattern matching tests are particularly affected by this issue"
msgstr ""

#: src/dev/devlog.md:275
msgid "**StringIndexOutOfBoundsException in Error Reporting:**"
msgstr ""

#: src/dev/devlog.md:276
msgid ""
"When using `parseAndCheckBoth`, error reporting code in "
"`parseAndCheck.scala` can throw `StringIndexOutOfBoundsException`"
msgstr ""

#: src/dev/devlog.md:277
msgid "This happens when trying to extract line information for error messages"
msgstr ""

#: src/dev/devlog.md:278
msgid "Requires bounds checking to prevent exceptions"
msgstr ""

#: src/dev/devlog.md:280
msgid "**Parser Architecture Tradeoffs:**"
msgstr ""

#: src/dev/devlog.md:281
msgid "We need to balance flexibility with consistency"
msgstr ""

#: src/dev/devlog.md:282
msgid ""
"Simple tokenization approach makes it hard to handle significant whitespace/"
"newlines"
msgstr ""

#: src/dev/devlog.md:283
msgid ""
"Excessive special cases make the parser harder to maintain and reason about"
msgstr ""

#: src/dev/devlog.md:284
msgid ""
"**Context-free parsing is strongly preferred over context-dependent "
"approaches**"
msgstr ""

#: src/dev/devlog.md:285
msgid ""
"A simple, uniform rule (like always ending an OpSeq when seeing `}\\n`) is "
"better than complex contextual rules"
msgstr ""

#: src/dev/devlog.md:287
msgid "Possible Approaches:"
msgstr ""

#: src/dev/devlog.md:289
msgid "**Context-Free Newline Handling (PREFERRED):**"
msgstr ""

#: src/dev/devlog.md:290
msgid ""
"Always end OpSeq expression when encountering `}\\n` (closing brace followed "
"by newline)"
msgstr ""

#: src/dev/devlog.md:291
msgid "Apply this rule uniformly regardless of surrounding context"
msgstr ""

#: src/dev/devlog.md:292
msgid "Uniform treatment of all block terminations without special cases"
msgstr ""

#: src/dev/devlog.md:293
msgid "No need to track or analyze the meaning of identifiers like \"match\""
msgstr ""

#: src/dev/devlog.md:294
msgid ""
"Simple, predictable parsing behavior that aligns with Chester's design "
"principles"
msgstr ""

#: src/dev/devlog.md:296
msgid "**Token Differentiation Strategy:**"
msgstr ""

#: src/dev/devlog.md:297
msgid "Enhance tokenizer to differentiate between whitespace and newlines"
msgstr ""

#: src/dev/devlog.md:298
msgid "This allows the parser to recognize expression boundaries better"
msgstr ""

#: src/dev/devlog.md:299
msgid "Requires minimal special-casing in the parser"
msgstr ""

#: src/dev/devlog.md:301
msgid "**Whitespace with Newline Flag:**"
msgstr ""

#: src/dev/devlog.md:302
msgid ""
"Instead of creating a separate `Token.Newline` class, enhance "
"`Token.Whitespace` with a boolean flag"
msgstr ""

#: src/dev/devlog.md:303
msgid ""
"Add a `canActAsNewline` flag to indicate if this whitespace contains "
"characters that can terminate expressions"
msgstr ""

#: src/dev/devlog.md:304
msgid ""
"This simplifies tokenization while still providing the necessary information "
"to the parser"
msgstr ""

#: src/dev/devlog.md:305
msgid ""
"Reduces token type proliferation and maintains a cleaner token hierarchy"
msgstr ""

#: src/dev/devlog.md:306
msgid ""
"Parser can check `token.isWhitespace && token.canActAsNewline` when making "
"termination decisions"
msgstr ""

#: src/dev/devlog.md:307
msgid ""
"Avoids the overhead of creating a completely new token type while gaining "
"the same benefits"
msgstr ""

#: src/dev/devlog.md:309
msgid "**Enhanced Block Parsing:**"
msgstr ""

#: src/dev/devlog.md:310
msgid ""
"Modify block parsing to handle different types of blocks in a more general "
"way"
msgstr ""

#: src/dev/devlog.md:311
msgid "Use structural information rather than keyword recognition"
msgstr ""

#: src/dev/devlog.md:312
msgid ""
"This approach maintains parser consistency while handling pattern matching"
msgstr ""

#: src/dev/devlog.md:314
msgid "**Contextual Parsing (LEAST PREFERRED):**"
msgstr ""

#: src/dev/devlog.md:315
msgid ""
"Use context information to parse expressions differently in different "
"situations"
msgstr ""

#: src/dev/devlog.md:316
msgid "For pattern matching, recognize the context and adjust parsing rules"
msgstr ""

#: src/dev/devlog.md:317
msgid "More complex and violates the preference for context-free parsing"
msgstr ""

#: src/dev/devlog.md:318
msgid "Harder to maintain and reason about"
msgstr ""

#: src/dev/devlog.md:320
msgid ""
"**Recommended Approach:** The **Context-Free Newline Handling** approach "
"combined with the **Whitespace with Newline Flag** provides the simplest and "
"most maintainable solution. This approach:"
msgstr ""

#: src/dev/devlog.md:322
msgid "Maintains Chester's core design principles of uniform symbol treatment"
msgstr ""

#: src/dev/devlog.md:323
msgid "Preserves strict separation of parsing from semantic analysis"
msgstr ""

#: src/dev/devlog.md:324
msgid ""
"Applies a consistent rule for all block terminations without special cases"
msgstr ""

#: src/dev/devlog.md:325
msgid "Avoids context-dependent parsing which is harder to maintain"
msgstr ""

#: src/dev/devlog.md:326
msgid ""
"Treats `}\\n` as a syntactic boundary in all contexts, which is simpler and "
"more predictable"
msgstr ""

#: src/dev/devlog.md:328
msgid ""
"The parser should simply terminate an OpSeq when encountering a `}\\n` "
"pattern, regardless of what identifiers (like \"match\") may be present in "
"the sequence. This maintains the context-free nature of the parser and "
"avoids the complexity of context-dependent rules."
msgstr ""

#: src/dev/devlog.md:330
msgid "Integration with Existing Code:"
msgstr ""

#: src/dev/devlog.md:332
msgid ""
"The proposed changes will affect several components of the current codebase:"
msgstr ""

#: src/dev/devlog.md:334
msgid "**Consistency with Operator Handling:**"
msgstr ""

#: src/dev/devlog.md:335
msgid ""
"The parser will continue to treat all symbols uniformly, including 'match'"
msgstr ""

#: src/dev/devlog.md:336
msgid "No special precedence rules will be added in the parser itself"
msgstr ""

#: src/dev/devlog.md:337
msgid "Pattern matching will be represented as a standard OpSeq in the AST"
msgstr ""

#: src/dev/devlog.md:338
msgid ""
"Any special handling of 'match' will occur in subsequent passes, not in the "
"parser"
msgstr ""

#: src/dev/devlog.md:340
msgid "**Interaction with Block Parsing:**"
msgstr ""

#: src/dev/devlog.md:341
msgid "Block parsing will remain unchanged"
msgstr ""

#: src/dev/devlog.md:342
msgid "The parser will create a standard OpSeq structure for match expressions"
msgstr ""

#: src/dev/devlog.md:343
msgid "Semantic analysis of pattern matching occurs after parsing, not during"
msgstr ""

#: src/dev/devlog.md:345
msgid "Performance Considerations:"
msgstr ""

#: src/dev/devlog.md:347
msgid "**Token Differentiation Impact:**"
msgstr ""

#: src/dev/devlog.md:348
msgid ""
"Adding Token.Newline will slightly increase token count but with negligible "
"memory overhead"
msgstr ""

#: src/dev/devlog.md:349
msgid "Parsing performance should not be significantly affected"
msgstr ""

#: src/dev/devlog.md:350
msgid ""
"May improve performance by reducing backtracking and error recovery needs"
msgstr ""

#: src/dev/devlog.md:352
msgid "**Operator-Based Solution Efficiency:**"
msgstr ""

#: src/dev/devlog.md:353
msgid "Leverages existing operator handling machinery"
msgstr ""

#: src/dev/devlog.md:354
msgid "No additional parsing passes required"
msgstr ""

#: src/dev/devlog.md:355
msgid "Consistent with current performance profile of operator parsing"
msgstr ""

#: src/dev/devlog.md:359
msgid "**Current Parsing Result (V1):**"
msgstr ""

#: src/dev/devlog.md:361
msgid "// Input:"
msgstr ""

#: src/dev/devlog.md:366
msgid "// AST (simplified):"
msgstr ""

#: src/dev/devlog.md:369 src/dev/devlog.md:384
msgid "\"notification\""
msgstr ""

#: src/dev/devlog.md:370 src/dev/devlog.md:385
msgid "\"match\""
msgstr ""

#: src/dev/devlog.md:372 src/dev/devlog.md:373 src/dev/devlog.md:387
#: src/dev/devlog.md:388
msgid "\"case\""
msgstr ""

#: src/dev/devlog.md:372 src/dev/devlog.md:387
msgid "\"Email\""
msgstr ""

#: src/dev/devlog.md:372 src/dev/devlog.md:373 src/dev/devlog.md:387
#: src/dev/devlog.md:388
msgid "\"=>\""
msgstr ""

#: src/dev/devlog.md:373 src/dev/devlog.md:388
msgid "\"SMS\""
msgstr ""

#: src/dev/devlog.md:378
msgid "**Desired V2 Parsing Result:**"
msgstr ""

#: src/dev/devlog.md:380
msgid "// Same input should produce identical AST structure with flat OpSeq"
msgstr ""

#: src/dev/devlog.md:380
msgid ""
"// The parser has no knowledge of what 'match' means - it's just an "
"identifier"
msgstr ""

#: src/dev/devlog.md:381
msgid "// Structure interpretation happens in later passes, not during parsing"
msgstr ""

#: src/dev/devlog.md:393
msgid "Reference Implementation Strategy:"
msgstr ""

#: src/dev/devlog.md:395
msgid "**Phased Approach:**"
msgstr ""

#: src/dev/devlog.md:396
msgid "First implement the whitespace enhancement with newline flag"
msgstr ""

#: src/dev/devlog.md:397
msgid "Ensure the parser treats 'match' just like any other identifier"
msgstr ""

#: src/dev/devlog.md:398
msgid "Verify match expressions produce standard OpSeq nodes"
msgstr ""

#: src/dev/devlog.md:399
msgid ""
"Test with existing pattern matching tests to ensure correct AST structure"
msgstr ""

#: src/dev/devlog.md:401
msgid "**Validation Criteria:**"
msgstr ""

#: src/dev/devlog.md:402
msgid "All existing tests should pass when using both parsers"
msgstr ""

#: src/dev/devlog.md:403
msgid "Parser should produce identical AST structures for both V1 and V2"
msgstr ""

#: src/dev/devlog.md:404
msgid "No special handling for any identifiers including 'match' in the parser"
msgstr ""

#: src/dev/devlog.md:405
msgid "Maintain uniform treatment of symbols throughout the parser"
msgstr ""

#: src/dev/devlog.md:406
msgid "Preserve strict separation between parsing and semantic analysis"
msgstr ""

#: src/dev/devlog.md:408
msgid "Learning from Other Languages:"
msgstr ""

#: src/dev/devlog.md:410
msgid "**Scala's Approach:**"
msgstr ""

#: src/dev/devlog.md:411
msgid "Scala treats 'match' as a special keyword with defined precedence"
msgstr ""

#: src/dev/devlog.md:412
msgid "Pattern matching is handled as a distinct grammar construct"
msgstr "模式匹配被處理為獨特的語法結構"

#: src/dev/devlog.md:413
msgid "This differs from Chester's uniform symbol treatment philosophy"
msgstr ""

#: src/dev/devlog.md:415
msgid "**Rust's Approach:**"
msgstr ""

#: src/dev/devlog.md:416
msgid "Rust uses match expressions with block-based syntax"
msgstr ""

#: src/dev/devlog.md:417
msgid "Parser explicitly recognizes the 'match' keyword"
msgstr ""

#: src/dev/devlog.md:418
msgid "Arms of match expressions have specific parsing rules"
msgstr ""

#: src/dev/devlog.md:419
msgid ""
"Chester can adapt Rust's block structure handling while maintaining uniform "
"symbol treatment"
msgstr ""

#: src/dev/devlog.md:421
msgid "Backward Compatibility Guarantees:"
msgstr ""

#: src/dev/devlog.md:423
msgid "**Parsing Output Compatibility:**"
msgstr ""

#: src/dev/devlog.md:424
msgid ""
"The V2 parser will produce ASTs semantically equivalent to V1 for pattern "
"matching"
msgstr ""

#: src/dev/devlog.md:425
msgid ""
"Existing code that consumes ASTs will continue to work without modification"
msgstr ""

#: src/dev/devlog.md:426
msgid "The structure of OpSeq nodes for pattern matching will be preserved"
msgstr ""

#: src/dev/devlog.md:428
msgid "**What Might Change:**"
msgstr ""

#: src/dev/devlog.md:429
msgid "Internal source position information might be slightly different"
msgstr ""

#: src/dev/devlog.md:430
msgid "Comment attachment points could vary in edge cases"
msgstr ""

#: src/dev/devlog.md:431
msgid "Error messages may be more precise or different in wording"
msgstr ""

#: src/dev/devlog.md:433
msgid "Transition Plan:"
msgstr ""

#: src/dev/devlog.md:435
msgid "**For Test Code:**"
msgstr ""

#: src/dev/devlog.md:436
msgid "Gradually migrate tests from parseAndCheck to parseAndCheckBoth"
msgstr ""

#: src/dev/devlog.md:437
msgid "Document any tests that must remain on V1 parser temporarily"
msgstr ""

#: src/dev/devlog.md:438
msgid "Add specific tests for pattern matching edge cases"
msgstr ""

#: src/dev/devlog.md:440
msgid "**For Production Code:**"
msgstr ""

#: src/dev/devlog.md:441
msgid "The V2 parser implementation can be introduced behind a feature flag"
msgstr ""

#: src/dev/devlog.md:442
msgid "Allow both parsers to run in parallel initially for validation"
msgstr ""

#: src/dev/devlog.md:443
msgid "Collect metrics on parsing compatibility and performance"
msgstr ""

#: src/dev/devlog.md:444
msgid "Full migration only after all tests pass with both parsers"
msgstr ""

#: src/dev/devlog.md:446
msgid "**For Documentation:**"
msgstr ""

#: src/dev/devlog.md:447
msgid "Update parser documentation to reflect the new approach"
msgstr ""

#: src/dev/devlog.md:448
msgid "Provide migration notes for any edge cases"
msgstr ""

#: src/dev/devlog.md:449
msgid "Document the rationale behind the design decisions"
msgstr ""

#: src/dev/devlog.md:451
msgid "Implementation Plan:"
msgstr ""

#: src/dev/devlog.md:453
msgid "**Whitespace Enhancement:**"
msgstr ""

#: src/dev/devlog.md:454
msgid "Enhance `Token.Whitespace` with a `canActAsNewline` flag"
msgstr ""

#: src/dev/devlog.md:455
msgid ""
"Modify tokenizer to set this flag appropriately when encountering newline "
"characters"
msgstr ""

#: src/dev/devlog.md:456
msgid "Keep token handling simple and uniform"
msgstr ""

#: src/dev/devlog.md:458
msgid "**Context-Free Expression Termination:**"
msgstr ""

#: src/dev/devlog.md:459
msgid ""
"Update `LexerV2.parseRest()` to implement simple `}\\n` termination rule"
msgstr ""

#: src/dev/devlog.md:460
msgid ""
"Add condition: `if (previousToken == \"}\" && currentToken.isWhitespace && "
"currentToken.canActAsNewline)`"
msgstr ""

#: src/dev/devlog.md:461
msgid ""
"Always terminate OpSeq when this pattern is encountered, regardless of "
"context"
msgstr ""

#: src/dev/devlog.md:462
msgid "No special cases or context-dependent decisions"
msgstr ""

#: src/dev/devlog.md:463
msgid "Consistent rule application across all expressions"
msgstr ""

#: src/dev/devlog.md:465
msgid "**Uniform Symbol Treatment:**"
msgstr ""

#: src/dev/devlog.md:466
msgid ""
"Maintain the flat OpSeq production for all expressions including pattern "
"matching"
msgstr ""

#: src/dev/devlog.md:467
msgid "No special handling for any identifiers (including 'match')"
msgstr ""

#: src/dev/devlog.md:468
msgid ""
"Apply termination rules based purely on token patterns, not semantic meaning"
msgstr ""

#: src/dev/devlog.md:469
msgid "Let later passes handle pattern matching semantics"
msgstr ""

#: src/dev/devlog.md:471
msgid "**Error Handling Improvements:**"
msgstr ""

#: src/dev/devlog.md:472
msgid ""
"Add bounds checking in `parseAndCheck.scala` to prevent "
"`StringIndexOutOfBoundsException`"
msgstr ""

#: src/dev/devlog.md:473
msgid "Ensure safe substring extraction for error messages"
msgstr ""

#: src/dev/devlog.md:475
msgid "**Testing Strategy:**"
msgstr ""

#: src/dev/devlog.md:476
msgid ""
"Fix the core expression termination in V2 parser using the context-free "
"approach"
msgstr ""

#: src/dev/devlog.md:477
msgid "Verify pattern matching tests pass with both parsers"
msgstr ""

#: src/dev/devlog.md:478
msgid "Gradually migrate more tests to use `parseAndCheckBoth`"
msgstr ""

#: src/dev/devlog.md:480
msgid "Current Status:"
msgstr ""

#: src/dev/devlog.md:481
msgid "Need to implement newline token handling"
msgstr ""

#: src/dev/devlog.md:482
msgid "Need to enhance operator-based approach for pattern matching"
msgstr ""

#: src/dev/devlog.md:483
msgid "Need to improve error reporting with bounds checking"
msgstr ""

#: src/dev/devlog.md:484
msgid "Pattern matching test runs with V1 parser but fails with V2"
msgstr ""

#: src/dev/devlog.md:485
msgid ""
"More work needed on general parsing of pattern matching without special cases"
msgstr ""

#: src/dev/devlog.md:487
msgid "The `}\\n` Pattern Problem"
msgstr ""

#: src/dev/devlog.md:489
msgid ""
"The Chester parser treats the `}\\n` pattern (closing brace followed by "
"newline) as a significant syntax element for terminating expressions in "
"specific contexts. This pattern plays a crucial role in:"
msgstr ""

#: src/dev/devlog.md:491
msgid "**Function/Method Definitions**"
msgstr ""

#: src/dev/devlog.md:492
msgid ""
"```\n"
"def factorial(n) {\n"
"  if n <= 1 then 1\n"
"  else n * factorial(n - 1)\n"
"}  // <- newline here ends the function definition\n"
"\n"
"val result = factorial(5); // Next statement\n"
"```"
msgstr ""

#: src/dev/devlog.md:501
msgid "**Match Expressions**"
msgstr ""

#: src/dev/devlog.md:502
msgid ""
"```\n"
"val result = notification match {\n"
"  case Email(sender, _) => {\n"
"    println(sender);\n"
"    \"Email received\"\n"
"  }  // <- block for this case\n"
"  case SMS(number, _) => \"SMS received\";\n"
"}  // <- newline here ends the match expression\n"
"\n"
"println(result); // Next statement\n"
"```"
msgstr ""

#: src/dev/devlog.md:514
msgid "Current Implementation Issues"
msgstr ""

#: src/dev/devlog.md:516
msgid "In the V2 parser:"
msgstr ""

#: src/dev/devlog.md:517
msgid ""
"The `parseBlock` method in `LexerV2.scala` recognizes the closing brace "
"(`RBrace`) as terminating a block but doesn't consider what follows it "
"(newline or not)"
msgstr ""

#: src/dev/devlog.md:518
msgid ""
"This causes inconsistencies between V1 and V2 parsers in how expressions are "
"terminated"
msgstr ""

#: src/dev/devlog.md:519
msgid ""
"The V1 parser considers what comes after the closing brace, but the V2 "
"parser currently doesn't"
msgstr ""

#: src/dev/devlog.md:521
msgid "Proposed Solution"
msgstr ""

#: src/dev/devlog.md:523
msgid ""
"To address this issue while maintaining context-free parsing principles:"
msgstr ""

#: src/dev/devlog.md:525
msgid "**Extend Token State Tracking**"
msgstr ""

#: src/dev/devlog.md:526
msgid "Modify the `LexerState` to track if the previous token was a `RBrace`"
msgstr ""

#: src/dev/devlog.md:527
msgid "Add a helper method like `isAfterClosingBrace()` to check this state"
msgstr ""

#: src/dev/devlog.md:529
msgid "**Update Expression Termination Logic**"
msgstr ""

#: src/dev/devlog.md:530
msgid ""
"In key expression parsing methods, check for the `}\\n` pattern by testing "
"if:"
msgstr ""

#: src/dev/devlog.md:531
msgid "Previous token was `RBrace`"
msgstr ""

#: src/dev/devlog.md:532
msgid "Current token is `Whitespace` containing a newline or is `EOF`"
msgstr ""

#: src/dev/devlog.md:533
msgid ""
"This check should be made in both the `parseExpr` and `parseExprList` methods"
msgstr ""

#: src/dev/devlog.md:535
msgid "**Ensure Uniform Treatment**"
msgstr ""

#: src/dev/devlog.md:536
msgid ""
"Apply the same termination rules consistently across all expression contexts"
msgstr ""

#: src/dev/devlog.md:537
msgid ""
"This maintains the context-free parsing principle while addressing the "
"termination issue"
msgstr ""

#: src/dev/devlog.md:539
msgid "**Add Test Cases**"
msgstr ""

#: src/dev/devlog.md:540
msgid "Create specific test cases for the `}\\n` pattern in different contexts"
msgstr ""

#: src/dev/devlog.md:541
msgid "Verify that both parsers (V1 and V2) handle the pattern identically"
msgstr ""

#: src/dev/devlog.md:543
msgid ""
"This solution preserves the uniform symbol treatment principle while "
"ensuring that the `}\\n` pattern is properly handled as a syntactic "
"terminator where appropriate."
msgstr ""

#: src/dev/devlog.md:545
msgid "Implementation Strategy"
msgstr ""

#: src/dev/devlog.md:547
msgid ""
"Start with smaller, isolated improvements that don't affect the overall "
"architecture"
msgstr ""

#: src/dev/devlog.md:548
msgid "Add comprehensive tests before making significant changes"
msgstr ""

#: src/dev/devlog.md:549
msgid "Update one component fully before moving to the next"
msgstr ""

#: src/dev/devlog.md:550
msgid "Prioritize improvements that enhance maintainability first"
msgstr ""

#: src/dev/devlog.md:551
msgid ""
"Verify each change with existing tests before proceeding to the next "
"improvement"
msgstr ""

#: src/dev/devlog.md:552
msgid "Complete high-priority features like comment preservation"
msgstr ""

#: src/dev/devlog.md:553
msgid "Update documentation to reflect implementation progress"
msgstr ""

#: src/dev/devlog.md:555
msgid "2025-03-09"
msgstr ""

#: src/dev/devlog.md:557
msgid "Fixed OnceCell Concurrent Write Issue"
msgstr ""

#: src/dev/devlog.md:558
msgid ""
"**Root Cause**: Type-level function applications attempted multiple writes "
"to same OnceCell"
msgstr ""

#: src/dev/devlog.md:559
msgid "**Solution**: Added existence check before cell population"
msgstr ""

#: src/dev/devlog.md:561
msgid "`tyck/src/main/scala/chester/tyck/TyckPropagator.scala`"
msgstr ""

#: src/dev/devlog.md:562
msgid "`tyck/src/test/scala/chester/tyck/TypeCellSpec.scala`"
msgstr ""

#: src/dev/devlog.md:563
msgid "**Tests Added**:"
msgstr ""

#: src/dev/devlog.md:564
msgid "Concurrent type-level function application collisions"
msgstr ""

#: src/dev/devlog.md:565
msgid "Stress test with 100 parallel cell writes"
msgstr ""

#: src/dev/devlog.md:567
msgid "2025-03-15"
msgstr ""

#: src/dev/devlog.md:569
msgid "Type System Improvements Completed"
msgstr ""

#: src/dev/devlog.md:571
msgid "**Enhanced Type Structure Reduction in DefaultReducer**"
msgstr ""

#: src/dev/devlog.md:572
msgid "Improved `reduceTypeStructure` method to properly handle:"
msgstr ""

#: src/dev/devlog.md:573
msgid "Union types by recursively reducing their component types"
msgstr ""

#: src/dev/devlog.md:574
msgid "Intersection types with proper reduction"
msgstr ""

#: src/dev/devlog.md:575
msgid ""
"Type-level function applications with recursive reduction for complex result "
"types"
msgstr ""

#: src/dev/devlog.md:576
msgid "Enhanced handling of nested function applications"
msgstr ""

#: src/dev/devlog.md:578
msgid "**Alpha-Equivalence Checking in TyckPropagator**"
msgstr ""

#: src/dev/devlog.md:579
msgid "Enhanced `areAlphaEquivalent` method to:"
msgstr ""

#: src/dev/devlog.md:580
msgid "Properly handle function types with bound variables"
msgstr ""

#: src/dev/devlog.md:581
msgid "Compare union and intersection types correctly"
msgstr ""

#: src/dev/devlog.md:582
msgid "Fall back to regular equality for other cases"
msgstr ""

#: src/dev/devlog.md:583
msgid "Added bound variable tracking in alpha-equivalence"
msgstr ""

#: src/dev/devlog.md:585
msgid "**Enhanced Type Level Comparison**"
msgstr ""

#: src/dev/devlog.md:586
msgid "Improved type level comparison in `tryUnify` method:"
msgstr ""

#: src/dev/devlog.md:587
msgid ""
"Implemented more flexible compatibility rules between different level types"
msgstr ""

#: src/dev/devlog.md:588
msgid "Allow finite level types to be compatible with unrestricted level types"
msgstr ""

#: src/dev/devlog.md:589
msgid "Maintain controlled asymmetric compatibility"
msgstr ""

#: src/dev/devlog.md:591
msgid "**Cell Coverage Mechanisms**"
msgstr ""

#: src/dev/devlog.md:592
msgid "Added dedicated helper method to ensure cell coverage"
msgstr ""

#: src/dev/devlog.md:593
msgid "Implemented self-coverage for union type components"
msgstr ""

#: src/dev/devlog.md:594
msgid "Fixed early returns that left cells uncovered"
msgstr ""

#: src/dev/devlog.md:596
msgid "**TraitCallTerm Implementation**"
msgstr ""

#: src/dev/devlog.md:597
msgid "Added `TraitCallTerm` in Term.scala"
msgstr ""

#: src/dev/devlog.md:598
msgid "Laid groundwork for trait-record subtyping relationships"
msgstr ""

#: src/dev/devlog.md:603 src/dev/devlog.md:940
msgid "`semantic/shared/src/main/scala/chester/reduce/Reducer.scala`"
msgstr ""

#: src/dev/devlog.md:604 src/dev/devlog.md:632 src/dev/devlog.md:941
msgid "`syntax/shared/src/main/scala/chester/syntax/core/Term.scala`"
msgstr ""

#: src/dev/devlog.md:606 src/dev/devlog.md:698
msgid "**Next Steps**:"
msgstr "**下一步**："

#: src/dev/devlog.md:607
msgid "Complete trait-record subtyping implementation"
msgstr ""

#: src/dev/devlog.md:608
msgid "Implement union-to-union subtyping case"
msgstr ""

#: src/dev/devlog.md:609
msgid "Fix remaining cell coverage issues in union-subtype.chester"
msgstr ""

#: src/dev/devlog.md:610
msgid "Add comprehensive test suite for traits and union types"
msgstr ""

#: src/dev/devlog.md:612
msgid "2025-03-16"
msgstr ""

#: src/dev/devlog.md:614
msgid "Term Definition Refactoring"
msgstr ""

#: src/dev/devlog.md:615
msgid "**Implemented Changes**:"
msgstr ""

#: src/dev/devlog.md:616
msgid "**Unified Term Definitions**"
msgstr ""

#: src/dev/devlog.md:617
msgid "Consolidated all Term definitions into a single Term.scala file"
msgstr ""

#: src/dev/devlog.md:618
msgid "Eliminated the separate spec/simple/truffle files"
msgstr ""

#: src/dev/devlog.md:619
msgid "Simplified the codebase by removing the need for converters"
msgstr ""

#: src/dev/devlog.md:621
msgid "**Updated Documentation**"
msgstr ""

#: src/dev/devlog.md:622
msgid "Updated development.md with new Term implementation approach"
msgstr ""

#: src/dev/devlog.md:623
msgid "Updated tyck-improvement-proposal.md to reflect Term changes"
msgstr ""

#: src/dev/devlog.md:624
msgid "Updated type-checking-system.md with current Term usage examples"
msgstr ""

#: src/dev/devlog.md:626
msgid "**Simplified Type System**"
msgstr ""

#: src/dev/devlog.md:627
msgid "Removed the need for trait interfaces with \\*C and \\*F suffixes"
msgstr ""

#: src/dev/devlog.md:628
msgid "Streamlined the inheritance hierarchy"
msgstr ""

#: src/dev/devlog.md:629
msgid "Made the codebase more maintainable with simplified Term definitions"
msgstr ""

#: src/dev/devlog.md:633
msgid "`docs/src/dev/development.md`"
msgstr ""

#: src/dev/devlog.md:634
msgid "`docs/src/dev/tyck-improvement-proposal.md`"
msgstr ""

#: src/dev/devlog.md:635
msgid "`docs/src/dev/type-checking-system.md`"
msgstr ""

#: src/dev/devlog.md:636 src/dev/devlog.md:1548
msgid "`docs/src/dev/devlog.md`"
msgstr ""

#: src/dev/devlog.md:638
msgid "**Files Removed**:"
msgstr ""

#: src/dev/devlog.md:639
msgid "`syntax/shared/src/main/scala/chester/syntax/core/spec/Term.scala`"
msgstr ""

#: src/dev/devlog.md:640
msgid "`syntax/shared/src/main/scala/chester/syntax/core/simple.scala`"
msgstr ""

#: src/dev/devlog.md:641
msgid "`syntax/jvm/src/main/scala/chester/syntax/core/truffle.scala`"
msgstr ""

#: src/dev/devlog.md:642
msgid "`syntax/jvm/src/main/scala/chester/syntax/core/convertToTruffle.scala`"
msgstr ""

#: src/dev/devlog.md:643
msgid ""
"`syntax/shared/src/main/scala/chester/syntax/core/convertToSimple.scala`"
msgstr ""

#: src/dev/devlog.md:646
msgid "Simplified codebase structure"
msgstr ""

#: src/dev/devlog.md:647
msgid "Reduced code duplication"
msgstr ""

#: src/dev/devlog.md:648
msgid "Eliminated need for converters"
msgstr ""

#: src/dev/devlog.md:649
msgid "Made adding new Term types easier and less error-prone"
msgstr ""

#: src/dev/devlog.md:650
msgid "Improved maintainability"
msgstr ""

#: src/dev/devlog.md:652
msgid "2025-03-19"
msgstr ""

#: src/dev/devlog.md:654
msgid "Trait Implementation Completed"
msgstr ""

#: src/dev/devlog.md:656
msgid "**Basic Trait Support**"
msgstr ""

#: src/dev/devlog.md:657
msgid "Added support for empty traits and record extension using `<:` syntax"
msgstr ""

#: src/dev/devlog.md:658
msgid "Implemented trait-record subtyping relation in type system"
msgstr ""

#: src/dev/devlog.md:659
msgid "Added proper trait type representation with `TraitTypeTerm`"
msgstr ""

#: src/dev/devlog.md:660
msgid "Added appropriate error reporting for trait implementation issues"
msgstr ""

#: src/dev/devlog.md:662
msgid "**Modified Elaborater for Trait Handling**"
msgstr ""

#: src/dev/devlog.md:663
msgid ""
"Enhanced `ElaboraterBlock.processTraitStmt` to handle trait bodies properly"
msgstr ""

#: src/dev/devlog.md:664
msgid "Updated `processRecordStmt` to elaborate the `extendsClause` for traits"
msgstr ""

#: src/dev/devlog.md:665
msgid "Added handling for trait extension in subtyping relationships"
msgstr ""

#: src/dev/devlog.md:666
msgid "Implemented trait-to-trait inheritance checks in `TyckPropagator`"
msgstr ""

#: src/dev/devlog.md:668
msgid "**Trait Field Handling**"
msgstr ""

#: src/dev/devlog.md:669
msgid "Added special handling for field declarations within trait bodies"
msgstr ""

#: src/dev/devlog.md:670
msgid "Implemented context tracking to recognize trait processing context"
msgstr ""

#: src/dev/devlog.md:671
msgid "Added `withProcessingType` method to track context in elaboration"
msgstr ""

#: src/dev/devlog.md:672
msgid "Created system to handle trait field requirements (future work)"
msgstr ""

#: src/dev/devlog.md:674
msgid "**Error Types for Traits**"
msgstr ""

#: src/dev/devlog.md:675
msgid "Added `NotATrait` error type for using non-traits in extends clause"
msgstr ""

#: src/dev/devlog.md:676
msgid "Added `NotImplementingTrait` for trait implementation errors"
msgstr ""

#: src/dev/devlog.md:677
msgid "Added `MissingTraitField` for missing required trait fields"
msgstr ""

#: src/dev/devlog.md:678
msgid "Enhanced error reporting for trait-related issues"
msgstr ""

#: src/dev/devlog.md:682 src/dev/devlog.md:942
msgid "`semantic/shared/src/main/scala/chester/tyck/ElaboraterBlock.scala`"
msgstr ""

#: src/dev/devlog.md:683
msgid "`semantic/shared/src/main/scala/chester/tyck/Context.scala`"
msgstr ""

#: src/dev/devlog.md:684
msgid "`semantic/shared/src/main/scala/chester/tyck/Context2.scala`"
msgstr ""

#: src/dev/devlog.md:685
msgid "`tests/tyck/basic-trait.chester`"
msgstr ""

#: src/dev/devlog.md:688
msgid ""
"Created temporary solution for trait field declarations to get basic traits "
"working"
msgstr ""

#: src/dev/devlog.md:689
msgid "Added field for tracking processing context in the `Context` class"
msgstr ""

#: src/dev/devlog.md:690
msgid "Simplified trait checking to focus on basic extension relationship"
msgstr ""

#: src/dev/devlog.md:691
msgid "Used the propagator network for maintaining trait subtyping constraints"
msgstr ""

#: src/dev/devlog.md:693
msgid "**Test Status**:"
msgstr "**測試狀態**："

#: src/dev/devlog.md:694
msgid "All tests passing, including the basic-trait test"
msgstr ""

#: src/dev/devlog.md:695
msgid "Added support for more complex traits with field requirements"
msgstr ""

#: src/dev/devlog.md:696
msgid "Test coverage for basic trait extension and trait field access"
msgstr ""

#: src/dev/devlog.md:699
msgid ""
"Enhance trait field checking for complete field requirement verification"
msgstr ""

#: src/dev/devlog.md:700
msgid "Add support for multiple trait inheritance"
msgstr ""

#: src/dev/devlog.md:701
msgid "Implement trait method and default implementations"
msgstr ""

#: src/dev/devlog.md:702
msgid "Add more comprehensive trait test cases"
msgstr ""

#: src/dev/devlog.md:704
msgid "2025-03-22"
msgstr ""

#: src/dev/devlog.md:706
msgid "Pattern Matching Fix Implementation for V2 Parser"
msgstr ""

#: src/dev/devlog.md:708 src/dev/devlog.md:1455
msgid "Problem Analysis"
msgstr ""

#: src/dev/devlog.md:710
msgid ""
"The V2 parser was failing to correctly parse pattern matching expressions "
"with blocks after the `=>` operator. This issue was particularly visible in "
"the `match2` test in `PatternMatchingTest`, which showed a mismatch between "
"expected and actual AST structures."
msgstr ""

#: src/dev/devlog.md:712
msgid "Root Cause"
msgstr ""

#: src/dev/devlog.md:714
msgid "**Missing Context Tracking**:"
msgstr ""

#: src/dev/devlog.md:715
msgid ""
"V1 parser used `ParsingContext(newLineAfterBlockMeansEnds = true)` for "
"contextual parsing"
msgstr ""

#: src/dev/devlog.md:716
msgid ""
"V2 parser lacked this contextual awareness for block termination after "
"newlines"
msgstr ""

#: src/dev/devlog.md:718
msgid "**AST Structure Discrepancies**:"
msgstr ""

#: src/dev/devlog.md:719
msgid "V1 produces consistent OpSeq structures with Identifiers for operators"
msgstr ""

#: src/dev/devlog.md:720
msgid ""
"V2 wasn't properly maintaining this structure in pattern matching contexts"
msgstr ""

#: src/dev/devlog.md:722
msgid "Critical Insight: Uniform Symbol Treatment"
msgstr ""

#: src/dev/devlog.md:724
msgid ""
"The key insight that guided our solution was the need to maintain Chester's "
"uniform symbol treatment:"
msgstr ""

#: src/dev/devlog.md:726
msgid "V1 parser treats ALL operators uniformly with no special cases"
msgstr ""

#: src/dev/devlog.md:727
msgid "`=>` is handled as a plain identifier, not a special operator"
msgstr ""

#: src/dev/devlog.md:728
msgid "Context affects only block termination, not token parsing"
msgstr ""

#: src/dev/devlog.md:730 src/dev/devlog.md:1460
msgid "Implementation Approach"
msgstr "實作方法"

#: src/dev/devlog.md:732
msgid "We implemented a 3-step fix that maintains uniform symbol treatment:"
msgstr "我們實現了一個保持統一符號處理的三步驟修復方案："

#: src/dev/devlog.md:734
msgid "**Added Context to LexerState**:"
msgstr "**向 LexerState 添加上下文**："

#: src/dev/devlog.md:737
msgid "// Existing fields..."
msgstr ""

#: src/dev/devlog.md:746
msgid "**Updated `checkForRBraceNewlinePattern`**:"
msgstr ""

#: src/dev/devlog.md:747
msgid ""
"Added context-awareness to only terminate expressions in the right context"
msgstr ""

#: src/dev/devlog.md:748
msgid "Maintained the existing newline detection logic"
msgstr ""

#: src/dev/devlog.md:751
msgid "// Only consider }\\n as terminating if we're in the right context"
msgstr ""

#: src/dev/devlog.md:754
msgid "// Rest of existing implementation"
msgstr ""

#: src/dev/devlog.md:759
msgid "**Enabled Context for All Blocks**:"
msgstr ""

#: src/dev/devlog.md:763
msgid "// Rest of implementation using contextState"
msgstr ""

#: src/dev/devlog.md:768
msgid "AST Structure Matching"
msgstr ""

#: src/dev/devlog.md:770
msgid ""
"While the block termination fix allows basic pattern matching to work, there "
"remain differences in the AST structure between V1 and V2 parsers:"
msgstr ""

#: src/dev/devlog.md:772
msgid ""
"```\n"
"=> Diff (- expected, + obtained)\n"
"           meta = None\n"
"-        )\n"
"-      ),\n"
"-      meta = None\n"
"-    ),\n"
"-    OpSeq(\n"
"-      seq = Vector(\n"
"+        ),\n"
"         Identifier(\n"
"               Identifier(\n"
"+                name = \"name\",\n"
"+                meta = None\n"
"+              ),\n"
"+              Identifier(\n"
"                 name = ...,\n"
"                 meta = ...\n"
"-              ),\n"
"-              ...\n"
"+              )\n"
"             ),\n"
"```"
msgstr ""

#: src/dev/devlog.md:796
msgid ""
"These structural differences need to be resolved to ensure full "
"compatibility between parsers. Current theories:"
msgstr ""

#: src/dev/devlog.md:797
msgid "Different handling of nested OpSeq structures"
msgstr ""

#: src/dev/devlog.md:798
msgid "Variance in how block expressions are attached to pattern matches"
msgstr ""

#: src/dev/devlog.md:799
msgid "Potential issues with comment attachment or source positions"
msgstr ""

#: src/dev/devlog.md:801 src/dev/elaboration-system.md:205
msgid "Testing Approach"
msgstr ""

#: src/dev/devlog.md:803
msgid "We're using a phased testing approach:"
msgstr ""

#: src/dev/devlog.md:806
msgid "// Current test approach - used during development"
msgstr ""

#: src/dev/devlog.md:807
msgid "// Tests with V1 parser only"
msgstr ""

#: src/dev/devlog.md:808
msgid "// Goal after full AST compatibility is achieved"
msgstr ""

#: src/dev/devlog.md:810
msgid "// Tests with both V1 and V2 parsers"
msgstr ""

#: src/dev/devlog.md:813
msgid "Current tests in `PatternMatchingTest` show:"
msgstr ""

#: src/dev/devlog.md:814
msgid "All tests using `parseAndCheck` pass with V1 parser"
msgstr ""

#: src/dev/devlog.md:815
msgid ""
"Simple pattern matching (no blocks after `=>`) passes with "
"`parseAndCheckBoth`"
msgstr ""

#: src/dev/devlog.md:816
msgid "Complex pattern matching with blocks still shows AST differences"
msgstr ""

#: src/dev/devlog.md:818 src/dev/devlog.md:928 src/dev/devlog.md:1139
msgid "Next Steps"
msgstr ""

#: src/dev/devlog.md:820
msgid "Investigate exact AST structural differences"
msgstr ""

#: src/dev/devlog.md:821
msgid "Run detailed tests with AST structure dumps"
msgstr ""

#: src/dev/devlog.md:822
msgid "Compare parsing behavior for complex pattern matching"
msgstr ""

#: src/dev/devlog.md:824
msgid "Enhance debug output"
msgstr ""

#: src/dev/devlog.md:825
msgid "Add more detailed logging of AST structures"
msgstr ""

#: src/dev/devlog.md:826
msgid "Enable easier comparison between V1 and V2 outputs"
msgstr ""

#: src/dev/devlog.md:828
msgid "Add targeted fixes for AST compatibility"
msgstr ""

#: src/dev/devlog.md:829
msgid "Maintain uniform symbol treatment"
msgstr ""

#: src/dev/devlog.md:830
msgid "Ensure consistent structure for nested expressions"
msgstr ""

#: src/dev/devlog.md:832
msgid "Update tests to use `parseAndCheckBoth` when fully fixed"
msgstr ""

#: src/dev/devlog.md:833
msgid "Migrate tests incrementally as compatibility issues are resolved"
msgstr ""

#: src/dev/devlog.md:834
msgid "Document any intentional differences"
msgstr ""

#: src/dev/devlog.md:836 src/dev/devlog.md:1491
msgid "Files Modified"
msgstr ""

#: src/dev/devlog.md:839
msgid ""
"This implementation represents significant progress in aligning V1 and V2 "
"parser behaviors while maintaining Chester's core design principles of "
"uniform symbol treatment and context-free parsing."
msgstr ""

#: src/dev/devlog.md:841
msgid "2025-03-23"
msgstr ""

#: src/dev/devlog.md:843
msgid "Comprehensive Type System Improvements Summary"
msgstr ""

#: src/dev/devlog.md:845
msgid ""
"The type system for Chester has undergone significant improvements, "
"particularly in the areas of union types, cell coverage, and trait "
"implementation. Key completed improvements include:"
msgstr ""

#: src/dev/devlog.md:847
msgid "1. Union Type Subtyping Implementation"
msgstr ""

#: src/dev/devlog.md:850
msgid "Implemented three key union subtyping scenarios:"
msgstr ""

#: src/dev/devlog.md:851
msgid ""
"**Union-to-Union Subtyping**: `(A|B) <: (C|D)` with proper component type "
"relationships"
msgstr ""

#: src/dev/devlog.md:852
msgid ""
"**Specific-to-Union Subtyping**: `A <: (B|C)` for cases like passing "
"`Integer` to `Integer|String`"
msgstr ""

#: src/dev/devlog.md:853
msgid ""
"**Union-to-Specific Subtyping**: `(A|B) <: C` for returning a union from a "
"function with specific return type"
msgstr ""

#: src/dev/devlog.md:855
msgid "Added cell coverage for all union types and their components:"
msgstr ""

#: src/dev/devlog.md:862
msgid ""
"// Connect cell to itself to ensure it's covered by at least one propagator"
msgstr ""

#: src/dev/devlog.md:867
msgid "Implemented proper connections in the propagator network:"
msgstr ""

#: src/dev/devlog.md:868
msgid "Added direct connections between union types"
msgstr ""

#: src/dev/devlog.md:869
msgid "Added connections from union types to their components"
msgstr ""

#: src/dev/devlog.md:870
msgid "Ensured all cells are covered by propagators during unification"
msgstr ""

#: src/dev/devlog.md:872
msgid "2. Cell Coverage Mechanisms"
msgstr ""

#: src/dev/devlog.md:874
msgid "**Implemented Solutions**:"
msgstr ""

#: src/dev/devlog.md:875
msgid ""
"Added self-coverage mechanism to prevent \"cells not covered\" errors during "
"zonking"
msgstr ""

#: src/dev/devlog.md:876
msgid ""
"Implemented comprehensive coverage for complex types and their components"
msgstr ""

#: src/dev/devlog.md:877
msgid ""
"Added safeguards to avoid early returns that could leave cells uncovered"
msgstr ""

#: src/dev/devlog.md:878
msgid "Added debugging support for cell coverage issues"
msgstr ""

#: src/dev/devlog.md:880
msgid ""
"This solution systematically addresses cell coverage issues by ensuring "
"every cell in the propagator network is properly connected, which is "
"essential for the constraint-based type checking system to function "
"correctly."
msgstr ""

#: src/dev/devlog.md:882
msgid "3. Enhanced Type Level Comparison"
msgstr ""

#: src/dev/devlog.md:885
msgid ""
"Enhanced how type levels are compared during unification with asymmetric "
"compatibility:"
msgstr ""

#: src/dev/devlog.md:889
msgid "// Finite is compatible with unrestricted"
msgstr ""

#: src/dev/devlog.md:890
msgid "// Unrestricted is not compatible with finite"
msgstr ""

#: src/dev/devlog.md:891
msgid "// For other cases, keep exact equality"
msgstr ""

#: src/dev/devlog.md:895
msgid "Added recursive reduction for type-level function applications"
msgstr ""

#: src/dev/devlog.md:896
msgid "Improved alpha-equivalence checking for dependent types"
msgstr ""

#: src/dev/devlog.md:898
msgid "4. Trait Implementation"
msgstr ""

#: src/dev/devlog.md:900
msgid "**Implemented Features**:"
msgstr ""

#: src/dev/devlog.md:901
msgid "Added basic trait definition and record extension with `<:` syntax"
msgstr ""

#: src/dev/devlog.md:902
msgid "Implemented trait-record subtyping relation in the type system"
msgstr ""

#: src/dev/devlog.md:903
msgid "Added trait type representation with `TraitTypeTerm`"
msgstr ""

#: src/dev/devlog.md:904
msgid "Added trait-to-trait inheritance checking"
msgstr ""

#: src/dev/devlog.md:905
msgid "Implemented context tracking for trait field declarations"
msgstr ""

#: src/dev/devlog.md:906
msgid "Added appropriate error reporting for trait-related issues"
msgstr ""

#: src/dev/devlog.md:908
msgid ""
"The trait implementation provides a solid foundation for more advanced "
"features planned in future work, such as complete field requirement "
"verification, multiple trait inheritance, and trait methods with default "
"implementations."
msgstr ""

#: src/dev/devlog.md:910
msgid "5. Type Structure Reduction Improvements"
msgstr ""

#: src/dev/devlog.md:912
msgid "Enhanced the reducer to properly handle union and intersection types:"
msgstr ""

#: src/dev/devlog.md:920
msgid "// Similar handling for Intersection and function calls"
msgstr ""

#: src/dev/devlog.md:926
msgid ""
"Added special handling for type-level function applications within type "
"comparisons"
msgstr ""

#: src/dev/devlog.md:930
msgid "While significant progress has been made, some areas still need work:"
msgstr ""

#: src/dev/devlog.md:931
msgid "Fix remaining edge cases in union-subtype.chester.todo test"
msgstr ""

#: src/dev/devlog.md:932
msgid ""
"Complete type-level function application enhancement for nested applications"
msgstr ""

#: src/dev/devlog.md:933
msgid "Enhance trait field requirement verification"
msgstr ""

#: src/dev/devlog.md:934
msgid "Implement multiple trait inheritance support"
msgstr ""

#: src/dev/devlog.md:935
msgid "Add trait methods and default implementations"
msgstr ""

#: src/dev/devlog.md:944
msgid "2025-03-24"
msgstr ""

#: src/dev/devlog.md:946
msgid "Parser Improvements Completed"
msgstr ""

#: src/dev/devlog.md:948
msgid "Uniform Operator Handling"
msgstr ""

#: src/dev/devlog.md:949
msgid ""
"**Issue**: Special case handling for the \"=>\" and \"=\" operators in "
"`parseOperator()` method"
msgstr ""

#: src/dev/devlog.md:950 src/dev/devlog.md:967 src/dev/devlog.md:985
#: src/dev/devlog.md:1001 src/dev/devlog.md:1016 src/dev/devlog.md:1056
#: src/dev/devlog.md:1075 src/dev/devlog.md:1093 src/dev/devlog.md:1111
msgid "**Improvement**:"
msgstr ""

#: src/dev/devlog.md:951
msgid "Removed special case handling for the \"=>\" operator"
msgstr ""

#: src/dev/devlog.md:952
msgid "Ensured operators are treated uniformly in the tokenizer"
msgstr ""

#: src/dev/devlog.md:953
msgid "Treated \"=>\" like any other operator in the tokenizing process"
msgstr ""

#: src/dev/devlog.md:955
msgid "More consistent operator handling"
msgstr ""

#: src/dev/devlog.md:956
msgid "Simplified code in the `parseOperator()` method"
msgstr ""

#: src/dev/devlog.md:957
msgid "Reduced special cases, making the code more maintainable"
msgstr ""

#: src/dev/devlog.md:958
msgid ""
"Better alignment with Chester's design principles of uniform symbol treatment"
msgstr ""

#: src/dev/devlog.md:960
msgid ""
"Removed special case code for the \"=>\" operator in the `parseOperator()` "
"method"
msgstr ""

#: src/dev/devlog.md:961
msgid ""
"Modified the method to uniformly parse all operators using a `StringBuilder`"
msgstr ""

#: src/dev/devlog.md:962
msgid "Verified all tests pass with the change, including operator tests"
msgstr ""

#: src/dev/devlog.md:963
msgid "Ensured consistent behavior with the original implementation"
msgstr ""

#: src/dev/devlog.md:965
msgid "LexerV2 Optimization and Refactoring"
msgstr ""

#: src/dev/devlog.md:966
msgid ""
"**Issue**: `LexerV2.scala` had redundant code and a missing state.advance() "
"method reference"
msgstr ""

#: src/dev/devlog.md:968
msgid "Optimized and refactored the code structure for better maintainability"
msgstr ""

#: src/dev/devlog.md:969
msgid "Fixed compilation errors by replacing advance() with state.advance()"
msgstr ""

#: src/dev/devlog.md:970
msgid "Improved modularity by extracting repeated logic into helper methods"
msgstr ""

#: src/dev/devlog.md:971
msgid "Enhanced state management for better consistency across the codebase"
msgstr ""

#: src/dev/devlog.md:973
msgid "Improved maintainability and readability of the lexer code"
msgstr ""

#: src/dev/devlog.md:974
msgid "Fixed compilation errors resulting in more stable code"
msgstr ""

#: src/dev/devlog.md:975
msgid "Better organization of related functionality"
msgstr ""

#: src/dev/devlog.md:976
msgid "Reduced duplication for easier future updates"
msgstr ""

#: src/dev/devlog.md:978
msgid "Replaced direct advance() calls with state.advance() where appropriate"
msgstr ""

#: src/dev/devlog.md:979
msgid "Restructured code for better organization and clarity"
msgstr ""

#: src/dev/devlog.md:980
msgid "Maintained functionality while improving code quality"
msgstr ""

#: src/dev/devlog.md:981
msgid "Ensured all tests continued to pass after changes"
msgstr ""

#: src/dev/devlog.md:983
msgid "Comment Preservation Implementation"
msgstr ""

#: src/dev/devlog.md:984
msgid "**Issue**: V2 parser didn't preserve comments in the AST, unlike V1"
msgstr ""

#: src/dev/devlog.md:986
msgid "Added comment collection and attachment similar to V1 parser"
msgstr ""

#: src/dev/devlog.md:987
msgid "Implemented support for both leading and trailing comments"
msgstr ""

#: src/dev/devlog.md:988
msgid ""
"Created mechanism for handling comments in blocks and at block boundaries"
msgstr ""

#: src/dev/devlog.md:990
msgid "Full feature parity with V1 parser for comment handling"
msgstr ""

#: src/dev/devlog.md:991
msgid "Source code formatting preservation"
msgstr ""

#: src/dev/devlog.md:992
msgid "Support for documentation generation tools"
msgstr ""

#: src/dev/devlog.md:994
msgid "Added methods to collect and categorize comments during parsing"
msgstr ""

#: src/dev/devlog.md:995
msgid "Integrated with ExprMeta and CommentInfo structures"
msgstr ""

#: src/dev/devlog.md:996
msgid "Enhanced expression creation to include comment attachment"
msgstr ""

#: src/dev/devlog.md:997
msgid "Added test cases with various comment placements"
msgstr ""

#: src/dev/devlog.md:999
msgid "TokenExtractors Refinement"
msgstr ""

#: src/dev/devlog.md:1000
msgid ""
"**Issue**: Verbose and redundant token extractors made the code harder to "
"maintain"
msgstr ""

#: src/dev/devlog.md:1002
msgid "Simplified token extractors using a common helper function"
msgstr ""

#: src/dev/devlog.md:1003
msgid "Reduced code duplication for source position extraction"
msgstr ""

#: src/dev/devlog.md:1004
msgid "Made the code more maintainable with concise patterns"
msgstr ""

#: src/dev/devlog.md:1006
msgid "More readable and maintainable token handling"
msgstr ""

#: src/dev/devlog.md:1007
msgid "Less code duplication"
msgstr ""

#: src/dev/devlog.md:1008
msgid "Better abstraction of common patterns"
msgstr ""

#: src/dev/devlog.md:1010
msgid "Created a `posExtract` function to centralize extraction logic"
msgstr ""

#: src/dev/devlog.md:1011
msgid "Refactored individual token extractors to use the helper"
msgstr ""

#: src/dev/devlog.md:1012
msgid "Maintained the same semantics with less code"
msgstr ""

#: src/dev/devlog.md:1014
msgid "Pattern Matching Block Termination Fix"
msgstr ""

#: src/dev/devlog.md:1015
msgid ""
"**Issue**: Inconsistent handling of the `}\\n` pattern between V1 and V2 "
"parsers in pattern matching"
msgstr ""

#: src/dev/devlog.md:1017
msgid "Added context tracking to LexerState"
msgstr ""

#: src/dev/devlog.md:1018
msgid "Implemented context-aware block termination checks"
msgstr ""

#: src/dev/devlog.md:1019
msgid "Enabled context for all blocks uniformly"
msgstr ""

#: src/dev/devlog.md:1021
msgid "Consistent behavior between V1 and V2 parsers"
msgstr ""

#: src/dev/devlog.md:1022
msgid "Maintained uniform symbol treatment principle"
msgstr ""

#: src/dev/devlog.md:1023
msgid "Fixed pattern matching tests"
msgstr ""

#: src/dev/devlog.md:1025
msgid "Added `newLineAfterBlockMeansEnds` flag to LexerState"
msgstr ""

#: src/dev/devlog.md:1026
msgid "Created `withNewLineTermination` helper method"
msgstr ""

#: src/dev/devlog.md:1027
msgid "Updated `checkForRBraceNewlinePattern` to consider context"
msgstr ""

#: src/dev/devlog.md:1028
msgid "Enabled context for all blocks in `parseBlock`"
msgstr ""

#: src/dev/devlog.md:1030
msgid "Previously Completed Improvements"
msgstr ""

#: src/dev/devlog.md:1032
msgid "**Number Parsing Refactoring**"
msgstr ""

#: src/dev/devlog.md:1033
msgid "Extracted specialized methods for different number formats"
msgstr ""

#: src/dev/devlog.md:1034
msgid "Improved error handling for number parsing"
msgstr ""

#: src/dev/devlog.md:1036
msgid "**Enhanced Escape Character Handling**"
msgstr ""

#: src/dev/devlog.md:1037
msgid "Extended support for escape sequences (Unicode, octal, hex)"
msgstr ""

#: src/dev/devlog.md:1038
msgid "Improved error reporting for invalid escape sequences"
msgstr ""

#: src/dev/devlog.md:1040
msgid "**Basic Operator Parsing Clean-Up**"
msgstr ""

#: src/dev/devlog.md:1041
msgid "Extracted comment parsing to a separate method"
msgstr ""

#: src/dev/devlog.md:1042
msgid "Improved structure of `parseOperator()` method"
msgstr ""

#: src/dev/devlog.md:1044
msgid "**Identifier Parsing Correctness**"
msgstr ""

#: src/dev/devlog.md:1045
msgid "Aligned with IdentifierRules for consistent character validation"
msgstr ""

#: src/dev/devlog.md:1046
msgid "Improved handling of Unicode characters and emoji"
msgstr ""

#: src/dev/devlog.md:1048
msgid "**SourcePos Creation Efficiency**"
msgstr ""

#: src/dev/devlog.md:1049
msgid "Implemented caching for UTF-16 offset calculations"
msgstr ""

#: src/dev/devlog.md:1050
msgid "Reduced tokenization time for complex expressions"
msgstr ""

#: src/dev/devlog.md:1052
msgid "Ultra-Compact Tokenizer Implementation"
msgstr ""

#: src/dev/devlog.md:1054
msgid "Tokenizer Size Reduction"
msgstr ""

#: src/dev/devlog.md:1055
msgid "**Issue**: The Tokenizer.scala implementation was longer than necessary"
msgstr ""

#: src/dev/devlog.md:1057
msgid "Dramatically reduced code size (>25% reduction)"
msgstr ""

#: src/dev/devlog.md:1058
msgid "Consolidated similar methods"
msgstr ""

#: src/dev/devlog.md:1059
msgid "Simplified UTF-16 position tracking"
msgstr ""

#: src/dev/devlog.md:1060
msgid "Enhanced token generation pipeline"
msgstr ""

#: src/dev/devlog.md:1062
msgid "More maintainable codebase"
msgstr ""

#: src/dev/devlog.md:1063
msgid "Better readability"
msgstr ""

#: src/dev/devlog.md:1064
msgid "Easier to extend with new token types"
msgstr ""

#: src/dev/devlog.md:1065
msgid "More focused implementation"
msgstr ""

#: src/dev/devlog.md:1067
msgid "Created lookup tables for token types"
msgstr ""

#: src/dev/devlog.md:1068
msgid "Used more functional patterns for token creation"
msgstr ""

#: src/dev/devlog.md:1069
msgid "Streamlined number parsing logic"
msgstr ""

#: src/dev/devlog.md:1070
msgid "Improved string processing with boundary control"
msgstr ""

#: src/dev/devlog.md:1071
msgid "Consolidated position tracking logic"
msgstr ""

#: src/dev/devlog.md:1073
msgid "Functional Style Enhancement"
msgstr ""

#: src/dev/devlog.md:1074
msgid "**Issue**: Imperative style code was harder to maintain"
msgstr ""

#: src/dev/devlog.md:1076
msgid "Added more functional approach to tokenization"
msgstr ""

#: src/dev/devlog.md:1077
msgid "Implemented lazy stream-based token generation"
msgstr ""

#: src/dev/devlog.md:1078
msgid "Created more concise token construction helpers"
msgstr ""

#: src/dev/devlog.md:1079
msgid "Improved pattern matching throughout the codebase"
msgstr ""

#: src/dev/devlog.md:1081
msgid "Code more closely aligned with Scala best practices"
msgstr ""

#: src/dev/devlog.md:1082
msgid "Better composability"
msgstr ""

#: src/dev/devlog.md:1083
msgid "More declarative implementation"
msgstr ""

#: src/dev/devlog.md:1084
msgid "Easier to test individual components"
msgstr ""

#: src/dev/devlog.md:1086
msgid "Used LazyList for token stream generation"
msgstr ""

#: src/dev/devlog.md:1087
msgid "Implemented functional helpers for token creation"
msgstr ""

#: src/dev/devlog.md:1088
msgid "Enhanced pattern matching for token type dispatch"
msgstr ""

#: src/dev/devlog.md:1089
msgid "Added more concise function definitions"
msgstr ""

#: src/dev/devlog.md:1091
msgid "Unicode and Emoji Support Enhancements"
msgstr ""

#: src/dev/devlog.md:1092
msgid ""
"**Issue**: Complex Unicode handling with surrogate pairs needed improvement"
msgstr ""

#: src/dev/devlog.md:1094
msgid "Enhanced support for supplementary characters"
msgstr ""

#: src/dev/devlog.md:1095
msgid "Improved UTF-16 position mapping"
msgstr ""

#: src/dev/devlog.md:1096
msgid "Streamlined surrogate pair handling"
msgstr ""

#: src/dev/devlog.md:1097
msgid "Added more comprehensive emoji support"
msgstr ""

#: src/dev/devlog.md:1099
msgid "Better internationalization support"
msgstr ""

#: src/dev/devlog.md:1100
msgid "Correct handling of modern emoji"
msgstr ""

#: src/dev/devlog.md:1101
msgid "Proper source position mapping for all character types"
msgstr ""

#: src/dev/devlog.md:1102
msgid "More robust parsing for all Unicode scripts"
msgstr ""

#: src/dev/devlog.md:1104
msgid "Used Java's Character API for proper codepoint handling"
msgstr ""

#: src/dev/devlog.md:1105
msgid "Added special cases for supplementary characters"
msgstr ""

#: src/dev/devlog.md:1106
msgid "Improved UTF-16 position calculation"
msgstr ""

#: src/dev/devlog.md:1107
msgid "Enhanced identifier parsing with Unicode support"
msgstr ""

#: src/dev/devlog.md:1109
msgid "Performance Optimization"
msgstr ""

#: src/dev/devlog.md:1110
msgid "**Issue**: Tokenizer performance could be improved"
msgstr ""

#: src/dev/devlog.md:1112
msgid "Reduced memory allocations"
msgstr ""

#: src/dev/devlog.md:1113
msgid "Simplified position tracking"
msgstr ""

#: src/dev/devlog.md:1114
msgid "Optimized string building"
msgstr ""

#: src/dev/devlog.md:1115
msgid "Enhanced token stream generation"
msgstr ""

#: src/dev/devlog.md:1117
msgid "Faster tokenization"
msgstr ""

#: src/dev/devlog.md:1118
msgid "Lower memory usage"
msgstr ""

#: src/dev/devlog.md:1119
msgid "Better scalability for large files"
msgstr ""

#: src/dev/devlog.md:1120
msgid "More efficient pipeline"
msgstr ""

#: src/dev/devlog.md:1122
msgid "Used StringBuilder for efficient string concatenation"
msgstr ""

#: src/dev/devlog.md:1123
msgid "Implemented smarter UTF-16 position tracking"
msgstr ""

#: src/dev/devlog.md:1124
msgid "Optimized character and token processing"
msgstr ""

#: src/dev/devlog.md:1125
msgid "Enhanced error detection and handling"
msgstr ""

#: src/dev/devlog.md:1127
msgid "Updated Feature Coverage"
msgstr ""

#: src/dev/devlog.md:1129
msgid "The V2 parser now has complete implementations for:"
msgstr ""

#: src/dev/devlog.md:1130
msgid "Basic literals (integers, floating-point numbers)"
msgstr ""

#: src/dev/devlog.md:1131
msgid "Function calls (including nested and with type parameters)"
msgstr ""

#: src/dev/devlog.md:1132
msgid "Pattern matching (with correct block termination)"
msgstr ""

#: src/dev/devlog.md:1133
msgid "Operator sequences (with uniform treatment)"
msgstr ""

#: src/dev/devlog.md:1134
msgid "Generic type parameters (including complex and nested generics)"
msgstr ""

#: src/dev/devlog.md:1135
msgid "Block arguments"
msgstr ""

#: src/dev/devlog.md:1136
msgid "Lists with mixed types"
msgstr ""

#: src/dev/devlog.md:1137
msgid "Comment preservation (leading and trailing)"
msgstr ""

#: src/dev/devlog.md:1140
msgid "Focus is now shifting to:"
msgstr ""

#: src/dev/devlog.md:1141
msgid "Object expressions implementation"
msgstr ""

#: src/dev/devlog.md:1142
msgid "Source maps support"
msgstr ""

#: src/dev/devlog.md:1143
msgid "Error recovery mechanisms"
msgstr ""

#: src/dev/devlog.md:1144
msgid "Migrating remaining V1-only tests"
msgstr ""

#: src/dev/devlog.md:1146 src/dev/devlog.md:1291
msgid "2025-03-25"
msgstr ""

#: src/dev/devlog.md:1148
msgid "Union Type Subtyping Implementation Details"
msgstr ""

#: src/dev/devlog.md:1150
msgid ""
"Following the comprehensive type system improvements from March 23rd, here "
"are the detailed implementation specifics for union type subtyping and cell "
"coverage mechanisms:"
msgstr ""

#: src/dev/devlog.md:1152
msgid "1. Enhanced Union Subtyping Implementation"
msgstr ""

#: src/dev/devlog.md:1154
msgid ""
"The implementation now fully supports all three union subtyping scenarios "
"with proper propagator connections:"
msgstr ""

#: src/dev/devlog.md:1156
msgid "**Union-to-Union Subtyping** (`A|B <: C|D`):"
msgstr ""

#: src/dev/devlog.md:1158
msgid ""
"// For each type in RHS union, at least one type in LHS union must accept it"
msgstr ""

#: src/dev/devlog.md:1168
msgid "**Specific-to-Union Subtyping** (`A <: B|C`):"
msgstr ""

#: src/dev/devlog.md:1170
msgid "// Delegate to the connectSpecificAndUnion helper method"
msgstr ""

#: src/dev/devlog.md:1180
msgid "**Union-to-Specific Subtyping** (`A|B <: C`):"
msgstr ""

#: src/dev/devlog.md:1182
msgid ""
"// A union can be used where a specific type is expected if all components "
"match it"
msgstr ""

#: src/dev/devlog.md:1186
msgid "2. Advanced Cell Coverage Mechanisms"
msgstr ""

#: src/dev/devlog.md:1188
msgid ""
"To solve the \"cells not covered by any propagator\" error, several key "
"mechanisms have been implemented:"
msgstr ""

#: src/dev/devlog.md:1190
msgid "**EnsureCellCoverage Propagator**:"
msgstr ""

#: src/dev/devlog.md:1200
msgid "// Always succeeds - just ensures the cell is covered"
msgstr ""

#: src/dev/devlog.md:1208
msgid "**Helper Methods for Union Component Coverage**:"
msgstr ""

#: src/dev/devlog.md:1210
msgid "// Ensures coverage for all cells within a union type"
msgstr ""

#: src/dev/devlog.md:1223
msgid "**Connection of Union Types to Components**:"
msgstr ""

#: src/dev/devlog.md:1225
msgid "// Creates UnionOf propagator to connect union cell to its components"
msgstr ""

#: src/dev/devlog.md:1235
msgid "**Special Handling for Function Calls**:"
msgstr ""

#: src/dev/devlog.md:1237
msgid "// Recursively processes function calls to ensure cell coverage"
msgstr ""

#: src/dev/devlog.md:1250
msgid "// No further processing for simple terms"
msgstr ""

#: src/dev/devlog.md:1255
msgid "3. Improvements to Type Compatibility Checking"
msgstr ""

#: src/dev/devlog.md:1257
msgid ""
"The implementation now includes enhanced compatibility checks for working "
"with union types:"
msgstr ""

#: src/dev/devlog.md:1259
msgid "**Union Compatibility Methods**:"
msgstr ""

#: src/dev/devlog.md:1260
msgid ""
"Added specialized methods for checking compatibility between union and non-"
"union types"
msgstr ""

#: src/dev/devlog.md:1261
msgid "Implemented bidirectional compatibility checking for union types"
msgstr ""

#: src/dev/devlog.md:1262
msgid "Enhanced subtyping relationships with proper union type handling"
msgstr ""

#: src/dev/devlog.md:1264
msgid "**Special Handling for Literal Types with Unions**:"
msgstr ""

#: src/dev/devlog.md:1265
msgid "Added special case handling for integer literals with union types"
msgstr ""

#: src/dev/devlog.md:1266
msgid ""
"Implemented type compatibility checking for literals against union types"
msgstr ""

#: src/dev/devlog.md:1267
msgid "Added support for both direct and indirect type matching"
msgstr ""

#: src/dev/devlog.md:1269
msgid ""
"These improvements ensure that union types work seamlessly with the rest of "
"the type system, including with literals, function types, and in both "
"widening and narrowing contexts."
msgstr ""

#: src/dev/devlog.md:1271
msgid "4. Type-Level Function Application Enhancements"
msgstr ""

#: src/dev/devlog.md:1273
msgid ""
"The implementation includes improvements to how type-level function "
"applications are handled:"
msgstr ""

#: src/dev/devlog.md:1275
msgid "**Reduction for Type Checking**:"
msgstr ""

#: src/dev/devlog.md:1276
msgid "Added specialized reduction mode for type-level expressions"
msgstr ""

#: src/dev/devlog.md:1277
msgid "Implemented proper context handling for type equality checking"
msgstr ""

#: src/dev/devlog.md:1278
msgid "Enhanced type comparison with reduction-based equality"
msgstr ""

#: src/dev/devlog.md:1280
msgid "**Term Reference Resolution**:"
msgstr ""

#: src/dev/devlog.md:1281
msgid "Added recursive reference resolution for deeper type analysis"
msgstr ""

#: src/dev/devlog.md:1282
msgid "Implemented proper handling of nested references in types"
msgstr ""

#: src/dev/devlog.md:1283
msgid "Enhanced type comparison with fully resolved references"
msgstr ""

#: src/dev/devlog.md:1285
msgid ""
"All these implementations follow the design principles outlined in the type "
"improvement proposal, ensuring that:"
msgstr ""

#: src/dev/devlog.md:1286
msgid "Original terms are preserved in elaborated results"
msgstr ""

#: src/dev/devlog.md:1287
msgid "Reduction is only used for type checking, not for elaboration"
msgstr ""

#: src/dev/devlog.md:1288
msgid "Union types behave correctly in all subtyping scenarios"
msgstr ""

#: src/dev/devlog.md:1289
msgid ""
"Cell coverage is guaranteed to prevent \"cells not covered by propagator\" "
"errors"
msgstr ""

#: src/dev/devlog.md:1293
msgid "Enhanced Trait Implementation Details"
msgstr ""

#: src/dev/devlog.md:1295
msgid ""
"Building on the basic trait implementation completed on March 19, several "
"enhancements have been added to the trait system:"
msgstr ""

#: src/dev/devlog.md:1297
msgid "1. Advanced Trait Context Tracking"
msgstr ""

#: src/dev/devlog.md:1299
msgid ""
"To properly handle trait fields and method declarations, the Context system "
"now includes special tracking for the current declaration context:"
msgstr ""

#: src/dev/devlog.md:1303
msgid "// Existing fields"
msgstr ""

#: src/dev/devlog.md:1304
msgid "\"\" // Can be \"trait\", \"record\", etc."
msgstr ""

#: src/dev/devlog.md:1306
msgid ""
"// Helper method to create a new context with a specific processing type"
msgstr ""

#: src/dev/devlog.md:1309
msgid "// Rest of the implementation"
msgstr ""

#: src/dev/devlog.md:1313
msgid ""
"This allows the elaborator to recognize when it's processing fields inside a "
"trait definition versus a record definition, which affects how those fields "
"are processed."
msgstr ""

#: src/dev/devlog.md:1315
msgid "2. Trait Statement Elaboration"
msgstr ""

#: src/dev/devlog.md:1317
msgid ""
"The `processTraitStmt` method now fully handles trait declarations with "
"proper context management:"
msgstr ""

#: src/dev/devlog.md:1332
msgid "// Process extends clause if present"
msgstr ""

#: src/dev/devlog.md:1344 src/dev/devlog.md:1445
msgid "// Other cases"
msgstr ""

#: src/dev/devlog.md:1346
msgid "// More processing"
msgstr ""

#: src/dev/devlog.md:1349
msgid "// Elaborate the body within a trait-specific context"
msgstr ""

#: src/dev/devlog.md:1351
msgid "\"trait\""
msgstr ""

#: src/dev/devlog.md:1354
msgid "// Create and return the TraitStmtTerm"
msgstr ""

#: src/dev/devlog.md:1367
msgid ""
"The key improvement is using `ctx.withProcessingType(\"trait\")` to indicate "
"when we're elaborating a trait body."
msgstr ""

#: src/dev/devlog.md:1369
msgid "3. Record-Trait Subtyping Verification"
msgstr ""

#: src/dev/devlog.md:1371
msgid ""
"The trait implementation now includes proper record-trait subtyping "
"relationship verification:"
msgstr ""

#: src/dev/devlog.md:1383
msgid "// Check for a direct extension relationship"
msgstr ""

#: src/dev/devlog.md:1391
msgid "// Report error if record doesn't explicitly extend the trait"
msgstr ""

#: src/dev/devlog.md:1400
msgid "4. Trait-Trait Extension Checking"
msgstr ""

#: src/dev/devlog.md:1402
msgid "Similarly, trait-trait inheritance is now properly verified:"
msgstr ""

#: src/dev/devlog.md:1414
msgid "// Check if they're the same trait (reflexivity)"
msgstr ""

#: src/dev/devlog.md:1419
msgid "// Check direct parent"
msgstr ""

#: src/dev/devlog.md:1430
msgid "5. Special Handling in Type Unification"
msgstr ""

#: src/dev/devlog.md:1432
msgid ""
"The trait subtyping rules are now properly integrated into the type "
"unification system:"
msgstr ""

#: src/dev/devlog.md:1435
msgid "// In unify method"
msgstr ""

#: src/dev/devlog.md:1437
msgid "// Record implementing trait (structural subtyping)"
msgstr ""

#: src/dev/devlog.md:1441
msgid "// Trait extending trait (structural subtyping)"
msgstr ""

#: src/dev/devlog.md:1449
msgid ""
"These implementations provide a solid foundation for trait-based programming "
"in Chester, with support for basic field requirements and type inheritance. "
"Future work will focus on more advanced trait features like method "
"implementations, default values, and multiple inheritance."
msgstr ""

#: src/dev/devlog.md:1451
msgid "2025-04-01"
msgstr ""

#: src/dev/devlog.md:1453
msgid "Generalized Block Termination Implementation for V2 Parser"
msgstr ""

#: src/dev/devlog.md:1456
msgid ""
"**Issue**: V2 parser needed a general solution for the `}\\n` pattern "
"without special-casing keywords"
msgstr ""

#: src/dev/devlog.md:1457
msgid ""
"**Core Principle Violation**: Previous implementation relied on checking if "
"expressions were Blocks"
msgstr ""

#: src/dev/devlog.md:1458
msgid ""
"**Design Requirement**: Need context-free parsing with uniform token pattern "
"detection"
msgstr ""

#: src/dev/devlog.md:1461
msgid ""
"**Solution Strategy**: Implemented a generalized `}\\n` pattern detection "
"mechanism"
msgstr ""

#: src/dev/devlog.md:1462
msgid "**Key Changes**:"
msgstr ""

#: src/dev/devlog.md:1463
msgid ""
"Modified `checkForRBraceNewlinePattern` to check previous token instead of "
"expression type"
msgstr ""

#: src/dev/devlog.md:1464
msgid "Added support for EOF as an implicit newline terminator"
msgstr ""

#: src/dev/devlog.md:1465
msgid "Renamed `separateCaseStatements` to `processMixedStatements`"
msgstr ""

#: src/dev/devlog.md:1466
msgid "Made statement splitting logic more general while preserving behavior"
msgstr ""

#: src/dev/devlog.md:1468
msgid "Technical Implementation"
msgstr ""

#: src/dev/devlog.md:1469
msgid "**Token Pattern Detection**:"
msgstr ""

#: src/dev/devlog.md:1470
msgid "Check if previous token was a closing brace (RBrace)"
msgstr ""

#: src/dev/devlog.md:1471
msgid "Verify if current token is whitespace containing a newline or EOF"
msgstr ""

#: src/dev/devlog.md:1472
msgid "Apply termination rules based purely on syntax, not semantics"
msgstr ""

#: src/dev/devlog.md:1473
msgid "**Statement Processing**:"
msgstr ""

#: src/dev/devlog.md:1474
msgid "Preserve existing multiple statements without changes"
msgstr ""

#: src/dev/devlog.md:1475
msgid ""
"Split single OpSeq statements when they contain multiple logical statements"
msgstr ""

#: src/dev/devlog.md:1476
msgid ""
"Detect natural statement boundaries at certain identifiers like \"case\""
msgstr ""

#: src/dev/devlog.md:1477
msgid "Maintain consistent behavior with V1 parser"
msgstr ""

#: src/dev/devlog.md:1479
msgid "Benefits"
msgstr ""

#: src/dev/devlog.md:1480
msgid "**Alignment with Core Principles**:"
msgstr ""

#: src/dev/devlog.md:1481
msgid "Maintains strict context-free parsing"
msgstr ""

#: src/dev/devlog.md:1482
msgid "Treats all blocks uniformly"
msgstr ""

#: src/dev/devlog.md:1483
msgid "Applies consistent rules for expression termination"
msgstr ""

#: src/dev/devlog.md:1484
msgid "Better separation between syntax and semantics"
msgstr ""

#: src/dev/devlog.md:1485
msgid "**Technical Improvements**:"
msgstr ""

#: src/dev/devlog.md:1486
msgid "More maintainable parser with fewer special cases"
msgstr ""

#: src/dev/devlog.md:1487
msgid "Simplified codebase with clearer termination rules"
msgstr ""

#: src/dev/devlog.md:1488
msgid "Better alignment between V1 and V2 parsers"
msgstr ""

#: src/dev/devlog.md:1489
msgid "All relevant tests now pass with identical behavior"
msgstr ""

#: src/dev/devlog.md:1494
msgid ""
"This implementation properly adheres to Chester's core parsing principles by "
"treating all `}\\n` patterns uniformly, regardless of their context."
msgstr ""

#: src/dev/devlog.md:1496
msgid "2025-04-02"
msgstr ""

#: src/dev/devlog.md:1498
msgid "Fixed Outdated Pattern in Reducer.scala"
msgstr ""

#: src/dev/devlog.md:1500
msgid ""
"During a comprehensive code review to align with Chester's term architecture "
"principles:"
msgstr ""

#: src/dev/devlog.md:1502
msgid ""
"**Issue Identified**: Found outdated pattern in `reduceStandard` method in "
"`Reducer.scala` that was using explicit type casting with pattern matching "
"on `StmtTerm`"
msgstr ""

#: src/dev/devlog.md:1503
msgid ""
"**Fix Applied**: Updated the code to maintain type safety while avoiding "
"unnecessary pattern matching"
msgstr ""

#: src/dev/devlog.md:1504
msgid "**Before**:"
msgstr ""

#: src/dev/devlog.md:1510
msgid "**After**:"
msgstr ""

#: src/dev/devlog.md:1513
msgid "// Keep the type information while reducing"
msgstr ""

#: src/dev/devlog.md:1517
msgid ""
"**Alignment with Principles**: The solution balances Chester's design "
"principles with type safety requirements by:"
msgstr ""

#: src/dev/devlog.md:1518
msgid "Avoiding pattern matching with `*C` and `*T` suffix traits"
msgstr ""

#: src/dev/devlog.md:1519
msgid "Keeping necessary type casts for type safety"
msgstr ""

#: src/dev/devlog.md:1520
msgid "Using more direct and readable code"
msgstr ""

#: src/dev/devlog.md:1522
msgid "More consistent codebase that follows established design principles"
msgstr ""

#: src/dev/devlog.md:1523
msgid "Type-safe implementation"
msgstr ""

#: src/dev/devlog.md:1524
msgid "Clearer intent with inline comments"
msgstr ""

#: src/dev/devlog.md:1525
msgid "Better alignment with the unified Term definition approach"
msgstr ""

#: src/dev/devlog.md:1527
msgid "2025-04-27"
msgstr ""

#: src/dev/devlog.md:1529
msgid "LexerV2 Refactoring and Plan Cleanup"
msgstr ""

#: src/dev/devlog.md:1531
msgid "**LexerV2 Code Refinements**:"
msgstr ""

#: src/dev/devlog.md:1532
msgid ""
"Introduced `peek` method in `LexerState` to look ahead without consuming "
"tokens, simplifying logic."
msgstr ""

#: src/dev/devlog.md:1533
msgid ""
"Refactored `parseAtom` to use `peek` for cleaner handling of empty objects "
"`{}` vs block/object start."
msgstr ""

#: src/dev/devlog.md:1534
msgid ""
"Introduced `withModifiedState` helper in `LexerState` to encapsulate "
"temporary state changes (like `newLineAfterBlockMeansEnds`), simplifying "
"`parseBlock`."
msgstr ""

#: src/dev/devlog.md:1535
msgid "Minor cleanup in `expectedError` using f-interpolators."
msgstr ""

#: src/dev/devlog.md:1537
msgid "**Parser Plan Update**:"
msgstr "**解析器計劃更新**："

#: src/dev/devlog.md:1538
msgid ""
"Marked Phase 2 (Advanced Features) as fully complete in `parser-plan.md`."
msgstr ""

#: src/dev/devlog.md:1539
msgid ""
"Marked \"V1/V2 Semantic Consistency\", \"Object Expressions\", and \"Block "
"Termination\" priorities as complete."
msgstr ""

#: src/dev/devlog.md:1540
msgid ""
"Updated `parser-implementation.md` to reflect completed status of these "
"features."
msgstr ""

#: src/dev/devlog.md:1541
msgid ""
"Consolidated completed tasks from planning/implementation docs into this "
"devlog entry."
msgstr ""

#: src/dev/devlog.md:1542
msgid ""
"Current focus remains on Phase 3: Error Handling (Recovery, Messages, Debug "
"Info), Source Maps, Test Migration, and Performance Optimization."
msgstr ""

#: src/dev/devlog.md:1546
msgid "`docs/src/dev/parser-plan.md`"
msgstr ""

#: src/dev/devlog.md:1547
msgid "`docs/src/dev/parser-implementation.md`"
msgstr ""

#: src/dev/effects-implementation-plan.md:3 src/dev/effects-system.md:3
#: src/dev/tyck-improvement-proposal.md:3 src/dev/type-checking-system.md:3
#: src/dev/union_types_progress.md:3
msgid "NOTE THAT THIS DOCUMENT IS OUTDATED AS RELEVANT CODE IS BEING REWRITTEN"
msgstr ""

#: src/dev/effects-implementation-plan.md:5
msgid "Goal"
msgstr ""

#: src/dev/effects-implementation-plan.md:7
msgid ""
"Enable type checking for the simplest effects example in `tests/tyck/effects-"
"basic.chester.todo` by implementing the necessary compiler components for "
"the built-in effects system."
msgstr ""

#: src/dev/effects-implementation-plan.md:9 src/dev/typescript-backend.md:14
msgid "Current Status"
msgstr ""

#: src/dev/effects-implementation-plan.md:11
msgid ""
"We have a basic effects syntax design specified in `docs/src/dev/effects-"
"system.md`"
msgstr ""

#: src/dev/effects-implementation-plan.md:12
msgid ""
"A simple test file `tests/tyck/effects-basic.chester.todo` exists but "
"doesn't type check yet"
msgstr ""

#: src/dev/effects-implementation-plan.md:13
msgid "Some of the infrastructure for effects already exists in the codebase"
msgstr ""

#: src/dev/effects-implementation-plan.md:15 src/dev/typescript-backend.md:20
msgid "Implementation Tasks"
msgstr ""

#: src/dev/effects-implementation-plan.md:17
msgid "1. Parser Enhancements"
msgstr ""

#: src/dev/effects-implementation-plan.md:19
msgid ""
"Add parsing support for the `/` effect annotation syntax in function types"
msgstr ""

#: src/dev/effects-implementation-plan.md:20
msgid "Parse built-in effect names (`IO`, `State`, etc.) as identifiers"
msgstr ""

#: src/dev/effects-implementation-plan.md:21
msgid "Parse effect combinations using the `&` operator"
msgstr ""

#: src/dev/effects-implementation-plan.md:22
msgid ""
"Generate AST nodes that correctly represent effects in function signatures"
msgstr ""

#: src/dev/effects-implementation-plan.md:25
msgid "// Example parser implementation:"
msgstr ""

#: src/dev/effects-implementation-plan.md:27
msgid "// Parse function signature..."
msgstr ""

#: src/dev/effects-implementation-plan.md:29
msgid "// Check for effect annotation"
msgstr ""

#: src/dev/effects-implementation-plan.md:30
msgid "\"/\""
msgstr ""

#: src/dev/effects-implementation-plan.md:40
msgid "2. Built-in Effects Registry"
msgstr ""

#: src/dev/effects-implementation-plan.md:42
msgid "Define a registry for built-in effect types"
msgstr ""

#: src/dev/effects-implementation-plan.md:43
msgid "Implement recognition of built-in effects like `IO` and `State`"
msgstr ""

#: src/dev/effects-implementation-plan.md:44
msgid ""
"Add a mechanism to validate that effect identifiers refer to built-in effects"
msgstr ""

#: src/dev/effects-implementation-plan.md:47
msgid "// Example registry:"
msgstr ""

#: src/dev/effects-implementation-plan.md:49
msgid "\"IO\""
msgstr ""

#: src/dev/effects-implementation-plan.md:50
msgid "\"State\""
msgstr ""

#: src/dev/effects-implementation-plan.md:51
msgid "\"Exception\""
msgstr ""

#: src/dev/effects-implementation-plan.md:52
msgid "\"NonTermination\""
msgstr ""

#: src/dev/effects-implementation-plan.md:60
msgid "3. Type Representation"
msgstr ""

#: src/dev/effects-implementation-plan.md:62
msgid "Enhance the `Effects` class to handle built-in effects"
msgstr ""

#: src/dev/effects-implementation-plan.md:63
msgid "Implement function type representation that includes effects"
msgstr ""

#: src/dev/effects-implementation-plan.md:64
msgid "Support effect combinations (union of effects)"
msgstr ""

#: src/dev/effects-implementation-plan.md:67
msgid "// Example Effects class:"
msgstr ""

#: src/dev/effects-implementation-plan.md:77
msgid "4. Type Checking"
msgstr ""

#: src/dev/effects-implementation-plan.md:79
msgid "Implement effect checking during function definition"
msgstr ""

#: src/dev/effects-implementation-plan.md:80
msgid "Verify that function bodies only use effects that are declared"
msgstr ""

#: src/dev/effects-implementation-plan.md:81
msgid "Track effect requirements in the function call chain"
msgstr ""

#: src/dev/effects-implementation-plan.md:82
msgid "Ensure effects are properly propagated from callee to caller"
msgstr ""

#: src/dev/effects-implementation-plan.md:85
msgid "// Example type checker for function calls:"
msgstr ""

#: src/dev/effects-implementation-plan.md:89
msgid "// Check argument types..."
msgstr ""

#: src/dev/effects-implementation-plan.md:91
msgid "// Extract function effects"
msgstr ""

#: src/dev/effects-implementation-plan.md:94
msgid "// Ensure the current context allows these effects"
msgstr ""

#: src/dev/effects-implementation-plan.md:97
msgid "// Return function's return type with effects"
msgstr ""

#: src/dev/effects-implementation-plan.md:102
msgid "5. Effect Propagation"
msgstr ""

#: src/dev/effects-implementation-plan.md:104
msgid "Implement a mechanism to accumulate effects from function calls"
msgstr ""

#: src/dev/effects-implementation-plan.md:105
msgid "Ensure effects are propagated up the call chain"
msgstr ""

#: src/dev/effects-implementation-plan.md:106
msgid "Handle effect combinations correctly"
msgstr ""

#: src/dev/effects-implementation-plan.md:109
msgid "// Example propagation:"
msgstr ""

#: src/dev/effects-implementation-plan.md:111
msgid "// Combine effects from caller and callee"
msgstr ""

#: src/dev/effects-implementation-plan.md:116
msgid "6. Error Reporting"
msgstr ""

#: src/dev/effects-implementation-plan.md:118
msgid "Add clear error messages for effect-related type errors"
msgstr ""

#: src/dev/effects-implementation-plan.md:119
msgid "Report when a function uses unauthorized effects"
msgstr ""

#: src/dev/effects-implementation-plan.md:120
msgid "Report when effect types are invalid or unknown"
msgstr ""

#: src/dev/effects-implementation-plan.md:123
msgid "// Example error generation:"
msgstr ""

#: src/dev/effects-implementation-plan.md:125
msgid ""
"s\"Function uses effect '$effect' but it is not declared in the function "
"signature\""
msgstr ""

#: src/dev/effects-implementation-plan.md:130
msgid "Implementation Order"
msgstr ""

#: src/dev/effects-implementation-plan.md:132
msgid "**First Phase: Basic Type Representation**"
msgstr ""

#: src/dev/effects-implementation-plan.md:133
msgid "Enhance the AST and type system to represent effects"
msgstr ""

#: src/dev/effects-implementation-plan.md:134
msgid "Implement the built-in effects registry"
msgstr ""

#: src/dev/effects-implementation-plan.md:135
msgid "Add effect annotations to function types"
msgstr ""

#: src/dev/effects-implementation-plan.md:137
msgid "**Second Phase: Parser Integration**"
msgstr ""

#: src/dev/effects-implementation-plan.md:138
msgid "Update the parser to handle effect annotations"
msgstr ""

#: src/dev/effects-implementation-plan.md:139
msgid "Parse effect combinations"
msgstr ""

#: src/dev/effects-implementation-plan.md:140
msgid "Generate correct AST nodes with effects"
msgstr ""

#: src/dev/effects-implementation-plan.md:142
msgid "**Third Phase: Type Checking**"
msgstr ""

#: src/dev/effects-implementation-plan.md:143
msgid "Implement basic effect checking for function bodies"
msgstr ""

#: src/dev/effects-implementation-plan.md:144
msgid "Add effect validation in function calls"
msgstr ""

#: src/dev/effects-implementation-plan.md:145
msgid "Ensure effects are correctly propagated"
msgstr ""

#: src/dev/effects-implementation-plan.md:147
msgid "**Fourth Phase: Error Handling**"
msgstr ""

#: src/dev/effects-implementation-plan.md:148
msgid "Add descriptive error messages"
msgstr ""

#: src/dev/effects-implementation-plan.md:149
msgid "Implement suggestions for fixing effect-related errors"
msgstr ""

#: src/dev/effects-implementation-plan.md:151
msgid "**Fifth Phase: Testing**"
msgstr ""

#: src/dev/effects-implementation-plan.md:152
msgid "Convert the `.todo` test to a regular test file"
msgstr ""

#: src/dev/effects-implementation-plan.md:153
msgid "Add additional tests for more complex effect scenarios"
msgstr ""

#: src/dev/effects-implementation-plan.md:154
msgid "Verify compatibility with existing code"
msgstr ""

#: src/dev/effects-implementation-plan.md:156
msgid "Timeline"
msgstr ""

#: src/dev/effects-implementation-plan.md:158
msgid "Days 1-2: First Phase implementation"
msgstr ""

#: src/dev/effects-implementation-plan.md:159
msgid "Days 3-4: Second Phase implementation"
msgstr ""

#: src/dev/effects-implementation-plan.md:160
msgid "Days 5-7: Third Phase implementation"
msgstr ""

#: src/dev/effects-implementation-plan.md:161
msgid "Days 8-9: Fourth Phase implementation"
msgstr ""

#: src/dev/effects-implementation-plan.md:162
msgid "Day 10: Testing and refinement"
msgstr ""

#: src/dev/effects-implementation-plan.md:164
#: src/dev/tyck-improvement-proposal.md:103 src/dev/typescript-backend.md:183
msgid "Success Criteria"
msgstr ""

#: src/dev/effects-implementation-plan.md:166
msgid ""
"The `tests/tyck/effects-basic.chester.todo` file can be renamed to `tests/"
"tyck/effects-basic.chester` and passes type checking"
msgstr ""

#: src/dev/effects-implementation-plan.md:167
msgid "The type checker correctly enforces effect constraints"
msgstr ""

#: src/dev/effects-implementation-plan.md:168
msgid "Effect propagation works as expected in nested function calls"
msgstr ""

#: src/dev/effects-implementation-plan.md:169
msgid "Pure functions don't require effect annotations"
msgstr ""

#: src/dev/effects-implementation-plan.md:170
msgid "Clear error messages are provided for effect-related type errors"
msgstr ""

#: src/dev/effects-system.md:7
msgid ""
"The Chester language includes a built-in effect system that enables tracking "
"and controlling side effects. This document outlines the design and "
"implementation of this system."
msgstr ""

#: src/dev/effects-system.md:9
msgid "Core Concepts"
msgstr ""

#: src/dev/effects-system.md:11
msgid ""
"**Effect**: A built-in type in the language that represents a capability to "
"perform a specific kind of operation."
msgstr ""

#: src/dev/effects-system.md:12
msgid ""
"**Effect Values**: Built-in values of type `Effect` (e.g., `IO`, `State`, "
"`Exception`)."
msgstr ""

#: src/dev/effects-system.md:13
msgid ""
"**Effect Requirements**: Functions declare which effects they may use with "
"the `/ Effect` syntax."
msgstr ""

#: src/dev/effects-system.md:14
msgid ""
"**Effect Propagation**: Effect requirements automatically propagate up the "
"call chain."
msgstr ""

#: src/dev/effects-system.md:15
msgid ""
"**Pure Functions**: Functions without effect annotations are pure (no side "
"effects)."
msgstr ""

#: src/dev/effects-system.md:17
msgid "Syntax"
msgstr ""

#: src/dev/effects-system.md:19
msgid "Function Declaration with Effects"
msgstr ""

#: src/dev/effects-system.md:26
msgid ""
"```\n"
"// Function with IO effect\n"
"def print(message: String): Unit / IO = ()\n"
"\n"
"// Function with multiple effects\n"
"def readAndWrite(): String / (IO & State) = { ... }\n"
"```"
msgstr ""

#: src/dev/effects-system.md:34
msgid "Effect Propagation"
msgstr ""

#: src/dev/effects-system.md:36
msgid ""
"When a function calls another function with effects, those effects must be "
"declared in the caller's signature:"
msgstr ""

#: src/dev/effects-system.md:38
msgid ""
"```\n"
"def hello(): Unit / IO = {\n"
"  print(\"Hello\")  // print has IO effect, so hello needs IO too\n"
"}\n"
"```"
msgstr ""

#: src/dev/effects-system.md:44
msgid "Built-in Effects"
msgstr ""

#: src/dev/effects-system.md:46
msgid "The language provides several built-in effects:"
msgstr ""

#: src/dev/effects-system.md:48
msgid "**IO**: Input/output operations (file I/O, console I/O, etc.)"
msgstr ""

#: src/dev/effects-system.md:49
msgid "**State**: Mutable state operations"
msgstr ""

#: src/dev/effects-system.md:50
msgid "**Exception**: Operations that may throw exceptions"
msgstr ""

#: src/dev/effects-system.md:51
msgid "**NonTermination**: Operations that may not terminate"
msgstr ""

#: src/dev/effects-system.md:53
msgid "Implementation Notes"
msgstr ""

#: src/dev/effects-system.md:55
msgid "The effect system is implemented through:"
msgstr ""

#: src/dev/effects-system.md:57
msgid ""
"**Type Checking**: Functions are verified to declare all effects they use."
msgstr ""

#: src/dev/effects-system.md:58
msgid ""
"**Effect Propagation**: Functions automatically require any effects used by "
"functions they call."
msgstr ""

#: src/dev/effects-system.md:59
msgid ""
"**Effect Handling**: The runtime system ensures effects are properly handled."
msgstr ""

#: src/dev/effects-system.md:61
msgid "Future Extensions"
msgstr ""

#: src/dev/effects-system.md:63
msgid "Potential future extensions include:"
msgstr ""

#: src/dev/effects-system.md:65
msgid "User-defined effects"
msgstr ""

#: src/dev/effects-system.md:66
msgid "Effect polymorphism"
msgstr ""

#: src/dev/effects-system.md:67
msgid "Effect inference"
msgstr ""

#: src/dev/effects-system.md:68
msgid "Effect handlers for controlling effect execution"
msgstr ""

#: src/dev/effects-system.md:70
msgid "Example Usage"
msgstr ""

#: src/dev/effects-system.md:72
msgid ""
"```\n"
"// Function with an IO effect requirement\n"
"def print(message: String): Unit / IO = ()\n"
"\n"
"// This function automatically inherits the IO effect\n"
"def hello(): Unit / IO = {\n"
"  print(\"Hello\")\n"
"}\n"
"\n"
"// Pure function with no effects\n"
"def pure(): Integer = 123\n"
"```"
msgstr ""

#: src/dev/elaboration-system.md:3
msgid "Introduction"
msgstr ""

#: src/dev/elaboration-system.md:5
msgid "Chester features two elaboration systems for type checking:"
msgstr ""

#: src/dev/elaboration-system.md:7
msgid ""
"**Original Type Checking Logic (`chester.tyck`)**: The constraint-based type "
"checking system using propagator networks"
msgstr ""

#: src/dev/elaboration-system.md:8
msgid ""
"**New Elaboration System (`chester.elab`)**: A modernized, more modular "
"approach to elaboration with a dedicated solver"
msgstr ""

#: src/dev/elaboration-system.md:10
msgid ""
"This document explains both systems, their differences, and provides "
"guidance on how to work with the new elaboration system."
msgstr ""

#: src/dev/elaboration-system.md:12
#, fuzzy
msgid "Architectural Comparison"
msgstr "架構"

#: src/dev/elaboration-system.md:14
msgid "Original System (`chester.tyck`)"
msgstr ""

#: src/dev/elaboration-system.md:16
msgid ""
"The original type checking system is built around propagator networks with "
"cells and constraints:"
msgstr ""

#: src/dev/elaboration-system.md:18
msgid "Uses `TyckPropagator` for constraint propagation"
msgstr ""

#: src/dev/elaboration-system.md:19
msgid ""
"Has a monolithic `Elaborater` class with specialized components "
"(`ElaboraterBlock`, `ElaboraterFunction`, etc.)"
msgstr ""

#: src/dev/elaboration-system.md:20
msgid "Relies on `CellId` references for tracking types"
msgstr ""

#: src/dev/elaboration-system.md:21
msgid "Uses a stateful approach for tracking and resolving constraints"
msgstr ""

#: src/dev/elaboration-system.md:23
msgid "New System (`chester.elab`)"
msgstr ""

#: src/dev/elaboration-system.md:25
msgid ""
"The new elaboration system takes a fundamentally different approach to type "
"checking:"
msgstr ""

#: src/dev/elaboration-system.md:27
msgid ""
"**Constraint-based Solver**: Uses a dedicated solver architecture for "
"tracking and resolving typing constraints"
msgstr ""

#: src/dev/elaboration-system.md:28
msgid ""
"**Modular Handler System**: Each elaboration concern is handled by a "
"dedicated, composable handler"
msgstr ""

#: src/dev/elaboration-system.md:29
msgid ""
"**Cell-based Representation**: Uses cells to represent type variables and "
"constraints in a more structured way"
msgstr ""

#: src/dev/elaboration-system.md:30
msgid ""
"**More Precise Types**: Infers more specific types (e.g., `IntTerm` instead "
"of `IntegerTerm`)"
msgstr ""

#: src/dev/elaboration-system.md:31
msgid ""
"**Handler-driven Architecture**: Components like `BlockElabHandler` and "
"`ListOfHandler` encapsulate specific elaboration logic"
msgstr ""

#: src/dev/elaboration-system.md:33
msgid "Key Components of the New System"
msgstr ""

#: src/dev/elaboration-system.md:35
msgid "1. Core Interfaces"
msgstr ""

#: src/dev/elaboration-system.md:37
msgid ""
"**Elab Trait** (`Elab.scala`) serves as the primary interface for "
"elaboration operations. It provides three key methods:"
msgstr ""

#: src/dev/elaboration-system.md:39
msgid ""
"`elab`: Elaborates an expression against a given type, returning a cell "
"containing the elaborated term"
msgstr ""

#: src/dev/elaboration-system.md:40
msgid ""
"`infer`: Infers both the term and type for an expression, returning them as "
"a pair"
msgstr ""

#: src/dev/elaboration-system.md:41
msgid ""
"`inferType`: Specializes in type-checking expressions that should be types "
"themselves"
msgstr ""

#: src/dev/elaboration-system.md:43
msgid ""
"All these methods require appropriate context, effects tracking, and solver "
"operations to function."
msgstr ""

#: src/dev/elaboration-system.md:45
msgid ""
"**DefaultElab Implementation** provides the core elaboration logic for "
"different expression types. It uses pattern matching to handle different "
"kinds of expressions, dispatching each to an appropriate constraint handler:"
msgstr ""

#: src/dev/elaboration-system.md:47
msgid "Integer literals are handled by the IntegerLit constraint"
msgstr ""

#: src/dev/elaboration-system.md:48
msgid "String literals are handled by the StringLit constraint"
msgstr ""

#: src/dev/elaboration-system.md:49
msgid "List expressions are handled by the ListOf constraint"
msgstr ""

#: src/dev/elaboration-system.md:50
msgid "Blocks are handled by the BlockElab constraint"
msgstr ""

#: src/dev/elaboration-system.md:52
msgid ""
"For each expression type, a corresponding constraint is created and passed "
"to the solver through SolverOps."
msgstr ""

#: src/dev/elaboration-system.md:54
msgid "2. Entry Point"
msgstr ""

#: src/dev/elaboration-system.md:56
msgid ""
"**DefaultElaborator** (`Elaborator.scala`) is the main entry point for using "
"the new elaboration system. It's configured with:"
msgstr ""

#: src/dev/elaboration-system.md:58
msgid "A default Elab implementation (DefaultElabImpl)"
msgstr ""

#: src/dev/elaboration-system.md:59
msgid "A SolverFactory (ConcurrentSolverFactory)"
msgstr ""

#: src/dev/elaboration-system.md:60
msgid "A handler configuration (DefaultSolverConf)"
msgstr ""

#: src/dev/elaboration-system.md:62
msgid ""
"This setup provides the `inferPure()` method that is used by the REPL and "
"tests as the primary entry point for type checking expressions."
msgstr ""

#: src/dev/elaboration-system.md:64
msgid "3. Constraint Handlers"
msgstr ""

#: src/dev/elaboration-system.md:66
msgid ""
"The system uses a handler-based architecture where each type of constraint "
"has a dedicated handler:"
msgstr ""

#: src/dev/elaboration-system.md:68
msgid ""
"**Literal Handlers**: `IntegerLitHandler`, `StringLitHandler`, "
"`SymbolLitHandler`"
msgstr ""

#: src/dev/elaboration-system.md:69
msgid "**Block Handler**: `BlockElabHandler` for elaborating code blocks"
msgstr ""

#: src/dev/elaboration-system.md:70
msgid "**List Handler**: `ListOfHandler` for list expressions"
msgstr ""

#: src/dev/elaboration-system.md:71
msgid ""
"**Unification Handlers**: `UnifyHandler`, `UnifyMultipleHandler` for type "
"compatibility"
msgstr ""

#: src/dev/elaboration-system.md:72
msgid ""
"**Type Handlers**: `IsTypeHandler` for type checking, `SimplifyUnionHandler` "
"for union types"
msgstr ""

#: src/dev/elaboration-system.md:74
msgid ""
"Each handler implements the `Handler` trait with a `run` method that "
"processes a specific type of constraint."
msgstr ""

#: src/dev/elaboration-system.md:76
msgid "4. Operations Interface"
msgstr ""

#: src/dev/elaboration-system.md:78
msgid ""
"**ElabOps** (`ElabOps.scala`) provides operations for error reporting and "
"semantic collection:"
msgstr ""

#: src/dev/elaboration-system.md:82
msgid "// Delegated reporter methods"
msgstr ""

#: src/dev/elaboration-system.md:87 src/dev/type-checking-system.md:171
msgid "Current Implementation Status"
msgstr ""

#: src/dev/elaboration-system.md:89
msgid "Features Supported"
msgstr ""

#: src/dev/elaboration-system.md:91
msgid "The new elaboration system currently supports:"
msgstr ""

#: src/dev/elaboration-system.md:93
msgid "Basic literals (integers, strings, symbols)"
msgstr ""

#: src/dev/elaboration-system.md:94
msgid ""
"Lists (including heterogeneous and nested lists with correct union typing)"
msgstr ""

#: src/dev/elaboration-system.md:95
msgid "Code blocks with statements and expressions"
msgstr ""

#: src/dev/elaboration-system.md:96
msgid "Type unification and compatibility checking"
msgstr ""

#: src/dev/elaboration-system.md:97
msgid "Pure expressions (without effects)"
msgstr ""

#: src/dev/elaboration-system.md:99
#, fuzzy
msgid "REPL Integration"
msgstr "Web API 集成"

#: src/dev/elaboration-system.md:101
msgid ""
"The REPL engine now uses the new elaboration system by default, as seen in "
"`REPLEngine.scala`:"
msgstr ""

#: src/dev/elaboration-system.md:103
msgid ""
"The REPL implementation includes a toggle (`useNewElab`) set to true by "
"default that allows switching between the old and new elaboration systems. "
"When enabled, the typeCheck method creates a reporter and ElabOps, then "
"calls DefaultElaborator.inferPure() to type check expressions. The results "
"are wrapped in a TyckResult0 object to maintain compatibility with the old "
"system's result format."
msgstr ""

#: src/dev/elaboration-system.md:105
msgid ""
"This implementation allows seamless switching between the old and new "
"elaboration systems, with the new system as the default."
msgstr ""

#: src/dev/elaboration-system.md:107
msgid "Test Coverage"
msgstr ""

#: src/dev/elaboration-system.md:109
msgid ""
"Test coverage for the new system is implemented in "
"`ElabLiteralAndListTest.scala`, which verifies:"
msgstr ""

#: src/dev/elaboration-system.md:111
msgid "**Integer literals**: Correctly elaborated to `IntTerm` with `IntType`"
msgstr ""

#: src/dev/elaboration-system.md:112
msgid ""
"**Heterogeneous lists**: Elaborated to `ListTerm` with a union type for "
"elements"
msgstr ""

#: src/dev/elaboration-system.md:113
msgid "**Empty lists**: Properly typed as `ListTerm[NothingType]`"
msgstr ""

#: src/dev/elaboration-system.md:114
msgid ""
"**Nested lists**: Correctly handle nested list structures and their type "
"relationships"
msgstr ""

#: src/dev/elaboration-system.md:116
msgid "These tests demonstrate the system's ability to:"
msgstr ""

#: src/dev/elaboration-system.md:117
msgid ""
"Infer precise types (using `IntTerm` instead of the more general "
"`IntegerTerm`)"
msgstr ""

#: src/dev/elaboration-system.md:118
msgid "Handle heterogeneity through proper union type creation"
msgstr ""

#: src/dev/elaboration-system.md:119
msgid "Maintain correct type relationships in nested structures"
msgstr ""

#: src/dev/elaboration-system.md:121
msgid "Using the New Elaboration System"
msgstr ""

#: src/dev/elaboration-system.md:123
msgid "Basic Usage"
msgstr ""

#: src/dev/elaboration-system.md:125
msgid ""
"The following example shows how to use the new elaboration system to type "
"check an expression:"
msgstr ""

#: src/dev/elaboration-system.md:127
msgid "To use the new elaboration system, you'll need to:"
msgstr ""

#: src/dev/elaboration-system.md:129
msgid "Parse an expression using ChesterReaderV2 or another parser"
msgstr ""

#: src/dev/elaboration-system.md:130
msgid "Create a reporter and ElabOps for error collection"
msgstr ""

#: src/dev/elaboration-system.md:131
msgid ""
"Call DefaultElaborator.inferPure() to obtain a Judge containing the "
"elaborated term and type"
msgstr ""

#: src/dev/elaboration-system.md:132
msgid "Check for errors and access the elaborated term and inferred type"
msgstr ""

#: src/dev/elaboration-system.md:134
msgid ""
"This process will properly handle parsing and type checking of various "
"expressions, including heterogeneous lists that will be typed with "
"appropriate union types."
msgstr ""

#: src/dev/elaboration-system.md:136
msgid "Extending the System with New Expression Types"
msgstr ""

#: src/dev/elaboration-system.md:138
msgid ""
"To add support for a new expression type, you need to follow these steps:"
msgstr ""

#: src/dev/elaboration-system.md:140 src/dev/elaboration-system.md:144
msgid "1. Define a Constraint Kind"
msgstr ""

#: src/dev/elaboration-system.md:142
msgid "Create a Kind object for your constraint:"
msgstr ""

#: src/dev/elaboration-system.md:146
msgid ""
"Create a Kind object in the `chester.elab` package that defines the type of "
"your constraint. This serves as a unique identifier for your constraint type "
"in the system."
msgstr ""

#: src/dev/elaboration-system.md:148
msgid "2. Create a Constraint Class"
msgstr ""

#: src/dev/elaboration-system.md:150
msgid "Define a constraint class for your expression type that takes:"
msgstr ""

#: src/dev/elaboration-system.md:151
msgid "Your expression type as a parameter"
msgstr ""

#: src/dev/elaboration-system.md:152
msgid "The target type cell"
msgstr ""

#: src/dev/elaboration-system.md:153
msgid "Required implicit parameters (effects, elab, ops, ctx)"
msgstr ""

#: src/dev/elaboration-system.md:155
msgid ""
"The constraint class should extend the `Constraint` abstract class with your "
"Kind."
msgstr ""

#: src/dev/elaboration-system.md:157
msgid "3. Implement a Handler"
msgstr ""

#: src/dev/elaboration-system.md:159
msgid ""
"Create a handler that processes your constraint by implementing the "
"`Handler` trait. The handler needs to:"
msgstr ""

#: src/dev/elaboration-system.md:160
msgid "Override the `run` method to implement the elaboration logic"
msgstr ""

#: src/dev/elaboration-system.md:161
msgid "Create appropriate cells for your results"
msgstr ""

#: src/dev/elaboration-system.md:162
msgid "Connect your result to the target type using constraints like `Unify`"
msgstr ""

#: src/dev/elaboration-system.md:163
msgid ""
"Optionally implement defaulting behavior for when type information is "
"incomplete"
msgstr ""

#: src/dev/elaboration-system.md:165
msgid "4. Register the Handler"
msgstr ""

#: src/dev/elaboration-system.md:167
msgid ""
"Add your handler to `DefaultSolverConf.scala` so the system knows how to "
"process your constraint. This involves adding your handler to the list of "
"handlers in the `DefaultSolverConf` value."
msgstr ""

#: src/dev/elaboration-system.md:169
msgid "5. Update DefaultElab"
msgstr ""

#: src/dev/elaboration-system.md:171
msgid ""
"Finally, extend the `elab()` method in `DefaultElab` to handle your "
"expression type by adding a pattern matching case for your expression type "
"that calls your constraint."
msgstr ""

#: src/dev/elaboration-system.md:173
msgid "Example: Adding Support for Boolean Literals"
msgstr ""

#: src/dev/elaboration-system.md:175
msgid ""
"A practical example would be adding support for boolean literals, which "
"would require:"
msgstr ""

#: src/dev/elaboration-system.md:177
msgid "Defining a `BooleanLit` Kind to identify the boolean literal constraint"
msgstr ""

#: src/dev/elaboration-system.md:178
msgid ""
"Creating a `BooleanLit` constraint class that takes a BooleanLiteral "
"expression and target type"
msgstr ""

#: src/dev/elaboration-system.md:179
msgid "Implementing a `BooleanLitHandler` that:"
msgstr ""

#: src/dev/elaboration-system.md:180
msgid "Creates a BooleanTerm with the appropriate value"
msgstr ""

#: src/dev/elaboration-system.md:181
msgid "Adds a cell containing that term"
msgstr ""

#: src/dev/elaboration-system.md:182
msgid "Creates a BooleanType cell"
msgstr ""

#: src/dev/elaboration-system.md:183
msgid "Unifies the target type with the boolean type"
msgstr ""

#: src/dev/elaboration-system.md:184
msgid "Connects the boolean term to the output cell"
msgstr ""

#: src/dev/elaboration-system.md:185
msgid "Registering the handler in DefaultSolverConf"
msgstr ""

#: src/dev/elaboration-system.md:186
msgid ""
"Adding a case for BooleanLiteral expressions in the DefaultElab.elab method"
msgstr ""

#: src/dev/elaboration-system.md:188
msgid "Transition Guidelines"
msgstr ""

#: src/dev/elaboration-system.md:190
msgid ""
"While both systems currently coexist, the development focus is transitioning "
"to the new `chester.elab` system. Follow these guidelines when working with "
"the codebase:"
msgstr ""

#: src/dev/elaboration-system.md:192
#, fuzzy
msgid "For New Development"
msgstr "開發日誌"

#: src/dev/elaboration-system.md:194
msgid ""
"Use `DefaultElaborator.inferPure()` as the primary entry point for new "
"typechecking code"
msgstr ""

#: src/dev/elaboration-system.md:195
msgid "Implement new features and extensions in the `chester.elab` package"
msgstr ""

#: src/dev/elaboration-system.md:196
msgid "Add handlers for new expression types following the pattern shown above"
msgstr ""

#: src/dev/elaboration-system.md:197
msgid "Write tests specifically against the new elaboration system"
msgstr ""

#: src/dev/elaboration-system.md:199
msgid "For Maintenance of Existing Code"
msgstr ""

#: src/dev/elaboration-system.md:201
msgid ""
"When fixing bugs in the existing `chester.tyck` system, consider if the fix "
"should also be applied to `chester.elab`"
msgstr ""

#: src/dev/elaboration-system.md:202
msgid ""
"Document cross-references between equivalent functionality in both systems"
msgstr ""

#: src/dev/elaboration-system.md:203
msgid "Gradually migrate test cases to support the new system"
msgstr ""

#: src/dev/elaboration-system.md:207
msgid ""
"Use `ElabLiteralAndListTest.scala` as a reference for test structure and "
"pattern"
msgstr ""

#: src/dev/elaboration-system.md:208
msgid "Create test cases that work with both systems to ensure compatibility"
msgstr ""

#: src/dev/elaboration-system.md:209
msgid ""
"The REPL's toggle (`useNewElab`) allows easy switching between systems for "
"comparison"
msgstr ""

#: src/dev/elaboration-system.md:211 src/guide/statements.md:85
msgid "Best Practices"
msgstr ""

#: src/dev/elaboration-system.md:213
msgid "1. Preserve Original Terms"
msgstr ""

#: src/dev/elaboration-system.md:215
msgid ""
"Consistent with the existing guidelines for the original elaboration system:"
msgstr ""

#: src/dev/elaboration-system.md:217
msgid "The elaboration system should preserve the original structure of terms"
msgstr ""

#: src/dev/elaboration-system.md:218
msgid "Avoid reduction during elaboration"
msgstr ""

#: src/dev/elaboration-system.md:219
msgid "Keep source code structure intact in elaborated results"
msgstr ""

#: src/dev/elaboration-system.md:222
msgid "2. Error Reporting"
msgstr ""

#: src/dev/elaboration-system.md:224
msgid "Use the `ElabOps` reporter for consistent error messages"
msgstr ""

#: src/dev/elaboration-system.md:225
msgid "Provide detailed type information in error messages"
msgstr ""

#: src/dev/elaboration-system.md:226
msgid "Match the error format of the original system for consistency"
msgstr ""

#: src/dev/elaboration-system.md:227
msgid "Include source position information when available"
msgstr ""

#: src/dev/elaboration-system.md:228
msgid "Use internationalized messages (with `t\"\"` string templates)"
msgstr ""

#: src/dev/elaboration-system.md:230
msgid "3. Testing"
msgstr ""

#: src/dev/elaboration-system.md:233
msgid "Verify the structure of elaborated terms"
msgstr ""

#: src/dev/elaboration-system.md:234
msgid ""
"Check inferred types carefully, especially for complex cases like union types"
msgstr ""

#: src/dev/elaboration-system.md:235
msgid "Test with heterogeneous data to verify union type handling"
msgstr ""

#: src/dev/elaboration-system.md:236
msgid ""
"Ensure tests cover edge cases like empty collections and nested structures"
msgstr ""

#: src/dev/elaboration-system.md:238
msgid "Current Limitations and Future Work"
msgstr ""

#: src/dev/elaboration-system.md:240
msgid ""
"The new elaboration system is still under development and doesn't yet "
"support the full range of Chester language features. Current limitations "
"include:"
msgstr ""

#: src/dev/elaboration-system.md:242
msgid "Limited support for complex expressions and statements"
msgstr ""

#: src/dev/elaboration-system.md:243
msgid ""
"Incomplete handling of advanced type features like traits and interfaces"
msgstr ""

#: src/dev/elaboration-system.md:244
msgid "Partial support for effects system"
msgstr ""

#: src/dev/elaboration-system.md:245
msgid "Incomplete support for pattern matching"
msgstr ""

#: src/dev/elaboration-system.md:247
msgid "Future development should focus on:"
msgstr ""

#: src/dev/elaboration-system.md:249
msgid "Extending the system to support all Chester language features"
msgstr ""

#: src/dev/elaboration-system.md:250
msgid "Improving error messages and diagnostics"
msgstr ""

#: src/dev/elaboration-system.md:251
msgid "Enhancing performance and error recovery"
msgstr ""

#: src/dev/elaboration-system.md:252
msgid "Eventually replacing the original system entirely"
msgstr ""

#: src/dev/intellij-idea.md:3
msgid "use nightly update of scala plugin"
msgstr ""

#: src/dev/intellij-idea.md:4
msgid "use \"Compiler\" for scala2"
msgstr ""

#: src/dev/intellij-idea.md:5
msgid ""
"in sbt settings, Create separate modules for main and test; Use separate "
"compiler output paths"
msgstr ""

#: src/dev/js2py.md:5
msgid ""
"This document outlines the process for converting JavaScript code generated "
"from Scala.js into Python-accessible modules. This approach allows Chester "
"functionality written in Scala to be available within Python environments."
msgstr ""

#: src/dev/js2py.md:7
msgid "Process Flow"
msgstr ""

#: src/dev/js2py.md:9
msgid "The conversion process follows these steps:"
msgstr ""

#: src/dev/js2py.md:11
msgid ""
"**Compile Scala.js to JavaScript** - Use the `sbt jsForPython/fastLinkJS` "
"SBT task to compile Scala code to JavaScript"
msgstr ""

#: src/dev/js2py.md:12
msgid ""
"**Bundle with Rollup** - Use Rollup to combine the generated JavaScript with "
"any needed glue code into a single module"
msgstr ""

#: src/dev/js2py.md:13
msgid ""
"**Convert to Python** - Use js2py to make the JavaScript functionality "
"accessible from Python"
msgstr ""

#: src/dev/js2py.md:15
msgid "Step-by-Step Implementation"
msgstr ""

#: src/dev/js2py.md:17
msgid "1. Scala.js Compilation"
msgstr ""

#: src/dev/js2py.md:19
msgid ""
"The `jsForPython` project in `build.sbt` is configured to compile Scala code "
"to ECMAScript modules with the `.mjs` extension:"
msgstr ""

#: src/dev/js2py.md:25 src/dev/js2py.md:28
msgid "\"js-for-python\""
msgstr ""

#: src/dev/js2py.md:33
msgid "// Enable ECMAScript module output."
msgstr ""

#: src/dev/js2py.md:35
msgid "// Use .mjs extension."
msgstr ""

#: src/dev/js2py.md:36
msgid "\"%s.mjs\""
msgstr ""

#: src/dev/js2py.md:41
msgid "To compile the Scala.js code, run:"
msgstr ""

#: src/dev/js2py.md:47
msgid ""
"This produces JavaScript files in the `js-for-python/js/target/` directory."
msgstr ""

#: src/dev/js2py.md:49
msgid "2. Bundling with Rollup"
msgstr ""

#: src/dev/js2py.md:51
msgid ""
"The `rollup.config.mjs` file defines how to bundle the generated JavaScript:"
msgstr ""

#: src/dev/js2py.md:54
msgid "'@rollup/plugin-node-resolve'"
msgstr ""

#: src/dev/js2py.md:55
msgid "'@rollup/plugin-commonjs'"
msgstr ""

#: src/dev/js2py.md:56
msgid "'@rollup/plugin-babel'"
msgstr ""

#: src/dev/js2py.md:59
msgid "'index.js'"
msgstr ""

#: src/dev/js2py.md:61
msgid "'dist/bundle.js'"
msgstr ""

#: src/dev/js2py.md:62
msgid "'cjs'"
msgstr ""

#: src/dev/js2py.md:71
msgid "'bundled'"
msgstr ""

#: src/dev/js2py.md:73
msgid "'@babel/preset-env'"
msgstr ""

#: src/dev/js2py.md:73
msgid "\"18\""
msgstr ""

#: src/dev/js2py.md:80
msgid ""
"To bundle the JavaScript code, create an `index.js` file that imports the "
"generated `.mjs` files, then run:"
msgstr ""

#: src/dev/js2py.md:83
msgid "# Only need to run this once to install dependencies\n"
msgstr ""

#: src/dev/js2py.md:87
msgid "This produces a bundled JavaScript file at `dist/bundle.js`."
msgstr ""

#: src/dev/js2py.md:89
msgid "3. JavaScript to Python with js2py"
msgstr ""

#: src/dev/js2py.md:91
msgid "Python Environment Setup with UV"
msgstr ""

#: src/dev/js2py.md:93
msgid ""
"We use the `uv` package manager for Python dependencies due to its improved "
"performance and reliability. All Python-related work should be done in the "
"`js-for-python` directory, which contains a `.python-version` file "
"specifying Python 3.11:"
msgstr ""

#: src/dev/js2py.md:96
msgid "# Navigate to the js-for-python directory\n"
msgstr ""

#: src/dev/js2py.md:98
msgid "# Create a virtual environment with the specified Python version\n"
msgstr ""

#: src/dev/js2py.md:101
msgid "# Activate the virtual environment\n"
msgstr ""

#: src/dev/js2py.md:103
msgid ""
"# On Unix/macOS\n"
"# or\n"
"# .venv\\Scripts\\activate  # On Windows\n"
msgstr ""

#: src/dev/js2py.md:106
msgid "# Install dependencies using requirements.txt\n"
msgstr ""

#: src/dev/js2py.md:111
msgid "Automated Translation Process"
msgstr ""

#: src/dev/js2py.md:113
msgid ""
"The `js2py_build.py` script in the `python` directory automates the "
"translation process:"
msgstr ""

#: src/dev/js2py.md:116
msgid "# Usage\n"
msgstr ""

#: src/dev/js2py.md:117
msgid "# Translates the bundle.js to chester.py\n"
msgstr ""

#: src/dev/js2py.md:118
msgid "# Forces retranslation even if chester.py exists\n"
msgstr ""

#: src/dev/js2py.md:121
msgid "This script performs the following steps:"
msgstr ""

#: src/dev/js2py.md:122
msgid "Verifies the bundle.js file exists"
msgstr ""

#: src/dev/js2py.md:123
msgid "Preprocesses the JavaScript to handle js2py compatibility issues"
msgstr ""

#: src/dev/js2py.md:124
msgid "Translates the JavaScript to Python using js2py.translate_file()"
msgstr ""

#: src/dev/js2py.md:125
msgid "Outputs the result to `python/chester.py`"
msgstr ""

#: src/dev/js2py.md:127
msgid "Usage Guidelines"
msgstr ""

#: src/dev/js2py.md:129
msgid "Expose Scala functions using `@JSExportTopLevel`:"
msgstr ""

#: src/dev/js2py.md:131
msgid "\"functionName\""
msgstr ""

#: src/dev/js2py.md:133
msgid "// Implementation"
msgstr ""

#: src/dev/js2py.md:137
msgid "Bundle only what's necessary to minimize final bundle size."
msgstr ""

#: src/dev/js2py.md:139
msgid "Access the Chester functionality from Python:"
msgstr ""

#: src/dev/js2py.md:142
msgid "# Import the Chester module\n"
msgstr ""

#: src/dev/js2py.md:145
msgid "# Access functions via the Chester global object\n"
msgstr ""

#: src/dev/js2py.md:149
msgid "Testing"
msgstr ""

#: src/dev/js2py.md:151
msgid "The project includes two test scripts:"
msgstr ""

#: src/dev/js2py.md:153
msgid "1. test_js2py.py"
msgstr ""

#: src/dev/js2py.md:155
msgid "Tests basic js2py functionality with a simple JavaScript example. It:"
msgstr ""

#: src/dev/js2py.md:156
msgid "Translates example.js to Python"
msgstr ""

#: src/dev/js2py.md:157
msgid "Imports and uses the translated module"
msgstr ""

#: src/dev/js2py.md:158
msgid "Tests various js2py features"
msgstr ""

#: src/dev/js2py.md:159
msgid "Tests the Chester JS -> Python bridge"
msgstr ""

#: src/dev/js2py.md:161 src/dev/js2py.md:173
msgid "To run:"
msgstr ""

#: src/dev/js2py.md:166
msgid "2. test_chester.py"
msgstr ""

#: src/dev/js2py.md:168
msgid "Tests the generated Chester Python module. It:"
msgstr ""

#: src/dev/js2py.md:169
msgid "Checks if the chester.py module exists and generates it if needed"
msgstr ""

#: src/dev/js2py.md:170
msgid "Imports the module and tests available functions"
msgstr ""

#: src/dev/js2py.md:171
msgid "Reports any errors"
msgstr ""

#: src/dev/js2py.md:178
msgid "Complete Testing Sequence"
msgstr ""

#: src/dev/js2py.md:180
msgid "To fully test the JavaScript to Python conversion:"
msgstr ""

#: src/dev/js2py.md:183
msgid "# 1. Compile Scala.js to JavaScript\n"
msgstr ""

#: src/dev/js2py.md:185
msgid "# 2. Bundle with Rollup\n"
msgstr ""

#: src/dev/js2py.md:188
msgid "# First time only\n"
msgstr ""

#: src/dev/js2py.md:190
msgid "# 3. Set up Python environment\n"
msgstr ""

#: src/dev/js2py.md:195
msgid "# 4. Test js2py and simple JavaScript\n"
msgstr ""

#: src/dev/js2py.md:198
msgid "# 5. Test Chester module\n"
msgstr ""

#: src/dev/js2py.md:203
msgid "Project Structure"
msgstr ""

#: src/dev/js2py.md:205
msgid "Current project structure:"
msgstr ""

#: src/dev/js2py.md:225
msgid "Troubleshooting"
msgstr ""

#: src/dev/js2py.md:227
msgid ""
"**CommonJS vs ESM**: Ensure module formats are compatible between Scala.js "
"output and Rollup configuration."
msgstr ""

#: src/dev/js2py.md:228
msgid ""
"**js2py limitations**: js2py has limited ECMAScript compatibility; avoid "
"advanced JS features."
msgstr ""

#: src/dev/js2py.md:229
msgid ""
"**Bundle size**: Large bundles may impact Python startup time; optimize "
"bundle size when possible."
msgstr ""

#: src/dev/js2py.md:230
msgid ""
"**Python version compatibility**: js2py works best with Python 3.8-3.11. "
"We're currently using Python 3.11."
msgstr ""

#: src/dev/js2py.md:231
msgid ""
"**Special character handling**: js2py doesn't support functions with special "
"characters in their names (like `$`) when accessing them directly. Use "
"`getattr()` instead:"
msgstr ""

#: src/dev/js2py.md:233
msgid "# Instead of: module.$function()\n"
msgstr ""

#: src/dev/js2py.md:234
msgid "\"$function\""
msgstr ""

#: src/dev/js2py.md:236
msgid ""
"**Object serialization issues**: When encountering \"Cannot convert object "
"to primitive value\" errors, explicitly use string conversion:"
msgstr ""

#: src/dev/js2py.md:238
msgid "// Instead of: \"text\" + object\n"
msgstr ""

#: src/dev/js2py.md:239
msgid "\"text\""
msgstr ""

#: src/dev/reader.md:3
msgid ""
"Design of Chester's parsers (\"readers\") that transform source code into "
"abstract syntax trees."
msgstr ""

#: src/dev/reader.md:7
msgid "Chester currently has two parser implementations:"
msgstr ""

#: src/dev/reader.md:9
msgid "**ReaderV1**: The original parser using FastParse combinators"
msgstr ""

#: src/dev/reader.md:10
msgid ""
"**ReaderV2**: The newer implementation using a token-based state machine"
msgstr ""

#: src/dev/reader.md:12
msgid ""
"Both parsers produce semantically identical ASTs using different internal "
"approaches."
msgstr ""

#: src/dev/reader.md:14
msgid "Core Design Principles"
msgstr ""

#: src/dev/reader.md:16
msgid ""
"**Context-Free Parsing**: Uniform rules for all expressions; identifiers "
"treated consistently"
msgstr ""

#: src/dev/reader.md:17
msgid "**Separation of Concerns**: Parse syntax without imposing semantics"
msgstr ""

#: src/dev/reader.md:18
msgid ""
"**Uniform Symbol Treatment**: No special keywords - just identifiers and "
"operators"
msgstr ""

#: src/dev/reader.md:19
msgid ""
"**Flat Operator Sequences**: Operator precedence handled later in the "
"semantic phase"
msgstr ""

#: src/dev/reader.md:20
msgid "**Newline Significance**: `}\\n` terminates expressions in blocks"
msgstr ""

#: src/dev/reader.md:21
msgid "**Block Return Values**: Last expression in a block is its return value"
msgstr ""

#: src/dev/reader.md:23
msgid "ReaderV1 Implementation"
msgstr ""

#: src/dev/reader.md:25
msgid ""
"ReaderV1 uses the FastParse library to implement a parser combinator "
"approach."
msgstr ""

#: src/dev/reader.md:27 src/dev/reader.md:60
msgid "Key Components"
msgstr ""

#: src/dev/reader.md:29
msgid ""
"**TokenParsers**: Small parsers for basic lexemes (identifiers, literals, "
"operators)"
msgstr ""

#: src/dev/reader.md:30
msgid ""
"**Combinators**: Composable functions that build larger parsers from smaller "
"ones"
msgstr ""

#: src/dev/reader.md:31
msgid ""
"**ParsingContext**: Tracks parsing state (e.g., whether currently in an "
"operator sequence)"
msgstr ""

#: src/dev/reader.md:32
msgid "**ExprMeta**: Metadata handling for source positions and comments"
msgstr ""

#: src/dev/reader.md:34 src/dev/reader.md:68
msgid "Characteristics"
msgstr ""

#: src/dev/reader.md:36
msgid "Declarative grammar definitions"
msgstr ""

#: src/dev/reader.md:37
msgid "FastParse-based error reporting"
msgstr ""

#: src/dev/reader.md:38
msgid "Recursive descent parsing model"
msgstr ""

#: src/dev/reader.md:40 src/dev/reader.md:78
msgid "Implementation Structure"
msgstr ""

#: src/dev/reader.md:42
msgid "ReaderV1 consists of:"
msgstr ""

#: src/dev/reader.md:44
msgid ""
"**Expression Parsers**: Methods like `parseExpr`, `parseAtom`, and "
"`parseOperator` form the core of the parser. They use FastParse combinators "
"to build complex parsers from simpler ones."
msgstr ""

#: src/dev/reader.md:46
msgid ""
"**Context Tracking**: A `ParsingContext` object tracks the current parsing "
"state, including whether we're in an operator sequence, a block, or other "
"specialized contexts."
msgstr ""

#: src/dev/reader.md:48
msgid ""
"**Source Position Tracking**: Dedicated methods map character positions to "
"line/column positions for error reporting, with special handling for UTF-16 "
"surrogate pairs."
msgstr ""

#: src/dev/reader.md:50
msgid ""
"**Whitespace and Comment Handling**: Dedicated parsers for whitespace, line "
"endings, and comments ensure these elements are preserved in the AST."
msgstr ""

#: src/dev/reader.md:52
msgid ""
"**Parser Extensions**: Custom extension methods for FastParse parsers add "
"support for metadata attachment, relaxed parsing, and error recovery."
msgstr ""

#: src/dev/reader.md:54
msgid ""
"**Parser Composition**: The implementation composes smaller parsers into "
"larger ones, following FastParse's combinator approach."
msgstr ""

#: src/dev/reader.md:56
msgid "ReaderV2 Implementation"
msgstr ""

#: src/dev/reader.md:58
msgid ""
"ReaderV2 uses a custom tokenizer and a state machine-based approach for "
"parsing, with significant improvements to block termination detection and "
"object expression parsing."
msgstr ""

#: src/dev/reader.md:62
msgid ""
"**Lexer**: Converts source code into a stream of tokens for efficient parsing"
msgstr ""

#: src/dev/reader.md:63
msgid ""
"**ReaderState**: Tracks current token position, history, and pending "
"whitespace/comments"
msgstr ""

#: src/dev/reader.md:64
msgid ""
"**ReaderContext**: Contains context flags like `newLineAfterBlockMeansEnds` "
"for parsing decisions"
msgstr ""

#: src/dev/reader.md:65
msgid ""
"**Token**: Represents tokens like identifiers, operators, literals, with "
"source position information"
msgstr ""

#: src/dev/reader.md:66
msgid ""
"**Token Handlers**: Specialized methods for parsing different token types "
"and structures"
msgstr ""

#: src/dev/reader.md:70
msgid "Pre-tokenization for efficient token stream processing"
msgstr ""

#: src/dev/reader.md:71
msgid "Separate lexing and parsing phases for cleaner code organization"
msgstr ""

#: src/dev/reader.md:72
msgid "Context-aware parsing with explicit state tracking"
msgstr ""

#: src/dev/reader.md:73
msgid "Enhanced UTF-16 aware Unicode and emoji handling"
msgstr ""

#: src/dev/reader.md:74
msgid "Robust block termination detection with the `}\\n` pattern"
msgstr ""

#: src/dev/reader.md:75
msgid "Comprehensive object expression support with multiple key types"
msgstr ""

#: src/dev/reader.md:76
msgid "Optimized comment handling and attachment"
msgstr ""

#: src/dev/reader.md:80
msgid "ReaderV2 consists of:"
msgstr ""

#: src/dev/reader.md:82
msgid ""
"**Two-Phase Parsing**: Separates tokenization from parsing, with a dedicated "
"Tokenizer creating a stream of tokens before parsing begins."
msgstr ""

#: src/dev/reader.md:84
msgid ""
"**State Management**: The parser maintains state through two complementary "
"objects:"
msgstr ""

#: src/dev/reader.md:85
msgid ""
"**ReaderState**: Tracks token position, history, and pending whitespace/"
"comments"
msgstr ""

#: src/dev/reader.md:86
msgid ""
"**ReaderContext**: Contains context flags like `newLineAfterBlockMeansEnds` "
"for syntactic decisions"
msgstr ""

#: src/dev/reader.md:87
msgid ""
"Together they enable precise tracking of parser state and contextual "
"information"
msgstr ""

#: src/dev/reader.md:89
msgid ""
"**Context-Aware Processing**: Context flags enable important syntactic "
"decisions like proper block termination with the `}\\n` pattern, while "
"maintaining uniform symbol treatment."
msgstr ""

#: src/dev/reader.md:91
msgid ""
"**Optimized Comment Handling**: Non-recursive methods like `skipComments()` "
"and `pullComments()` efficiently manage comment attachment, replacing the "
"previous recursive approach."
msgstr ""

#: src/dev/reader.md:93
msgid ""
"**Robust Block Termination**: The special `}\\n` pattern detection is "
"implemented in the `checkForRBraceNewlinePattern()` method, which uses the "
"`newLineAfterBlockMeansEnds` flag from ReaderContext to determine when "
"blocks should end."
msgstr ""

#: src/dev/reader.md:95
msgid "**Enhanced Object Expressions**: Support for multiple key types:"
msgstr ""

#: src/dev/reader.md:99
msgid "Both `=` and `=>` operators in object clauses"
msgstr ""

#: src/dev/reader.md:101
msgid ""
"**Error Handling**: The parser produces structured `ParseError` objects with "
"detailed source position information and recovery mechanisms."
msgstr ""

#: src/dev/reader.md:103
msgid ""
"**Bottom-Up Construction**: Parsing builds expressions from atoms and then "
"extends them through continuation-based parsing in `parseRest()`."
msgstr ""

#: src/dev/reader.md:105
msgid "Key Similarities Between Implementations"
msgstr ""

#: src/dev/reader.md:107
msgid "Both parsers:"
msgstr ""

#: src/dev/reader.md:109
msgid "Track source positions for error reporting"
msgstr ""

#: src/dev/reader.md:110
msgid "Preserve comments in the AST"
msgstr ""

#: src/dev/reader.md:111
msgid "Handle the `}\\n` block termination pattern"
msgstr ""

#: src/dev/reader.md:112
msgid "Produce flat operator sequences without precedence handling"
msgstr ""

#: src/dev/reader.md:113
msgid "Parse the same language syntax"
msgstr ""

#: src/dev/reader.md:114
msgid "Use context tracking for parsing decisions"
msgstr ""

#: src/dev/reader.md:115
msgid "Generate identical AST structures"
msgstr ""

#: src/dev/reader.md:117
msgid "Key Differences Between Implementations"
msgstr ""

#: src/dev/reader.md:119
msgid "Feature"
msgstr ""

#: src/dev/reader.md:119
msgid "ReaderV1"
msgstr ""

#: src/dev/reader.md:119
msgid "ReaderV2"
msgstr ""

#: src/dev/reader.md:121
msgid "**Parsing Approach**"
msgstr ""

#: src/dev/reader.md:121
msgid "Parser combinators (FastParse)"
msgstr ""

#: src/dev/reader.md:121
msgid "Token-based state machine"
msgstr ""

#: src/dev/reader.md:122
msgid "**Error Recovery**"
msgstr ""

#: src/dev/reader.md:122
msgid "Limited"
msgstr ""

#: src/dev/reader.md:122
msgid "Enhanced with token-based recovery"
msgstr ""

#: src/dev/reader.md:123
msgid "**Token Creation**"
msgstr ""

#: src/dev/reader.md:123
msgid "On-demand during parsing"
msgstr ""

#: src/dev/reader.md:123
msgid "Separate tokenization phase"
msgstr ""

#: src/dev/reader.md:124
msgid "**State Handling**"
msgstr ""

#: src/dev/reader.md:124
msgid "Implicit in parse context"
msgstr ""

#: src/dev/reader.md:124
msgid "Explicit in ReaderState"
msgstr ""

#: src/dev/reader.md:125
msgid "**Code Structure**"
msgstr ""

#: src/dev/reader.md:125
msgid "Grammar-centric"
msgstr ""

#: src/dev/reader.md:125
msgid "Process-centric"
msgstr ""

#: src/dev/reader.md:126
msgid "**Performance**"
msgstr ""

#: src/dev/reader.md:126
msgid "Good"
msgstr ""

#: src/dev/reader.md:126
msgid "Better (especially on large files)"
msgstr ""

#: src/dev/reader.md:127
msgid "**Unicode Support**"
msgstr ""

#: src/dev/reader.md:127
msgid "Basic"
msgstr ""

#: src/dev/reader.md:127
msgid "Enhanced with better UTF-16 handling"
msgstr ""

#: src/dev/reader.md:129
msgid "Testing Infrastructure"
msgstr ""

#: src/dev/reader.md:131
msgid ""
"Chester's test framework validates parser correctness and compatibility "
"between V1 and V2 implementations. This framework, defined in `reader/shared/"
"src/test/scala/chester/reader/parseAndCheck.scala`, provides several key "
"testing functions:"
msgstr ""

#: src/dev/reader.md:133
msgid "Core Testing Functions"
msgstr ""

#: src/dev/reader.md:135
msgid "**Parser-Specific Testing**:"
msgstr ""

#: src/dev/reader.md:136
msgid ""
"`parseV1(input)`: Parses input with V1 parser only and returns the result"
msgstr ""

#: src/dev/reader.md:137
msgid ""
"`parseV2(input)`: Parses input with V2 parser only and returns the result"
msgstr ""

#: src/dev/reader.md:138
msgid ""
"`parseAndCheckV1(input, expected)`: Tests V1 parser against expected output"
msgstr ""

#: src/dev/reader.md:139
msgid ""
"`parseAndCheckV2(input, expected)`: Tests V2 parser against expected output"
msgstr ""

#: src/dev/reader.md:141
msgid "**Cross-Parser Verification**:"
msgstr ""

#: src/dev/reader.md:142
msgid ""
"`parseAndCheckBoth(input, expected)`: Tests both parsers and ensures they "
"produce identical results"
msgstr ""

#: src/dev/reader.md:143
msgid "Tests backward compatibility and feature parity"
msgstr ""

#: src/dev/reader.md:145
msgid "**Top-Level Parsing**:"
msgstr ""

#: src/dev/reader.md:146
msgid ""
"`parseTopLevelV1/V2` and `parseAndCheckTopLevelV1/V2/Both`: Similar "
"functions for testing top-level parsing"
msgstr ""

#: src/dev/reader.md:147
msgid "Handle file-level parsing with multiple expressions"
msgstr ""

#: src/dev/reader.md:149
msgid "Error Reporting"
msgstr ""

#: src/dev/reader.md:151
msgid "The testing framework provides error reporting with:"
msgstr ""

#: src/dev/reader.md:153
msgid "Detailed error messages showing exact failure position"
msgstr ""

#: src/dev/reader.md:154
msgid "Visual pointer to error location in source code"
msgstr ""

#: src/dev/reader.md:155
msgid "Context-aware error descriptions"
msgstr ""

#: src/dev/reader.md:156
msgid "Comparison between expected and actual AST structures"
msgstr ""

#: src/dev/reader.md:158
msgid "Serialization Verification"
msgstr ""

#: src/dev/reader.md:160
msgid ""
"The framework also tests that parsed expressions can be correctly serialized "
"and deserialized:"
msgstr ""

#: src/dev/reader.md:162
msgid "Verifies JSON serialization with `read[Expr](write[Expr](value))`"
msgstr ""

#: src/dev/reader.md:163
msgid ""
"Confirms binary serialization with `readBinary[Expr](writeBinary[Expr]"
"(value))`"
msgstr ""

#: src/dev/reader.md:164
msgid "Ensures AST structures maintain integrity through serialization cycles"
msgstr ""

#: src/dev/reader.md:166
msgid "Test Organization"
msgstr ""

#: src/dev/reader.md:168
msgid "Parser tests are organized into several categories:"
msgstr ""

#: src/dev/reader.md:170
msgid "**Expression Tests**: Verify parsing of individual expression types"
msgstr ""

#: src/dev/reader.md:171
msgid "**Integration Tests**: Test combined language features"
msgstr ""

#: src/dev/reader.md:172
msgid "**Regression Tests**: Ensure previously fixed issues don't reoccur"
msgstr ""

#: src/dev/reader.md:173
msgid "**Migration Tests**: Track progress in supporting V1 features in V2"
msgstr ""

#: src/dev/reader.md:175
msgid "File-Based Testing"
msgstr ""

#: src/dev/reader.md:177
msgid ""
"In addition to the core testing functions, Chester implements file-based "
"integration tests:"
msgstr ""

#: src/dev/reader.md:179
msgid ""
"**FileParserTest.scala**: Tests ReaderV2 against a suite of test files in "
"`tests/parser` directory"
msgstr ""

#: src/dev/reader.md:180
msgid ""
"**FileParserTestV1.scala**: Tests ReaderV1 against the same test suite for "
"comparison"
msgstr ""

#: src/dev/reader.md:182
msgid "These file-based tests:"
msgstr ""

#: src/dev/reader.md:183
msgid "Ensure consistency when parsing complete Chester files"
msgstr ""

#: src/dev/reader.md:184
msgid "Verify parser behavior across a wide range of syntax combinations"
msgstr ""

#: src/dev/reader.md:185
msgid "Automatically generate expected output for regression testing"
msgstr ""

#: src/dev/reader.md:186
msgid "Maintain backward compatibility during parser evolution"
msgstr ""

#: src/dev/reader.md:188
msgid "Future Development"
msgstr ""

#: src/dev/reader.md:190
msgid ""
"ReaderV2 is the focus of ongoing development, with priorities including:"
msgstr ""

#: src/dev/reader.md:192
msgid "Completing error recovery implementation"
msgstr ""

#: src/dev/reader.md:193
msgid "Adding source maps support"
msgstr ""

#: src/dev/reader.md:194
msgid "Migrating any remaining V1-only tests"
msgstr ""

#: src/dev/reader.md:195
msgid "Expanding test coverage"
msgstr ""

#: src/dev/reader.md:196
msgid "Optimizing token handling for better performance"
msgstr ""

#: src/dev/reader.md:198
msgid "See [devlog.md](devlog.md) for chronological implementation details."
msgstr ""

#: src/dev/scalablytyped-bindings.md:3
msgid ""
"This document provides information about where to find and how to use the "
"ScalablyTyped bindings in the Chester project."
msgstr ""

#: src/dev/scalablytyped-bindings.md:5
msgid "Where to Find the Bindings"
msgstr ""

#: src/dev/scalablytyped-bindings.md:7
msgid ""
"The ScalablyTyped bindings for external libraries like `ts-morph` are "
"generated during the build process and stored in the following locations:"
msgstr ""

#: src/dev/scalablytyped-bindings.md:9
msgid "Generated Source Files"
msgstr ""

#: src/dev/scalablytyped-bindings.md:11
msgid "The actual Scala source files for the bindings are located at:"
msgstr ""

#: src/dev/scalablytyped-bindings.md:17
msgid "Within this directory:"
msgstr ""

#: src/dev/scalablytyped-bindings.md:18
msgid "`mod/` directory contains all the main classes and traits"
msgstr ""

#: src/dev/scalablytyped-bindings.md:19
msgid "`anon/` directory contains anonymous types"
msgstr ""

#: src/dev/scalablytyped-bindings.md:20
msgid ""
"`tsMorphBooleans.scala`, `tsMorphInts.scala`, etc. contain constants and "
"types"
msgstr ""

#: src/dev/scalablytyped-bindings.md:22
msgid "Important Files for ts-morph"
msgstr ""

#: src/dev/scalablytyped-bindings.md:24
msgid "Key files for working with ts-morph:"
msgstr ""

#: src/dev/scalablytyped-bindings.md:26
msgid "`mod/SourceFile.scala` - Contains the SourceFile class definition"
msgstr ""

#: src/dev/scalablytyped-bindings.md:27
msgid ""
"`mod/StatementedNode.scala` - Contains methods for accessing interfaces, "
"classes, and type aliases"
msgstr ""

#: src/dev/scalablytyped-bindings.md:28
msgid ""
"`mod/Project.scala` - Contains the Project class for creating and working "
"with projects"
msgstr ""

#: src/dev/scalablytyped-bindings.md:30
msgid "Using the Bindings in Code"
msgstr ""

#: src/dev/scalablytyped-bindings.md:32
msgid "There are two approaches to using ts-morph from Scala.js:"
msgstr ""

#: src/dev/scalablytyped-bindings.md:34
msgid "Approach 1: Using ScalablyTyped Bindings Directly"
msgstr ""

#: src/dev/scalablytyped-bindings.md:36
msgid "To use the ScalablyTyped bindings in your code:"
msgstr ""

#: src/dev/scalablytyped-bindings.md:38
msgid "Import the correct namespace:"
msgstr ""

#: src/dev/scalablytyped-bindings.md:43
msgid ""
"When working with SourceFile to access interfaces, classes, and type "
"aliases, note that:"
msgstr ""

#: src/dev/scalablytyped-bindings.md:44
msgid "`SourceFile` does not directly extend `StatementedNode`"
msgstr ""

#: src/dev/scalablytyped-bindings.md:45
msgid ""
"Use methods like `getInterfaces()`, `getClasses()`, and `getTypeAliases()` "
"from the appropriate trait"
msgstr ""

#: src/dev/scalablytyped-bindings.md:46
msgid ""
"Convert JavaScript arrays to Scala lists using `js.Array.from(...).toList`"
msgstr ""

#: src/dev/scalablytyped-bindings.md:48
msgid "Example access pattern:"
msgstr ""

#: src/dev/scalablytyped-bindings.md:55
msgid "Approach 2: Using Direct JavaScript Interop"
msgstr ""

#: src/dev/scalablytyped-bindings.md:57
msgid ""
"For simpler integration, especially when facing type mismatches or method "
"access issues, you can use direct JavaScript evaluation:"
msgstr ""

#: src/dev/scalablytyped-bindings.md:64
msgid ""
"// Use direct JavaScript interop with triple quotes for multiline JavaScript"
msgstr ""

#: src/dev/scalablytyped-bindings.md:65
msgid ""
"s\"\"\"\n"
"    function analyze(filePath) {\n"
"      const { Project } = require(\"ts-morph\");\n"
"      \n"
"      try {\n"
"        const project = new Project();\n"
"        const sourceFile = project.addSourceFileAtPath(filePath);\n"
"        \n"
"        // Use native JavaScript APIs directly\n"
"        const interfaces = sourceFile.getInterfaces().map(interface => ({\n"
"          name: interface.getName(),\n"
"          // ... other properties\n"
"        }));\n"
"        \n"
"        return JSON.stringify(interfaces);\n"
"      } catch (e) {\n"
"        return JSON.stringify({ error: e.message });\n"
"      }\n"
"    }\n"
"    \n"
"    analyze(\"${"
msgstr ""

#: src/dev/scalablytyped-bindings.md:85
msgid ""
"}\");\n"
"  \"\"\""
msgstr ""

#: src/dev/scalablytyped-bindings.md:90
msgid "This approach:"
msgstr ""

#: src/dev/scalablytyped-bindings.md:91
msgid "Avoids type mismatches and casting issues"
msgstr ""

#: src/dev/scalablytyped-bindings.md:92
msgid "Uses native JavaScript directly"
msgstr ""

#: src/dev/scalablytyped-bindings.md:93
msgid "Returns results as JSON strings"
msgstr ""

#: src/dev/scalablytyped-bindings.md:94
msgid "Escapes Scala-JavaScript interpolation issues using triple quotes"
msgstr ""

#: src/dev/scalablytyped-bindings.md:96
msgid "Common Gotchas"
msgstr ""

#: src/dev/scalablytyped-bindings.md:98
msgid ""
"**Array Conversion**: JavaScript arrays need to be converted to Scala "
"collections using `js.Array.from(...).toList`"
msgstr ""

#: src/dev/scalablytyped-bindings.md:100
msgid ""
"**Method Names**: Some method names in the bindings may differ from the "
"original TypeScript API"
msgstr ""

#: src/dev/scalablytyped-bindings.md:102
msgid ""
"**Inheritance Hierarchy**: The inheritance hierarchy in the bindings may not "
"match the TypeScript original exactly"
msgstr ""

#: src/dev/scalablytyped-bindings.md:104
msgid ""
"**Type Conversion**: Sometimes explicit type conversion is needed when "
"working with the bindings"
msgstr ""

#: src/dev/scalablytyped-bindings.md:106
msgid ""
"**String Interpolation**: When using direct JavaScript eval, use Scala "
"triple quotes (`\"\"\"`) and properly escape JavaScript template literals (`$"
"{...}` to `$${...}`)"
msgstr ""

#: src/dev/scalablytyped-bindings.md:108
#, fuzzy
msgid "Rebuilding Bindings"
msgstr "let 繫結"

#: src/dev/scalablytyped-bindings.md:110
msgid "If you need to rebuild the ScalablyTyped bindings:"
msgstr ""

#: src/dev/scalablytyped-bindings.md:112
msgid "Run `sbt \"jsTypings/stImport\"` to regenerate the bindings"
msgstr ""

#: src/dev/scalablytyped-bindings.md:113
msgid "For troubleshooting binding generation, check `jsTypings/stOutputs`"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:5
msgid ""
"This document outlines specific proposed improvements to Chester's type "
"checking system, focusing on dependent types, union and intersection types, "
"and the integration between the reducer and type checker."
msgstr ""

#: src/dev/tyck-improvement-proposal.md:7
msgid "1. Overview and Background"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:9
msgid ""
"Chester's type system is based on a constraint propagation network where:"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:10
msgid "Type constraints are represented by **propagators**"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:11
msgid "**Cells** hold type information and track their propagators"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:12
msgid "Two types of propagator connections:"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:13
msgid "**Reading**: Propagators that read from a cell"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:14
msgid "**Zonking**: Propagators that can write to or resolve a cell"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:16
msgid ""
"Recent improvements have focused on enhancing support for dependent types, "
"which require:"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:17
msgid "Types that can depend on terms"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:18
msgid "Variable bindings in types with alpha-equivalence checking"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:19
msgid "Sophisticated reduction strategies for type equality"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:21
msgid "2. Current Status and Progress"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:23
msgid ""
"**Note**: Many key improvements have been completed and documented in the "
"devlog entries. Refer to `docs/src/dev/devlog.md` for details on completed "
"improvements, particularly those related to type system enhancements, trait "
"implementation, and the new AutoConnect propagator."
msgstr ""

#: src/dev/tyck-improvement-proposal.md:25
msgid "3. Remaining Issues and Implementation Plan"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:27
msgid "3.1 ✅ Union Type Subtyping Implementation"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:29
#: src/dev/tyck-improvement-proposal.md:42
msgid "**Status: COMPLETED**"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:31
msgid ""
"The union type implementation has been completed with full support for the "
"pipe operator (`|`) syntax and proper subtyping relationships. All "
"components have been implemented as documented in the devlog."
msgstr ""

#: src/dev/tyck-improvement-proposal.md:33
msgid "Completed implementations include:"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:34
msgid "Union-to-Union subtyping (`A|B <: C|D`)"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:35
msgid "Specific-to-Union subtyping (`A <: B|C`)"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:36
msgid "Union-to-Specific subtyping (`A|B <: C`)"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:37
msgid "Cell coverage mechanisms for union types"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:38
msgid "Proper type checking for union types in all contexts"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:40
msgid "3.2 ✅ Removal of the EnsureCellCoverage Hack"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:44
msgid ""
"The `EnsureCellCoverage` hack has been replaced with a proper `AutoConnect` "
"propagator that establishes meaningful type relationships. See the devlog "
"for implementation details."
msgstr ""

#: src/dev/tyck-improvement-proposal.md:46
msgid "Key improvements include:"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:47
msgid "Analysis of term structure to create proper type connections"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:48
msgid "Smart handling of union and intersection types"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:49
msgid "Specialized support for function calls and their arguments"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:50
msgid "Default value support for truly unconstrained type variables"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:51
msgid "Complete removal of all `EnsureCellCoverage` instances"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:53
msgid "All success criteria have been met:"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:54
msgid "All cells are covered by meaningful propagators with actual logic"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:55
msgid "No explicit `EnsureCellCoverage` instances in the codebase"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:56
msgid "Union types and other complex types work correctly"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:57
msgid "Type errors are detected and reported accurately"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:58
msgid "Tests pass with proper constraint checking"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:59
msgid "Improved code clarity and maintainability"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:61
msgid "3.3 Enhanced Type-Level Function Application Reduction"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:63
msgid "Current Limitation"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:65
msgid ""
"The current type checker supports basic type-level function applications, "
"but has limited handling of nested or recursive function applications in "
"type-level contexts. When complex type-level expressions involve multiple "
"nested function calls, the reducer may not properly evaluate them during "
"type checking, leading to:"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:67
msgid "Type errors due to incomplete reduction of nested function applications"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:68
msgid "Reduced flexibility when using type-level functions in complex ways"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:69
msgid "Unclear error messages when type-level function applications fail"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:71 src/dev/typescript-backend.md:82
#: src/dev/typescript-backend.md:120
msgid "Implementation Plan"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:73
msgid "The implementation requires focused changes to:"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:75
msgid "**DefaultReducer Enhancement**:"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:76
msgid "Improve handling of nested type-level function applications"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:77
msgid "Implement recursive handling of type-level function results"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:78
msgid "Ensure consistent reduction behavior for composed functions"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:80
msgid "**Type Checking Integration**:"
msgstr "**類型檢查整合**："

#: src/dev/tyck-improvement-proposal.md:81
msgid ""
"Further enhance the `tryUnify` method to handle complex function call terms"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:82
msgid "Ensure proper cell coverage for nested function applications"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:83
msgid "Add guards to prevent pattern matching conflicts"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:85
msgid "Testable Example"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:87
msgid ""
"```chester\n"
"// Test enhanced type-level function application\n"
"record A(a: Integer);\n"
"record B(b: String);\n"
"\n"
"// Basic identity function for types\n"
"def idType(x: Type): Type = x;\n"
"\n"
"// Function composition at the type level\n"
"def composeTypes(f: Type -> Type, g: Type -> Type, x: Type): Type = "
"f(g(x));\n"
"\n"
"// Test basic composition\n"
"let aT = composeTypes(idType, idType, A);\n"
"def getA(x: aT): Integer = x.a;  // Should work via reduction\n"
"```"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:105
msgid "Nested function applications are properly reduced during type checking"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:106
msgid "Field access on types produced by composed functions works correctly"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:107
msgid "The original function applications are preserved in elaborated results"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:108
msgid "No \"cells not covered by any propagator\" errors occur during zonking"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:110
msgid "4. Testing Strategy"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:112
msgid "4.1 Create Specialized Tests for Dependent Types"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:114
msgid "Implement tests that verify:"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:115
msgid "Function types with type dependencies"
msgstr "帶有類型依賴的函數類型"

#: src/dev/tyck-improvement-proposal.md:116
msgid "Equality of types with different variable names but same structure"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:117
msgid "Union and intersection types with alpha-equivalent components"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:119
msgid "4.2 Union Type Testing Cases"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:121
msgid "Completed test cases:"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:123
msgid ""
"```chester\n"
"// Widening (Success)\n"
"def f(x: Integer): Integer | String = x;\n"
"f(42);\n"
"```"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:129
msgid "Additional test cases needed:"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:131
msgid ""
"```chester\n"
"// Nested Union Types\n"
"def complex(x: (Integer | String) | Boolean): (Integer | String) | Boolean = "
"x;\n"
"\n"
"// Union with parametric types\n"
"def generic<T>(x: T | String): T | String = x;\n"
"\n"
"// Intersection with union\n"
"def mixed(x: (A & B) | C): (A & B) | C = x;\n"
"```"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:142
msgid "5. Implementation Steps"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:144
msgid "5.1 Phase 1: Core Type System Improvements"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:146
msgid "**Status**: Most core improvements have been completed."
msgstr ""

#: src/dev/tyck-improvement-proposal.md:148
msgid "Completed improvements (see devlog for details):"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:149
msgid "✅ Enhanced Type Structure Reduction in DefaultReducer"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:150
msgid "✅ Alpha-Equivalence Checking in TyckPropagator"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:151
msgid "✅ Enhanced Type Level Comparison"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:152
msgid "✅ Cell Coverage Mechanisms with AutoConnect propagator"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:153
msgid "✅ Union Type Subtyping Implementation"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:154
msgid "✅ Basic Trait Implementation"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:156
msgid "Remaining items to complete:"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:157
msgid "Add more complex test cases for nested union types"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:158
msgid ""
"Complete enhanced type-level function application for complex nested cases"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:159
msgid "Add test cases for complex type-level functions"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:161
msgid "5.2 Phase 2: Advanced Type Features"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:162
msgid "Test with complex type-level function examples"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:163
msgid "Verify all success criteria are met"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:164
msgid "Add more test cases for edge cases"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:165
msgid "Document implementation details and usage patterns"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:167
msgid "6. Design Principles to Follow"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:169
msgid "6.1 Term Preservation"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:171
msgid "Never reduce during elaboration"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:172
msgid "Only use reduction for type-level comparisons"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:173
msgid "Preserve source structure for better error reporting"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:175
msgid "6.2 Reduction Strategy"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:176
msgid "Only reduce during type equality checking"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:178
msgid "Use proper reduction context from current context"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:179
msgid "Never reflect internal reductions in output"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:181
msgid "6.3 Documentation"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:182
msgid "Keep this document updated with implementation progress"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:183
msgid "Document design decisions and trade-offs"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:184
msgid "Maintain clear test cases for each feature"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:186
msgid "7. Success Criteria"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:188
msgid "All tests pass, including the specialized dependent type tests"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:189
msgid "The type checking system correctly handles:"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:190
msgid "Complex dependent type scenarios"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:191
msgid "Intersection type comparisons"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:192
msgid "Union type subtyping"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:193
msgid "Type-level function applications"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:194
msgid ""
"Documentation clearly explains dependent type concepts and usage patterns"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:195
msgid "Meta variables in complex types resolve correctly"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:197
msgid "8. Running Tests"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:199
msgid ""
"To run the tests for the type checker specifically, use the following SBT "
"command:"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:202
msgid "# Run the FilesTyckTest suite to test the type checking system\n"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:206
msgid ""
"⚠️ **IMPORTANT WARNING**: Do NOT use the `-z` test filter option (e.g., `sbt "
"\"rootJVM/testOnly -- -z pattern\"`) as it is broken and produces unreliable "
"results. Instead, run the entire test suite and review the results."
msgstr ""

#: src/dev/tyck-improvement-proposal.md:208
msgid "8.5 Quick Test Guide"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:210
msgid "Basic Test Cases By Feature"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:212
msgid ""
"Below are minimal test cases for each feature that can be used for quick "
"verification. Create these in separate `.chester` files in the `tests/tyck/` "
"directory to validate implementation."
msgstr ""

#: src/dev/tyck-improvement-proposal.md:214
msgid "1. Union Type Tests"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:216
msgid ""
"```chester\n"
"// FILE: union_basic.chester\n"
"// Tests basic union type assignment\n"
"let a: Integer | String = 42;\n"
"let b: Integer | String = \"hello\";\n"
"```"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:223
msgid ""
"```chester\n"
"// FILE: union_function.chester\n"
"// Tests function with union type parameters and return\n"
"def identity(x: Integer | String): Integer | String = x;\n"
"let a = identity(42);\n"
"let b = identity(\"hello\");\n"
"```"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:231
msgid ""
"```chester\n"
"// FILE: union_specific.chester\n"
"// Tests union-to-specific subtyping\n"
"def expectNumber(x: Number): Number = x;\n"
"let a: Integer | Float = 42;\n"
"expectNumber(a);  // Should succeed if Integer|Float <: Number\n"
"```"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:239
msgid "2. Trait Tests"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:241
msgid ""
"```chester\n"
"// FILE: trait_basic.chester\n"
"// Tests basic trait implementation\n"
"trait Showable {\n"
"  def show: String;\n"
"}\n"
"\n"
"record Person(name: String, age: Integer) <: Showable {\n"
"  def show: String = name;\n"
"}\n"
"\n"
"let p = Person(\"Alice\", 30);\n"
"let s: Showable = p;\n"
"let name = s.show;\n"
"```"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:257
msgid ""
"```chester\n"
"// FILE: trait_field.chester\n"
"// Tests trait field access\n"
"trait HasName {\n"
"  def name: String;\n"
"}\n"
"\n"
"record User(name: String, email: String) <: HasName;\n"
"\n"
"def getName(x: HasName): String = x.name;\n"
"let u = User(\"Bob\", \"bob@example.com\");\n"
"getName(u);\n"
"```"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:271
msgid "3. Type-Level Function Tests"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:273
msgid ""
"```chester\n"
"// FILE: type_function.chester\n"
"// Tests type-level function application\n"
"def idType(x: Type): Type = x;\n"
"\n"
"record Point(x: Integer, y: Integer);\n"
"let pointType = idType(Point);\n"
"\n"
"def makePoint(p: pointType): pointType = p;\n"
"let p = Point(1, 2);\n"
"makePoint(p);\n"
"```"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:286
msgid "Running Individual Test Cases"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:288
msgid "To run a specific test file:"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:291
msgid "# Compile and run a specific test file\n"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:292
msgid "\"rootJVM/testOnly chester.tyck.FilesTyckTest -- -only add.chester\""
msgstr ""

#: src/dev/tyck-improvement-proposal.md:295
msgid "Test Verification Checklist"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:297
msgid "For each test case, verify:"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:299
msgid "✅ Compilation succeeds without errors"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:300
msgid "✅ Type checks pass correctly"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:301
msgid "✅ No \"cells not covered by any propagator\" errors"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:302
msgid ""
"✅ Error messages are clear and helpful when intentional errors are "
"introduced"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:304
msgid "9. ✅ Trait Implementation Plan"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:306
#: src/dev/tyck-improvement-proposal.md:322
msgid "**Status: BASIC IMPLEMENTATION COMPLETED**"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:308
msgid ""
"Basic trait implementation has been completed and documented in the "
"development log. See the devlog for implementation details."
msgstr ""

#: src/dev/tyck-improvement-proposal.md:310
msgid "Future Enhancements for Traits"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:312
msgid ""
"While basic trait functionality is working, the following enhancements are "
"planned for future implementation:"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:314
msgid "Complete field requirement verification for traits"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:315
msgid "Multiple trait inheritance support"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:316
msgid "Trait method and default implementations"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:317
msgid "More comprehensive trait test cases"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:318
msgid "Advanced trait composition patterns"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:320
msgid "10. ✅ Detailed Plan for Complex Union Types"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:324
msgid ""
"Many of the planned union type improvements have been completed and "
"documented in the devlog. The implementation includes proper handling of "
"union subtyping and cell coverage through the new AutoConnect propagator."
msgstr ""

#: src/dev/tyck-improvement-proposal.md:326
msgid "Future Work for Complex Union Types"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:328
msgid ""
"To further extend support for complex union types (nested unions, unions "
"with generic types), the following detailed technical steps are still needed:"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:330
msgid "**Enhance Parser and Desalter Support**:"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:331
msgid "Improve handling of parenthesized union types"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:332
msgid "Add special handling for union types with generic parameters"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:333
msgid "Support deeper nested union types"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:335
msgid "**Strengthen Type Checking for Advanced Cases**:"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:336
msgid "Enhance handling of nested unions by \"flattening\" when appropriate"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:337
msgid "Improve error reporting for complex union scenarios"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:338
msgid "Update unification to handle multi-level nested unions properly"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:340
msgid "**Expand the Test Suite**:"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:341
msgid "Add specific unit tests for each subtyping scenario"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:342
msgid "Test nested unions with different depths"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:343
msgid "Test unions with different combinations of types"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:344
msgid "Test function types with union parameters and return types"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:345
msgid "Test generic type parameters with union bounds"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:346
msgid ""
"Test more complex scenarios combining unions, intersections, and generic "
"types"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:348
msgid "Success Metrics"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:350
msgid "The implementation will be considered successful when:"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:352
msgid "All test cases pass without errors"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:353
msgid "The type checker correctly handles complex nested unions"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:354
msgid "No \"cells not covered\" exceptions occur"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:355
msgid "Type error messages are clear and help identify the issue"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:356
msgid "The implementation can scale to handle arbitrarily complex union types"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:358
msgid "11. Experimental Implementation Notes: Union Type Improvements"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:360
msgid ""
"During an experimental implementation attempt to fix union type handling, "
"the following specific changes were made to improve union type subtyping and "
"prevent cell coverage errors:"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:362
msgid "11.1 Union-to-Specific Type Relationship Changes"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:364
msgid ""
"The key issue identified was in how union types were converted to specific "
"types (e.g., `Integer | String` to `Integer`):"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:366
msgid "**Original Implementation Issues:**"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:367
msgid ""
"In `TyckPropagator.scala`, the `unionSpecificCompatible` method only checked "
"if ANY component of the union was compatible with the specific type"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:368
msgid ""
"This allowed unsound expressions like `def f(x: Integer | String): Integer = "
"x` to type-check"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:370
msgid "**Specific Changes Made:**"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:371
msgid ""
"Modified `unionSpecificCompatible` method to check if ALL union components "
"are compatible with the specific type"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:372
msgid ""
"Changed the implementation logic from `unionTypes.exists(compatible)` to `!"
"unionTypes.exists(!compatible)`"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:373
msgid ""
"Added explicit error reporting in `handleUnionSpecific` method within the "
"`Unify` case class"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:374
msgid ""
"Enhanced debug output to include step-by-step component compatibility checks"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:375
msgid ""
"Modified `Elaborater.unify` method's union case to properly handle specific-"
"to-union compatibility"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:377
msgid "11.2 DefaultValuePropagator Implementation"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:379
msgid "To solve the \"cells not covered by any propagator\" errors:"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:381
msgid "**Specific Implementation Changes:**"
msgstr "**具體實現變更**："

#: src/dev/tyck-improvement-proposal.md:382
msgid ""
"Rewritten `ensureDefaultValue[T]` method (line ~1087 in "
"`TyckPropagator.scala`):"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:383
msgid "Added explicit `state.addPropagator` call to add a dedicated propagator"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:384
msgid "Added explicit `state.fill` call to ensure cells have values"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:385
msgid "Added diagnostic logging to track cell state"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:387
msgid "Created a new `DefaultValuePropagator[T]` case class with:"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:388
msgid "Set `score = 100` to give it high priority"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:389
msgid "Implemented `run`, `defaulting`, and `naiveFallbackZonk` methods"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:390
msgid ""
"Added proper cell tracking with `readingCells`, `writingCells`, and "
"`defaultingCells`"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:391
msgid ""
"Added custom `identify` method returning `Some(id)` to prevent propagator "
"removal"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:393
msgid "11.3 Infinite Recursion Prevention"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:395
msgid "Specific changes to break cyclic dependencies:"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:397
msgid "In `UnionOf` propagator:"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:398
msgid "Removed recursive calls to `unify` that could cause infinite loops"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:399
msgid "Used early returns and simplified value checking logic"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:400
msgid "Added guard conditions before recursive propagator creation"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:402
msgid "In the `handleUnionSpecific` method:"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:403
msgid ""
"Used `ensureDefaultValue` for each union component instead of creating "
"linked propagators"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:404
msgid ""
"Added filtered component selection before creating propagator connections"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:405
msgid ""
"Used explicit value discarding with statements like `val _ = "
"ensureDefaultValue(unionType)`"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:407
msgid "11.4 Test File Updates"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:409
msgid "Specific file changes:"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:410
msgid ""
"Moved `tests/tyck-fails/union-subtype-fail.chester.todo` to active status by "
"removing `.todo` extension"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:411
msgid ""
"Updated the expected behavior of `def f(x: Integer | String): Integer = x` "
"to correctly fail"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:412
msgid ""
"Modified `tests/tyck/simple-union.chester.todo` to ensure it properly tests "
"union widening"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:414
msgid "11.5 Key Identifier Changes for Future Reference"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:416
msgid "The most significant method and identifier changes were:"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:417
msgid "`unionSpecificCompatible`: Changed compatibility check logic"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:418
msgid "`handleUnionSpecific`: Rewrote to handle ALL union components"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:419
msgid "`ensureDefaultValue`: Enhanced with propagator creation"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:420
msgid "Added new `DefaultValuePropagator` class"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:421
msgid "Modified `Unify.defaulting` case for union handling"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:422
msgid "Updated union component debug logging using `Debug.debugPrint`"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:424
msgid ""
"These changes collectively represent an approach to fixing union type "
"subtyping that ensures sound type checking while preventing \"cells not "
"covered\" errors through improved propagator management."
msgstr ""

#: src/dev/type-checking-system.md:5
msgid "Quick Start Guide"
msgstr ""

#: src/dev/type-checking-system.md:7
msgid ""
"Chester's type checking system is powered by a **propagator network** - a "
"constraint-based approach that allows for complex type relationships."
msgstr ""

#: src/dev/type-checking-system.md:9
msgid "Simple Visual Overview"
msgstr ""

#: src/dev/type-checking-system.md:38
msgid "Key Concepts in 30 Seconds"
msgstr ""

#: src/dev/type-checking-system.md:40
msgid "**Cells** - Hold type information and track connections to propagators"
msgstr ""

#: src/dev/type-checking-system.md:41
msgid ""
"**Propagators** - Define constraints between cells and propagate type "
"information"
msgstr ""

#: src/dev/type-checking-system.md:42
msgid ""
"**Network** - The collection of cells and propagators that work together"
msgstr ""

#: src/dev/type-checking-system.md:44
msgid "When type checking:"
msgstr ""

#: src/dev/type-checking-system.md:45
msgid "Cells store type information (like \"this variable has type Integer\")"
msgstr ""

#: src/dev/type-checking-system.md:46
msgid ""
"Propagators enforce constraints (like \"parameter type must match argument "
"type\")"
msgstr ""

#: src/dev/type-checking-system.md:47
msgid ""
"When a cell value changes, connected propagators activate to propagate that "
"change"
msgstr ""

#: src/dev/type-checking-system.md:49
msgid ""
"This reactive network allows complex type relationships (like union types) "
"to be modeled effectively."
msgstr ""

#: src/dev/type-checking-system.md:53
msgid "1. Core Components"
msgstr ""

#: src/dev/type-checking-system.md:55
msgid "**Cells (`HoldCell`)**"
msgstr ""

#: src/dev/type-checking-system.md:56
msgid "Hold type information and state"
msgstr ""

#: src/dev/type-checking-system.md:57
msgid "Track propagator connections:"
msgstr ""

#: src/dev/type-checking-system.md:60
msgid "// Current value"
msgstr ""

#: src/dev/type-checking-system.md:61
msgid "// Change tracking"
msgstr ""

#: src/dev/type-checking-system.md:67
msgid "**Propagators**"
msgstr ""

#: src/dev/type-checking-system.md:68
msgid "Base trait defining propagator behavior:"
msgstr ""

#: src/dev/type-checking-system.md:79
msgid "2. Key Propagator Types"
msgstr ""

#: src/dev/type-checking-system.md:81
msgid "**Unify Propagator**"
msgstr ""

#: src/dev/type-checking-system.md:82
msgid "Handles type unification and subtyping"
msgstr ""

#: src/dev/type-checking-system.md:83
msgid "Special cases for:"
msgstr ""

#: src/dev/type-checking-system.md:84
msgid "Meta variables"
msgstr ""

#: src/dev/type-checking-system.md:85
msgid "Union types"
msgstr ""

#: src/dev/type-checking-system.md:86
msgid "Intersection types"
msgstr ""

#: src/dev/type-checking-system.md:87
msgid "List types"
msgstr ""

#: src/dev/type-checking-system.md:88
msgid "Record types"
msgstr ""

#: src/dev/type-checking-system.md:90
msgid "**UnionOf Propagator**"
msgstr ""

#: src/dev/type-checking-system.md:91
msgid "Manages union type construction"
msgstr ""

#: src/dev/type-checking-system.md:92
msgid "Handles:"
msgstr ""

#: src/dev/type-checking-system.md:93
msgid "Component type collection"
msgstr ""

#: src/dev/type-checking-system.md:94
msgid "Meta variable resolution"
msgstr ""

#: src/dev/type-checking-system.md:95
msgid "Type compatibility checks"
msgstr ""

#: src/dev/type-checking-system.md:97
msgid "**LiteralType Propagator**"
msgstr ""

#: src/dev/type-checking-system.md:98
msgid "Handles literal type inference"
msgstr "處理字面值類型推斷"

#: src/dev/type-checking-system.md:99
msgid "Manages type constraints for literals"
msgstr ""

#: src/dev/type-checking-system.md:101
msgid "3. Propagation Process"
msgstr ""

#: src/dev/type-checking-system.md:103
msgid "**Registration**"
msgstr ""

#: src/dev/type-checking-system.md:106
msgid "// 1. Create propagator holder"
msgstr ""

#: src/dev/type-checking-system.md:109
msgid "// 2. Register with reading cells"
msgstr ""

#: src/dev/type-checking-system.md:114
msgid "// 3. Register with zonking cells"
msgstr ""

#: src/dev/type-checking-system.md:119
msgid "// 4. Initial run"
msgstr ""

#: src/dev/type-checking-system.md:126
msgid "**Execution**"
msgstr ""

#: src/dev/type-checking-system.md:133
msgid "// Run reading propagators"
msgstr ""

#: src/dev/type-checking-system.md:144
msgid "3. Union Type Subtyping"
msgstr ""

#: src/dev/type-checking-system.md:146
msgid ""
"Chester supports union types (`A|B`) with a sophisticated subtyping "
"relationship managed by the propagator network. The subtyping rules are "
"implemented in the `unify` method in `Elaborater.scala`."
msgstr ""

#: src/dev/type-checking-system.md:148
msgid "Union Subtyping Rules"
msgstr ""

#: src/dev/type-checking-system.md:150
msgid "**Union-to-Union Subtyping**: `(A|B) <: (C|D)`"
msgstr ""

#: src/dev/type-checking-system.md:151
msgid ""
"For each type in the right union, at least one type in the left union must "
"accept it"
msgstr ""

#: src/dev/type-checking-system.md:152
msgid ""
"Implemented by creating propagator connections between compatible component "
"types"
msgstr ""

#: src/dev/type-checking-system.md:154
msgid "**Specific-to-Union Subtyping**: `A <: (B|C)`"
msgstr ""

#: src/dev/type-checking-system.md:155
msgid ""
"A specific type can be used where a union is expected if it's compatible "
"with any union member"
msgstr ""

#: src/dev/type-checking-system.md:156
msgid "Example: Passing an `Integer` to a function expecting `Integer|String`"
msgstr ""

#: src/dev/type-checking-system.md:158
msgid "**Union-to-Specific Subtyping**: `(A|B) <: C`"
msgstr ""

#: src/dev/type-checking-system.md:159
msgid ""
"A union can be assigned to a specific type if all union members are "
"compatible with that type"
msgstr ""

#: src/dev/type-checking-system.md:160
msgid ""
"Example: Returning an `Integer|Float` from a function that promises to "
"return `Number`"
msgstr ""

#: src/dev/type-checking-system.md:162
msgid "Implementation Challenges"
msgstr ""

#: src/dev/type-checking-system.md:164
msgid "The union type subtyping implementation addresses several challenges:"
msgstr ""

#: src/dev/type-checking-system.md:166
msgid ""
"**Cell Coverage**: Ensuring all cells (including component types) are "
"properly covered by propagators"
msgstr ""

#: src/dev/type-checking-system.md:167
msgid ""
"**Meta Variables in Unions**: Special handling for meta variables that "
"appear in unions"
msgstr ""

#: src/dev/type-checking-system.md:168
msgid ""
"**Early Return Prevention**: Avoiding early returns that could leave cells "
"uncovered"
msgstr ""

#: src/dev/type-checking-system.md:169
msgid ""
"**Component Tracking**: Ensuring each component of a union has proper "
"propagator connections"
msgstr ""

#: src/dev/type-checking-system.md:173
msgid ""
"The implementation of the core type system features has been completed with "
"recent significant enhancements. Major milestones include:"
msgstr ""

#: src/dev/type-checking-system.md:175
msgid "1. Cell Coverage Improvements (2025-04-21)"
msgstr ""

#: src/dev/type-checking-system.md:177
msgid ""
"The previously \"hacky\" approach to cell coverage has been completely "
"redesigned:"
msgstr ""

#: src/dev/type-checking-system.md:178
msgid "Removed the `AutoConnect` propagator and related indirection"
msgstr ""

#: src/dev/type-checking-system.md:179
msgid "Implemented direct type relationship handling during unification"
msgstr ""

#: src/dev/type-checking-system.md:180
msgid ""
"Created explicit relationships between types directly at creation/"
"unification points"
msgstr ""

#: src/dev/type-checking-system.md:181
msgid "Simplified codebase by removing several layers of indirection"
msgstr ""

#: src/dev/type-checking-system.md:182
msgid ""
"Maintained the same type checking capabilities with a cleaner implementation"
msgstr ""

#: src/dev/type-checking-system.md:184
msgid "2. Union Type Subtyping (2025-03-25)"
msgstr ""

#: src/dev/type-checking-system.md:186
msgid ""
"Union types are now fully implemented with support for all subtyping "
"relationships:"
msgstr ""

#: src/dev/type-checking-system.md:187
msgid ""
"**Union-to-Union**: `(A|B) <: (C|D)` with proper component compatibility"
msgstr ""

#: src/dev/type-checking-system.md:188
msgid ""
"**Specific-to-Union**: `A <: (B|C)` for cases like passing `Integer` to "
"`Integer|String`"
msgstr ""

#: src/dev/type-checking-system.md:189
msgid ""
"**Union-to-Specific**: `(A|B) <: C` for returning unions from specific "
"return type functions"
msgstr ""

#: src/dev/type-checking-system.md:191
msgid "3. Trait Implementation (2025-03-19)"
msgstr ""

#: src/dev/type-checking-system.md:193
msgid "Basic trait support is now available:"
msgstr ""

#: src/dev/type-checking-system.md:194
msgid "Empty traits and record extension using `<:` syntax"
msgstr ""

#: src/dev/type-checking-system.md:195
msgid "Trait-record subtyping relation in type system"
msgstr ""

#: src/dev/type-checking-system.md:196
msgid "`TraitTypeTerm` representation with proper error reporting"
msgstr ""

#: src/dev/type-checking-system.md:197
msgid "Context tracking for trait processing"
msgstr ""

#: src/dev/type-checking-system.md:199
msgid "Remaining Challenges"
msgstr ""

#: src/dev/type-checking-system.md:201
#, fuzzy
msgid "**Type-Level Computation**"
msgstr "**類型註解檢查**："

#: src/dev/type-checking-system.md:202
msgid "Further improvements to recursive type-level function applications"
msgstr ""

#: src/dev/type-checking-system.md:203
msgid "Advanced dependent types with multiple levels of abstraction"
msgstr ""

#: src/dev/type-checking-system.md:204
msgid "More comprehensive testing of type-level computation"
msgstr ""

#: src/dev/type-checking-system.md:206
msgid "**Advanced Trait Features**"
msgstr ""

#: src/dev/type-checking-system.md:207 src/dev/type-checking-system.md:269
msgid "Complete field requirement verification"
msgstr ""

#: src/dev/type-checking-system.md:208 src/dev/type-checking-system.md:270
msgid "Multiple trait inheritance"
msgstr ""

#: src/dev/type-checking-system.md:209 src/dev/type-checking-system.md:271
msgid "Trait methods and default implementations"
msgstr ""

#: src/dev/type-checking-system.md:210
msgid "Trait-to-trait inheritance constraints"
msgstr ""

#: src/dev/type-checking-system.md:212
msgid "Testing Strategy"
msgstr ""

#: src/dev/type-checking-system.md:214
msgid "1. Coverage Tests"
msgstr ""

#: src/dev/type-checking-system.md:215
msgid "Test basic cell coverage"
msgstr ""

#: src/dev/type-checking-system.md:216
msgid "Test union type component coverage"
msgstr ""

#: src/dev/type-checking-system.md:217
msgid "Test meta variable coverage"
msgstr ""

#: src/dev/type-checking-system.md:219
#, fuzzy
msgid "2. State Tests"
msgstr "第 2 章：語句"

#: src/dev/type-checking-system.md:220
msgid "Test propagator lifecycle"
msgstr ""

#: src/dev/type-checking-system.md:221
msgid "Test union type state"
msgstr ""

#: src/dev/type-checking-system.md:222
msgid "Test meta variable resolution"
msgstr ""

#: src/dev/type-checking-system.md:224
msgid "3. Integration Tests"
msgstr ""

#: src/dev/type-checking-system.md:225
msgid "Test complex type scenarios"
msgstr ""

#: src/dev/type-checking-system.md:226
msgid "Test error handling"
msgstr ""

#: src/dev/type-checking-system.md:227
msgid "Test performance"
msgstr ""

#: src/dev/type-checking-system.md:229
msgid "Trait Implementation"
msgstr ""

#: src/dev/type-checking-system.md:231
msgid ""
"Chester's type system now supports traits and record-trait subtyping "
"relationships through the `<:` syntax, with the following features "
"implemented:"
msgstr ""

#: src/dev/type-checking-system.md:233
msgid "1. Trait Definition and Implementation"
msgstr ""

#: src/dev/type-checking-system.md:236
msgid "// Define a trait"
msgstr ""

#: src/dev/type-checking-system.md:240
msgid "// Record implementing a trait"
msgstr ""

#: src/dev/type-checking-system.md:243
msgid "// Using the record with correct field"
msgstr ""

#: src/dev/type-checking-system.md:248
msgid "2. Trait Subtyping Rules"
msgstr ""

#: src/dev/type-checking-system.md:250
msgid "The type system implements several trait-related subtyping rules:"
msgstr ""

#: src/dev/type-checking-system.md:252
msgid ""
"**Record-Trait Subtyping**: Records that extend traits are considered "
"subtypes of those traits"
msgstr ""

#: src/dev/type-checking-system.md:253
msgid ""
"**Trait-Record Compatibility**: Traits can be used where their implementing "
"records are expected"
msgstr ""

#: src/dev/type-checking-system.md:254
msgid "**Trait-Trait Inheritance**: Traits can extend other traits"
msgstr ""

#: src/dev/type-checking-system.md:256
msgid "3. Implementation Components"
msgstr ""

#: src/dev/type-checking-system.md:258
msgid "The trait implementation consists of several key components:"
msgstr ""

#: src/dev/type-checking-system.md:260
msgid "**TraitTypeTerm** in `Term.scala` for trait type representation"
msgstr ""

#: src/dev/type-checking-system.md:261
msgid "**TraitStmtTerm** for trait definitions with optional bodies"
msgstr ""

#: src/dev/type-checking-system.md:262
msgid ""
"**processTraitStmt** in `ElaboraterBlock.scala` to handle trait declarations"
msgstr ""

#: src/dev/type-checking-system.md:263
msgid ""
"**checkTraitImplementation** in `TyckPropagator.scala` to verify trait "
"implementation"
msgstr ""

#: src/dev/type-checking-system.md:264
msgid ""
"Special context tracking with `withProcessingType` to handle trait bodies"
msgstr ""

#: src/dev/type-checking-system.md:266
msgid "4. Future Enhancements"
msgstr ""

#: src/dev/type-checking-system.md:268
msgid "Future work will focus on:"
msgstr ""

#: src/dev/type-checking-system.md:273
msgid "Best Practices for Cell Management"
msgstr ""

#: src/dev/type-checking-system.md:275
msgid "OnceCell Usage Guidelines"
msgstr ""

#: src/dev/type-checking-system.md:277
msgid ""
"The `OnceCell` implementation is a specialized cell type that enforces "
"single-assignment semantics. Proper usage requires careful attention to "
"avoid errors:"
msgstr ""

#: src/dev/type-checking-system.md:279
msgid "1. Cell Filling Best Practices"
msgstr ""

#: src/dev/type-checking-system.md:281
msgid ""
"**Always check before filling**: Before calling `fill()` on any cell, check "
"if it already has a value using `state.readUnstable(cell)`."
msgstr ""

#: src/dev/type-checking-system.md:282
msgid ""
"**Handle already-filled cells gracefully**: When a cell already has a value, "
"check if new value equals existing value."
msgstr ""

#: src/dev/type-checking-system.md:283
msgid ""
"**Use debug assertions**: Include debug prints for cell operations to trace "
"propagation flow."
msgstr ""

#: src/dev/type-checking-system.md:285
msgid "2. Propagator Implementation Guidelines"
msgstr ""

#: src/dev/type-checking-system.md:287
msgid ""
"**Declare cell dependencies correctly**: Ensure all propagators correctly "
"declare their reading and zonking cell dependencies."
msgstr ""

#: src/dev/type-checking-system.md:288
msgid ""
"**Implement naiveZonk correctly**: The `naiveZonk` method should return "
"appropriate dependencies for zonking."
msgstr ""

#: src/dev/type-checking-system.md:289
msgid ""
"**Be idempotent**: Propagator's `run` method should be idempotent - multiple "
"calls with the same input should produce the same output."
msgstr ""

#: src/dev/type-checking-system.md:291
msgid "3. Type-Level Function Handling"
msgstr ""

#: src/dev/type-checking-system.md:293
msgid "When implementing propagators that handle type-level functions:"
msgstr ""

#: src/dev/type-checking-system.md:295
msgid ""
"**Watch for recursive effects**: Type-level functions may cause recursive "
"propagation attempts"
msgstr ""

#: src/dev/type-checking-system.md:296
msgid ""
"**Avoid modifications during reduction**: When reducing for type equality, "
"don't modify the original terms"
msgstr ""

#: src/dev/type-checking-system.md:297
msgid ""
"**Use correct reduction mode**: Use `ReduceMode.TypeLevel` for reductions "
"needed for type equality checks"
msgstr ""

#: src/dev/typescript-backend.md:5
msgid ""
"This document outlines the implementation plan for a TypeScript backend in "
"the Chester compiler. The backend will take type-checked Chester code and "
"generate equivalent TypeScript code, leveraging the existing JavaScript AST "
"infrastructure."
msgstr ""

#: src/dev/typescript-backend.md:7
msgid "Goals"
msgstr ""

#: src/dev/typescript-backend.md:9
msgid ""
"Create a TypeScript code generator that uses the existing JavaScript AST"
msgstr ""

#: src/dev/typescript-backend.md:10
msgid "Ensure proper handling of Chester's type system in TypeScript output"
msgstr ""

#: src/dev/typescript-backend.md:11
msgid ""
"Support TypeScript-specific features like interfaces, type annotations, and "
"generics"
msgstr ""

#: src/dev/typescript-backend.md:12
msgid "Maintain type safety between Chester and TypeScript"
msgstr ""

#: src/dev/typescript-backend.md:16
msgid ""
"The JavaScript AST (`compiler/shared/src/main/scala/chester/targets/js/"
"AST.scala`) already includes TypeScript-specific nodes"
msgstr ""

#: src/dev/typescript-backend.md:17
msgid ""
"We need to implement the transformation from Chester's type-checked AST to "
"TypeScript AST"
msgstr ""

#: src/dev/typescript-backend.md:18
msgid "We need to implement a code generator for TypeScript"
msgstr ""

#: src/dev/typescript-backend.md:22
msgid "1. TypeScript AST Enhancements"
msgstr ""

#: src/dev/typescript-backend.md:24
msgid ""
"While the existing JavaScript AST includes TypeScript nodes, we may need to "
"extend it with additional TypeScript-specific features:"
msgstr ""

#: src/dev/typescript-backend.md:26
msgid "Ensure all TypeScript type annotations are properly represented"
msgstr ""

#: src/dev/typescript-backend.md:27
msgid ""
"Add support for TypeScript-specific syntax like `readonly`, `namespace`, etc."
msgstr ""

#: src/dev/typescript-backend.md:28
msgid "Implement TypeScript module system support"
msgstr ""

#: src/dev/typescript-backend.md:30
msgid "2. Chester to TypeScript Type Mapping"
msgstr ""

#: src/dev/typescript-backend.md:32
msgid "Create a mapping between Chester's type system and TypeScript types:"
msgstr ""

#: src/dev/typescript-backend.md:34
msgid "TypeScript Type"
msgstr ""

#: src/dev/typescript-backend.md:39
msgid "Unit"
msgstr ""

#: src/dev/typescript-backend.md:39
msgid "void"
msgstr ""

#: src/dev/typescript-backend.md:40
msgid "Type"
msgstr ""

#: src/dev/typescript-backend.md:40
msgid "any"
msgstr ""

#: src/dev/typescript-backend.md:41
msgid "Function"
msgstr ""

#: src/dev/typescript-backend.md:42
msgid "interface"
msgstr ""

#: src/dev/typescript-backend.md:43
msgid "Union"
msgstr ""

#: src/dev/typescript-backend.md:43
msgid "union type"
msgstr ""

#: src/dev/typescript-backend.md:44
msgid "Effect"
msgstr ""

#: src/dev/typescript-backend.md:44
msgid "(see below)"
msgstr ""

#: src/dev/typescript-backend.md:46
msgid "3. Effect System Handling"
msgstr ""

#: src/dev/typescript-backend.md:48
msgid ""
"For Chester's effect system, we have several options for TypeScript "
"representation:"
msgstr ""

#: src/dev/typescript-backend.md:50
msgid "**Type-based approach**: Represent effects as part of function types"
msgstr ""

#: src/dev/typescript-backend.md:56
msgid "**Comment-based approach**: Use TypeScript comments to document effects"
msgstr ""

#: src/dev/typescript-backend.md:62
msgid "**Runtime checking**: Implement runtime effect checking in TypeScript"
msgstr ""

#: src/dev/typescript-backend.md:67
msgid ""
"The recommended approach is #1, as it provides compile-time checking in "
"TypeScript."
msgstr ""

#: src/dev/typescript-backend.md:69
msgid "4. Code Generator Implementation"
msgstr ""

#: src/dev/typescript-backend.md:71
msgid "Implement a TypeScript code generator with the following components:"
msgstr ""

#: src/dev/typescript-backend.md:73
msgid "**AST Transformer**: Convert Chester AST to TypeScript AST"
msgstr ""

#: src/dev/typescript-backend.md:74
msgid "**Type Transformer**: Convert Chester types to TypeScript types"
msgstr ""

#: src/dev/typescript-backend.md:75
msgid "**Effect Transformer**: Handle effect annotations"
msgstr ""

#: src/dev/typescript-backend.md:76
msgid "**Code Emitter**: Generate TypeScript code from the AST"
msgstr ""

#: src/dev/typescript-backend.md:78
msgid "Code Emitter"
msgstr ""

#: src/dev/typescript-backend.md:80
msgid "Transforms the TypeScript AST into a valid TypeScript code string."
msgstr ""

#: src/dev/typescript-backend.md:84
msgid "The backend involves several key components:"
msgstr ""

#: src/dev/typescript-backend.md:86
msgid "1. AST Definition (`js.AST.scala`)"
msgstr ""

#: src/dev/typescript-backend.md:88
msgid ""
"Defines the structure of the target JavaScript/TypeScript Abstract Syntax "
"Tree (AST)."
msgstr ""

#: src/dev/typescript-backend.md:90
msgid "2. AST Transformer"
msgstr ""

#: src/dev/typescript-backend.md:92
msgid ""
"Converts the type-checked Chester **core AST** (`chester.syntax.core.Term`) "
"into the target `js.AST`."
msgstr ""

#: src/dev/typescript-backend.md:93
msgid ""
"**Node Mapping**: Map each relevant `core.Term` node to its equivalent "
"`js.AST` node(s)."
msgstr ""

#: src/dev/typescript-backend.md:94
msgid ""
"**Type Mapping**: Translate Chester types (including unions, records) to "
"TypeScript types."
msgstr ""

#: src/dev/typescript-backend.md:95
msgid ""
"**Effect Transformer**: Handle effect annotations (potentially via comments "
"or specific code structures)."
msgstr ""

#: src/dev/typescript-backend.md:97
msgid "3. Code Emitter"
msgstr ""

#: src/dev/typescript-backend.md:99
msgid "Transforms the `js.AST` into a valid TypeScript code string."
msgstr ""

#: src/dev/typescript-backend.md:101
msgid "Current Status (as of YYYY-MM-DD)"
msgstr ""

#: src/dev/typescript-backend.md:103
msgid ""
"The basic AST node definitions (`js.AST.scala`) exist in `compiler/shared/"
"src/main/scala/chester/targets/js/`."
msgstr ""

#: src/dev/typescript-backend.md:104
msgid ""
"A placeholder backend object (`Backend.scala`) has been created in the same "
"directory (`chester.targets.js` package). It expects "
"`chester.syntax.core.Term` as input and contains basic transformation logic "
"for some nodes, but needs refinement and completion."
msgstr ""

#: src/dev/typescript-backend.md:105
msgid ""
"The AST Transformer logic within `Backend.scala` is incomplete and requires "
"verification against the actual `core.Term` structure."
msgstr ""

#: src/dev/typescript-backend.md:106
msgid "The detailed Code Emitter logic **has not yet been implemented**."
msgstr ""

#: src/dev/typescript-backend.md:107
msgid ""
"The integration of this backend into the main compilation pipeline or test "
"infrastructure needs to be done."
msgstr ""

#: src/dev/typescript-backend.md:109
msgid "Challenges"
msgstr ""

#: src/dev/typescript-backend.md:111
msgid ""
"Mapping Chester's type system (including union types, structural types) to "
"TypeScript's type system."
msgstr ""

#: src/dev/typescript-backend.md:112
msgid ""
"Handling effects and ensuring the generated code respects them (perhaps via "
"comments or specific function signatures)."
msgstr ""

#: src/dev/typescript-backend.md:114
msgid "5. Integration with Compiler Pipeline"
msgstr ""

#: src/dev/typescript-backend.md:116
msgid "Add a TypeScript target option to the compiler"
msgstr ""

#: src/dev/typescript-backend.md:117
msgid "Integrate the TypeScript backend with the existing compilation pipeline"
msgstr ""

#: src/dev/typescript-backend.md:118
msgid "Ensure proper error handling and reporting"
msgstr ""

#: src/dev/typescript-backend.md:122
msgid "**Phase 1: Basic TypeScript Generation**"
msgstr ""

#: src/dev/typescript-backend.md:123
msgid "Implement basic AST transformation"
msgstr ""

#: src/dev/typescript-backend.md:124
msgid "Handle primitive types and simple functions"
msgstr ""

#: src/dev/typescript-backend.md:125
msgid "Generate valid TypeScript code without effects"
msgstr ""

#: src/dev/typescript-backend.md:127
msgid "**Phase 2: Advanced Type Features**"
msgstr ""

#: src/dev/typescript-backend.md:128
msgid "Implement generics"
msgstr ""

#: src/dev/typescript-backend.md:129
msgid "Handle record types and interfaces"
msgstr ""

#: src/dev/typescript-backend.md:130
msgid "Support union and intersection types"
msgstr ""

#: src/dev/typescript-backend.md:132
msgid "**Phase 3: Effect System Integration**"
msgstr ""

#: src/dev/typescript-backend.md:133
msgid "Implement effect type representation"
msgstr ""

#: src/dev/typescript-backend.md:134
msgid "Handle effect propagation in TypeScript"
msgstr ""

#: src/dev/typescript-backend.md:135
msgid "Ensure effect safety in generated code"
msgstr ""

#: src/dev/typescript-backend.md:137
msgid "**Phase 4: Optimization and Refinement**"
msgstr ""

#: src/dev/typescript-backend.md:138
msgid "Optimize generated TypeScript code"
msgstr ""

#: src/dev/typescript-backend.md:139
msgid "Improve readability of output"
msgstr ""

#: src/dev/typescript-backend.md:140
msgid "Add source mapping for debugging"
msgstr ""

#: src/dev/typescript-backend.md:142
msgid "Example Transformation"
msgstr ""

#: src/dev/typescript-backend.md:144
msgid "Chester Input:"
msgstr "Chester 輸入："

#: src/dev/typescript-backend.md:145
msgid ""
"```\n"
"// Function with an effect\n"
"def print(message: String) : Unit / IO = ()\n"
"\n"
"// Function that uses the effect\n"
"def hello() : Unit / IO = {\n"
"  print(\"Hello\")\n"
"}\n"
"\n"
"// Pure function (no effects)\n"
"def pure() : Integer = 123\n"
"```"
msgstr ""

#: src/dev/typescript-backend.md:158
msgid "TypeScript Output:"
msgstr ""

#: src/dev/typescript-backend.md:159
msgid ""
"```typescript\n"
"// Function with an effect\n"
"function print(message: string): IOEffect<void> {\n"
"  // Implementation\n"
"  return undefined as IOEffect<void>;\n"
"}\n"
"\n"
"// Function that uses the effect\n"
"function hello(): IOEffect<void> {\n"
"  print(\"Hello\");\n"
"  return undefined as IOEffect<void>;\n"
"}\n"
"\n"
"// Pure function (no effects)\n"
"function pure(): number {\n"
"  return 123;\n"
"}\n"
"\n"
"// Effect type definitions\n"
"type Effect = { readonly __effect: unique symbol };\n"
"type IOEffect<T> = T & { readonly __io: unique symbol };\n"
"type StateEffect<T> = T & { readonly __state: unique symbol };\n"
"```"
msgstr ""

#: src/dev/typescript-backend.md:185
msgid ""
"The TypeScript backend can generate valid TypeScript code from Chester "
"programs"
msgstr ""

#: src/dev/typescript-backend.md:186
msgid ""
"The generated TypeScript code maintains the type safety of the original "
"Chester code"
msgstr ""

#: src/dev/typescript-backend.md:187
msgid "Effects are properly represented and checked in the TypeScript output"
msgstr ""

#: src/dev/typescript-backend.md:188
msgid "The TypeScript code is readable and follows TypeScript best practices"
msgstr ""

#: src/dev/union_types_progress.md:5
msgid ""
"This document outlines the implementation and current state of union types "
"in Chester."
msgstr ""

#: src/dev/union_types_progress.md:7
msgid "Current State"
msgstr ""

#: src/dev/union_types_progress.md:9
msgid ""
"Union types are now fully implemented in Chester with both parsing and type "
"checking support. The implementation can handle all three key subtyping "
"relationships: union-to-union, specific-to-union, and union-to-specific."
msgstr ""

#: src/dev/union_types_progress.md:11
#, fuzzy
msgid "Implementation Overview"
msgstr "實作方法"

#: src/dev/union_types_progress.md:13
msgid "The following components have been implemented to support union types:"
msgstr ""

#: src/dev/union_types_progress.md:15
msgid "1. Parser & Desalting (`Desalt.scala`)"
msgstr ""

#: src/dev/union_types_progress.md:17
msgid ""
"**Union Type Parsing**: Implemented in the `desugar` method to handle union "
"type expressions:"
msgstr ""

#: src/dev/union_types_progress.md:18
msgid "Detects `|` operators in type expressions"
msgstr ""

#: src/dev/union_types_progress.md:19
msgid "Creates a `UnionTypeExpr` node with component types"
msgstr ""

#: src/dev/union_types_progress.md:20
msgid "Handles nested union types properly"
msgstr ""

#: src/dev/union_types_progress.md:21
msgid "Preserves source position information for error reporting"
msgstr ""

#: src/dev/union_types_progress.md:22
msgid "Respects operator precedence and grouping"
msgstr ""

#: src/dev/union_types_progress.md:24
msgid "The parser now correctly recognizes syntax like:"
msgstr ""

#: src/dev/union_types_progress.md:25
msgid ""
"```chester\n"
"// Simple union type\n"
"function accept(value: Integer | String) { ... }\n"
"\n"
"// Nested union types\n"
"function process(data: Integer | String | (Array | Object)) { ... }\n"
"\n"
"// Union in type annotation\n"
"let value: Integer | String = \"hello\";\n"
"```"
msgstr ""

#: src/dev/union_types_progress.md:36
msgid "2. Type Elaboration (`Elaborater.scala`)"
msgstr ""

#: src/dev/union_types_progress.md:38
msgid ""
"**Union Type Elaboration**: Implemented handling for union type expressions "
"in the type checking system:"
msgstr ""

#: src/dev/union_types_progress.md:39
msgid "Elaborate each component type in the union"
msgstr ""

#: src/dev/union_types_progress.md:40
msgid "Create proper `Union` term with component types"
msgstr ""

#: src/dev/union_types_progress.md:41
msgid "Register appropriate propagators for type constraints"
msgstr ""

#: src/dev/union_types_progress.md:42
msgid "Maintain connections between union types and components"
msgstr ""

#: src/dev/union_types_progress.md:44
msgid ""
"**Union Type Unification**: Implemented support for all three subtyping "
"relationships:"
msgstr ""

#: src/dev/union_types_progress.md:45
msgid ""
"**Union-to-Union**: `(A|B) <: (C|D)` with proper component compatibility "
"checks"
msgstr ""

#: src/dev/union_types_progress.md:46
msgid ""
"**Specific-to-Union**: `A <: (B|C)` for cases like passing `Integer` to a "
"parameter of type `Integer|String`"
msgstr ""

#: src/dev/union_types_progress.md:47
msgid ""
"**Union-to-Specific**: `(A|B) <: C` for returning a union from a function "
"with specific return type"
msgstr ""

#: src/dev/union_types_progress.md:49
msgid ""
"**Type-Level Functions with Union Types**: Added support for type-level "
"functions that:"
msgstr ""

#: src/dev/union_types_progress.md:50
msgid "Return union types"
msgstr ""

#: src/dev/union_types_progress.md:51
msgid "Accept union types as arguments"
msgstr ""

#: src/dev/union_types_progress.md:52
msgid "Process union components correctly"
msgstr ""

#: src/dev/union_types_progress.md:54
msgid "The implementation enables code patterns like:"
msgstr ""

#: src/dev/union_types_progress.md:56
msgid ""
"```chester\n"
"// Accepting a union type parameter\n"
"def process(value: Integer | String): String = {\n"
"  match value {\n"
"    case i: Integer => i.toString()\n"
"    case s: String => s\n"
"  }\n"
"}\n"
"\n"
"// Returning a union type\n"
"def fetch(): Integer | String | Null = {\n"
"  if (hasData()) getData()\n"
"  else null\n"
"}\n"
"\n"
"// Union types in generic contexts\n"
"def firstOrDefault[T](list: List[T], default: T): T = {\n"
"  if (isEmpty(list)) default else first(list)\n"
"}\n"
"```"
msgstr ""

#: src/dev/union_types_progress.md:77
msgid "3. Type Propagator (`TyckPropagator.scala`)"
msgstr ""

#: src/dev/union_types_progress.md:79
msgid ""
"**UnionOf Propagator Implementation**: Implemented the `UnionOf` propagator "
"to handle union type constraints:"
msgstr ""

#: src/dev/union_types_progress.md:80
msgid "Manages relationships between union types and their components"
msgstr ""

#: src/dev/union_types_progress.md:81
msgid "Enforces proper subtyping relationships with union types"
msgstr ""

#: src/dev/union_types_progress.md:82
msgid "Handles cell coverage for all union components"
msgstr ""

#: src/dev/union_types_progress.md:83
msgid "Ensures proper zonking of union types"
msgstr ""

#: src/dev/union_types_progress.md:85
msgid ""
"**Enhanced Type Compatibility for Union Types**: Implemented union type "
"compatibility with three key cases:"
msgstr ""

#: src/dev/union_types_progress.md:87
msgid "**Union-to-Union Compatibility**:"
msgstr ""

#: src/dev/union_types_progress.md:90
msgid "// For union-to-union subtyping, we check component compatibility"
msgstr ""

#: src/dev/union_types_progress.md:91
msgid ""
"// with complex rules for determining when unions are subtypes of each other"
msgstr ""

#: src/dev/union_types_progress.md:95
msgid "**Term-to-Union Compatibility**:"
msgstr ""

#: src/dev/union_types_progress.md:98
msgid "// For term-to-union subtyping, we check if the term is compatible"
msgstr ""

#: src/dev/union_types_progress.md:99
msgid "// with any type in the union"
msgstr ""

#: src/dev/union_types_progress.md:103
msgid "**Union-to-Term Compatibility**:"
msgstr ""

#: src/dev/union_types_progress.md:106
msgid "// For union-to-term subtyping, we check if all types in the union"
msgstr ""

#: src/dev/union_types_progress.md:107
msgid "// are compatible with the term"
msgstr ""

#: src/dev/union_types_progress.md:111
msgid ""
"**Cell Coverage Implementation**: Added comprehensive cell coverage "
"mechanisms:"
msgstr ""

#: src/dev/union_types_progress.md:112
msgid "Direct connections between union types and their components"
msgstr ""

#: src/dev/union_types_progress.md:113
msgid "Self-coverage for component types"
msgstr ""

#: src/dev/union_types_progress.md:114
msgid "Enhanced zonking capabilities for union types"
msgstr ""

#: src/dev/union_types_progress.md:115
msgid "Prevention of early returns that could leave cells uncovered"
msgstr ""

#: src/dev/union_types_progress.md:117
msgid "4. Test Framework and Validation"
msgstr ""

#: src/dev/union_types_progress.md:119
msgid ""
"**Comprehensive Test Suite**: Added a complete set of tests to validate "
"union type functionality:"
msgstr ""

#: src/dev/union_types_progress.md:120
msgid "Basic union type syntax tests"
msgstr ""

#: src/dev/union_types_progress.md:121
msgid "Union type subtyping tests (all three relationship types)"
msgstr ""

#: src/dev/union_types_progress.md:122
msgid "Union type pattern matching tests"
msgstr ""

#: src/dev/union_types_progress.md:123
#, fuzzy
msgid "Function with union type parameters and return values"
msgstr "帶有類型依賴的函數類型"

#: src/dev/union_types_progress.md:124
msgid "Cell coverage tests for union types"
msgstr ""

#: src/dev/union_types_progress.md:125
msgid "Edge cases and error handling tests"
msgstr ""

#: src/dev/union_types_progress.md:127
#, fuzzy
msgid "**Test Files**:"
msgstr "**測試狀態**："

#: src/dev/union_types_progress.md:128
msgid "`tests/tyck/simplest_union.chester`: Basic union type functionality"
msgstr ""

#: src/dev/union_types_progress.md:129
msgid "`tests/tyck/union-subtype.chester`: Union subtyping relationships"
msgstr ""

#: src/dev/union_types_progress.md:130
msgid ""
"`tests/tyck/union-pattern-matching.chester`: Pattern matching with union "
"types"
msgstr ""

#: src/dev/union_types_progress.md:131
msgid ""
"Various integration tests using union types with other language features"
msgstr ""

#: src/dev/union_types_progress.md:133
msgid "Current Status and Future Work"
msgstr ""

#: src/dev/union_types_progress.md:135
msgid "Completed"
msgstr ""

#: src/dev/union_types_progress.md:137
msgid "✅ Parser support for union type syntax"
msgstr ""

#: src/dev/union_types_progress.md:138
msgid "✅ Type elaboration for union types"
msgstr ""

#: src/dev/union_types_progress.md:139
msgid "✅ Full union type subtyping relationships"
msgstr ""

#: src/dev/union_types_progress.md:140
msgid "✅ Cell coverage mechanisms for union types"
msgstr ""

#: src/dev/union_types_progress.md:141
msgid "✅ Error reporting for union type mismatch errors"
msgstr ""

#: src/dev/union_types_progress.md:142
msgid "✅ Integration with trait types and interfaces"
msgstr ""

#: src/dev/union_types_progress.md:143
#, fuzzy
msgid "✅ Pattern matching with union types"
msgstr "模式匹配和類型使用"

#: src/dev/union_types_progress.md:145
msgid "Future Enhancements"
msgstr ""

#: src/dev/union_types_progress.md:147
msgid "More comprehensive error messages for specific union type errors"
msgstr ""

#: src/dev/union_types_progress.md:148
msgid "Performance optimizations for complex union types"
msgstr ""

#: src/dev/union_types_progress.md:149
msgid "Enhanced type inference with union types"
msgstr ""

#: src/dev/union_types_progress.md:150
msgid "Integration with effect system"
msgstr ""

#: src/dev/union_types_progress.md:151
msgid "Compiler backend optimizations for union types"
msgstr ""

#: src/dev/union_types_progress.md:155
msgid "Main implementation files:"
msgstr ""

#: src/dev/union_types_progress.md:156
msgid "`Desalt.scala` (parser implementation)"
msgstr ""

#: src/dev/union_types_progress.md:157
msgid "`Elaborater.scala` (type checking implementation)"
msgstr ""

#: src/dev/union_types_progress.md:158
msgid "`TyckPropagator.scala` (propagator implementation)"
msgstr ""

#: src/dev/union_types_progress.md:159
msgid "`Term.scala` (union type representation)"
msgstr ""

#: src/dev/union_types_progress.md:161
msgid "Test files:"
msgstr ""

#: src/dev/union_types_progress.md:162
msgid "`tests/tyck/simplest_union.chester`"
msgstr ""

#: src/dev/union_types_progress.md:163
msgid "`tests/tyck/union-subtype.chester`"
msgstr ""

#: src/dev/union_types_progress.md:164
msgid "Other integration test files"
msgstr ""

#: src/dev/union_types_progress.md:166
#, fuzzy
msgid "Related documentation:"
msgstr "**構建文檔**："

#: src/dev/union_types_progress.md:167
#, fuzzy
msgid "Type checking system documentation"
msgstr "**類型檢查整合**："

#: src/dev/union_types_progress.md:168
msgid "Trait implementation documentation"
msgstr ""

#: src/guide/Record.md:3
msgid ""
"Chester provides a concise and powerful syntax for defining records, which "
"are similar to structs or classes in other languages. Records in Chester are "
"immutable by default and provide a convenient way to group related data."
msgstr ""
"Chester 提供了簡潔而強大的語法來定義記錄（records），這類似於其他語言中的結構"
"體（structs）或類（classes）。Chester 中的記錄預設是不可變的，並提供了一種便"
"捷的方式來組織相關數據。"

#: src/guide/Record.md:5
msgid "Basic Record Syntax"
msgstr "記錄的基本語法"

#: src/guide/Record.md:7
msgid "The basic syntax for defining a record in Chester is as follows:"
msgstr "Chester 中定義記錄的基本語法如下："

#: src/guide/Record.md:13
msgid "Here's a simple example of a `Person` record:"
msgstr "以下是一個簡單的 `Person` 記錄範例："

#: src/guide/Record.md:19
msgid "Using Records"
msgstr "使用記錄"

#: src/guide/Record.md:21
msgid ""
"Once defined, you can create instances of records and access their fields:"
msgstr "一旦定義，就可以創建記錄的實例並訪問它們的字段："

#: src/guide/Record.md:23
msgid ""
"```chester,playground,editable\n"
"let alice = Person(\"Alice\", 30);\n"
"println(alice.name);  // Outputs: Alice\n"
"println(alice.age);   // Outputs: 30\n"
"```"
msgstr ""
"```chester,playground,editable\n"
"let alice = Person(\"Alice\", 30);\n"
"println(alice.name);  // 輸出: Alice\n"
"println(alice.age);   // 輸出: 30\n"
"```"

#: src/guide/statements.md:3
msgid "Scope of `let` and `def`"
msgstr "let 和 def 的範圍"

#: src/guide/statements.md:5
msgid ""
"In Chester, `let` and `def` are used to declare bindings, but they differ in "
"how they handle scoping and forward references. Understanding these "
"differences is crucial for writing correct and efficient Chester programs."
msgstr ""
"在 Chester 中，let 和 def 用於宣告繫結，但它們在處理範圍和前向引用時有所不"
"同。了解這些差異對於撰寫正確且高效的 Chester 程式至關重要。"

#: src/guide/statements.md:7
msgid "`let` Bindings"
msgstr "let 繫結"

#: src/guide/statements.md:9
msgid ""
"**Local Scope**: `let` bindings are only visible **after** their declaration "
"within the current block."
msgstr "**區域範圍**：let 繫結僅在宣告後在當前塊中可見。"

#: src/guide/statements.md:10
msgid ""
"**No Forward References**: You cannot reference a `let` binding before it's "
"declared."
msgstr "**不允許前向引用**：你不能在宣告之前引用 let 繫結。"

#: src/guide/statements.md:11
msgid ""
"**Type Inference**: If no type annotation is provided, the compiler infers "
"the type from the binding's body."
msgstr "**類型推斷**：如果沒有提供類型註解，編譯器會從繫結的主體推斷類型。"

#: src/guide/statements.md:13 src/guide/statements.md:33
msgid "**Example:**"
msgstr "**範例**："

#: src/guide/statements.md:15
msgid ""
"```chester,playground,editable\n"
"// Correct usage of 'let'\n"
"let x = 5;\n"
"let y = x; // 'x' is defined before use\n"
"```"
msgstr ""
"```chester,playground,editable\n"
"// 正確使用 let\n"
"let x = 5;\n"
"let y = x; // 'x' 在使用前已定義\n"
"```"

#: src/guide/statements.md:21
msgid ""
"```chester,playground,editable\n"
"// Incorrect usage of 'let'\n"
"let y = x + 2; // Error: 'x' is not defined yet\n"
"let x = 5;\n"
"```"
msgstr ""

#: src/guide/statements.md:27
msgid "`def` Bindings"
msgstr ""

#: src/guide/statements.md:29
msgid ""
"**Global Scope**: `def` bindings are visible throughout the entire block, "
"even before their declaration."
msgstr "**全域範圍**：def 繫結在整個塊中可見，甚至在宣告之前。"

#: src/guide/statements.md:30
msgid ""
"**Allows Forward References**: You can reference a `def` binding before it's "
"declared."
msgstr "**允許前向引用**：你可以在宣告之前引用 def 繫結。"

#: src/guide/statements.md:31
msgid ""
"**Type Annotation Required for Forward References**: If you use a `def` "
"binding before its declaration, you must provide a type annotation."
msgstr "**需要類型註解**：如果你在宣告之前使用 def 繫結，必須提供類型註解。"

#: src/guide/statements.md:35
msgid ""
"```chester,playground,editable\n"
"// Correct usage of 'def' with type annotation\n"
"def y = square(5); // 'square' is used before its declaration\n"
"\n"
"def square(n: Int) = n * n; // Type annotation for 'n' is required\n"
"```"
msgstr ""
"```chester,playground,editable\n"
"// 正確使用 def 並提供類型註解\n"
"def y = square(5); // 'square' 在使用前已宣告\n"
"\n"
"def square(n: Int) = n * n; // 需要類型註解\n"
"```"

#: src/guide/statements.md:42
msgid ""
"```chester,playground,editable\n"
"// Incorrect usage of 'def' without type annotation\n"
"def y = increment(5); // 'increment' is used before its declaration\n"
"\n"
"def increment(n) = n + 1; // Error: Missing type annotation for 'n'\n"
"```"
msgstr ""

#: src/guide/statements.md:49
msgid "Summary of Scoping Rules"
msgstr "範圍規則摘要"

#: src/guide/statements.md:51
msgid "**`let` Bindings**:"
msgstr "**let 繫結**："

#: src/guide/statements.md:52
msgid "Visible only after their declaration within the current block."
msgstr "僅在當前塊中宣告後可見。"

#: src/guide/statements.md:53
msgid "Do **not** allow forward references."
msgstr "不允許前向引用。"

#: src/guide/statements.md:54
msgid "Type annotations are optional if the type can be inferred."
msgstr "如果類型可以推斷，則類型註解是可選的。"

#: src/guide/statements.md:56
msgid "**`def` Bindings**:"
msgstr "**def 繫結**："

#: src/guide/statements.md:57
msgid "Visible throughout the entire block."
msgstr "在整個塊中可見。"

#: src/guide/statements.md:58
msgid "Allow forward references."
msgstr "允許前向引用。"

#: src/guide/statements.md:59
msgid "Require type annotations when used before their declarations."
msgstr "在宣告之前使用時需要類型註解。"

#: src/guide/statements.md:61
msgid "Compiler Behavior"
msgstr "編譯器行為"

#: src/guide/statements.md:63
msgid ""
"When processing a block, the Chester compiler handles `let` and `def` "
"bindings differently to manage scope and type checking."
msgstr ""
"當處理一個塊時，Chester 編譯器會以不同的方式處理 let 和 def 繫結，以管理範圍"
"和類型檢查。"

#: src/guide/statements.md:65
msgid "Processing `def` Bindings"
msgstr "處理 def 繫結"

#: src/guide/statements.md:67
msgid "**Collection Phase**:"
msgstr "**收集階段**："

#: src/guide/statements.md:68
msgid ""
"The compiler collects all `def` bindings, noting their names, type "
"annotations, and identifiers."
msgstr "編譯器收集所有 def 繫結，記錄它們的名稱、類型註解和識別符。"

#: src/guide/statements.md:69
msgid "It tracks forward references to detect usages before declarations."
msgstr "它追蹤前向引用以檢測在宣告之前的用法。"

#: src/guide/statements.md:71
msgid "**Type Annotation Checks**:"
msgstr "**類型註解檢查**："

#: src/guide/statements.md:72
msgid ""
"For forward-referenced `def` bindings without type annotations, the compiler "
"reports a `MissingTypeAnnotationError`."
msgstr ""
"對於沒有類型註解的前向引用 def 繫結，編譯器會報告 "
"`MissingTypeAnnotationError`。"

#: src/guide/statements.md:74
msgid "**Context Updates**:"
msgstr "**上下文更新**："

#: src/guide/statements.md:75
msgid ""
"The compiler adds placeholders or inferred types to the context, allowing "
"forward-referenced `def` bindings to be used."
msgstr "編譯器將佔位符或推斷的類型添加到上下文中，允許使用前向引用 def 繫結。"

#: src/guide/statements.md:77
msgid "Processing `let` Bindings"
msgstr ""

#: src/guide/statements.md:79
msgid "**Sequential Processing**:"
msgstr ""

#: src/guide/statements.md:80
msgid "`let` bindings are processed in order of their appearance."
msgstr ""

#: src/guide/statements.md:81
msgid "Each `let` binding is added to the context **after** its declaration."
msgstr ""

#: src/guide/statements.md:82
msgid "**No Forward References**:"
msgstr ""

#: src/guide/statements.md:83
msgid "Referencing a `let` binding before its declaration results in an error."
msgstr ""

#: src/guide/statements.md:87
msgid ""
"Use `let` when you don't need to reference the binding before its "
"declaration."
msgstr ""

#: src/guide/statements.md:88
msgid ""
"Use `def` when you need forward references or are defining recursive "
"functions."
msgstr "當需要前向引用或定義遞歸函數時使用 def。"

#: src/guide/statements.md:89
msgid ""
"Always provide type annotations for `def` bindings that are forward-"
"referenced to avoid compilation errors."
msgstr "為了避免編譯錯誤，始終為前向引用 def 繫結提供類型註解。"

#: src/guide/statements.md:91
msgid ""
"By understanding these scoping rules, you can write more predictable and "
"maintainable Chester code."
msgstr "通過理解這些範圍規則，可以撰寫更可預測且可維護的 Chester 程式。"

#: src/guide/syntax-grammar.md:3
msgid ""
"**IMPORTANT NOTE:** This document provides only a rough description of the "
"Chester language syntax and might be highly incorrect or not fully aligned "
"with the current implementation. It should be used as a general guide rather "
"than a precise specification."
msgstr ""
"**重要提示：** 本文檔僅提供Chester語言語法的大致描述，可能高度不準確或與當前"
"實現不完全一致。應將其用作一般指南，而非精確的規範。"

#: src/guide/syntax-grammar.md:5
msgid ""
"This document attempts to describe the Chester language syntax using a BNF-"
"like notation."
msgstr "本文檔嘗試使用類似BNF的符號來描述Chester語言語法。"

#: src/guide/syntax-grammar.md:7
msgid ""
"**Note:** Whitespace and comments (`// ...`) are generally allowed between "
"tokens and are not explicitly shown in the grammar rules unless significant "
"(like newlines in blocks)."
msgstr ""
"**注意：** 空白字符和註釋（`// ...`）通常允許在標記之間出現，除非有特殊意義"
"（如區塊中的換行），否則在語法規則中不會明確顯示。"

#: src/guide/syntax-grammar.md:9
msgid "Top Level"
msgstr "頂層結構"

#: src/guide/syntax-grammar.md:16
msgid ""
"_Note: In many contexts (like blocks or top-level), newlines can act as "
"statement separators similar to semicolons. The last expression in a block "
"acts as its return value unless followed by a semicolon._"
msgstr ""
"_注意：在許多上下文（如區塊或頂層）中，換行可以像分號一樣作為語句分隔符。區塊"
"中的最後一個表達式作為其返回值，除非後跟分號。_"

#: src/guide/syntax-grammar.md:20
msgid ""
"```bnf\n"
"Expr ::= Atom | Expr Operator Expr | Operator Expr | Expr Operator\n"
"\n"
"Atom ::= ID\n"
"       | Literal\n"
"       | Tuple\n"
"       | List\n"
"       | Block\n"
"       | Object\n"
"       | Application\n"
"       | MethodCall\n"
"       | SymbolLookup\n"
"       | Keyword\n"
"\n"
"Tuple ::= '(' ExprList? ')'\n"
"List  ::= '[' ExprList? ']'\n"
"Block ::= '{' Statement* Expr? '}'\n"
"\n"
"ExprList ::= Expr (',' Expr)* ','?\n"
"\n"
"Application ::= GenericApplication | FunctionCall | BlockApplication | "
"CombinedApplication\n"
"GenericApplication ::= Atom '[' ExprList ']'\n"
"FunctionCall ::= Atom '(' ExprList? ')'\n"
"BlockApplication ::= Atom Block\n"
"CombinedApplication ::= GenericApplication FunctionCall\n"
"                      | GenericApplication BlockApplication\n"
"                      | FunctionCall BlockApplication\n"
"                      | GenericApplication FunctionCall BlockApplication\n"
"\n"
"MethodCall   ::= Atom '.' ID ('(' ExprList? ')')?  // Parentheses are "
"optional for field access\n"
"Attribute ::= '@' ID // NOT IMPLEMENTED YET\n"
"Keyword      ::= '#' ID (GenericApplication | FunctionCall)*\n"
"```"
msgstr ""

#: src/guide/syntax-grammar.md:54
msgid ""
"_Note: All identifiers are treated uniformly at the syntax level, with no "
"distinction between different kinds of identifiers. Operator precedence and "
"associativity are handled during semantic analysis, not in the grammar._"
msgstr ""

#: src/guide/syntax-grammar.md:56
msgid "Object Literals"
msgstr "物件字面值"

#: src/guide/syntax-grammar.md:73
msgid "Literals"
msgstr "字面值"

#: src/guide/syntax-grammar.md:75
msgid ""
"```bnf\n"
"Literal ::= INT_LITERAL\n"
"          | RAT_LITERAL\n"
"          | STRING_LITERAL\n"
"          | SYMBOL_LITERAL\n"
"\n"
"SYMBOL_LITERAL ::= \"'\" ID\n"
"```"
msgstr ""

#: src/guide/syntax-grammar.md:84
msgid "Terminals"
msgstr "終結符"

#: src/guide/syntax-grammar.md:86
msgid ""
"```bnf\n"
"ID             ::= /* Starts with letter, _, or emoji; contains letters, "
"digits, _, emoji */\n"
"Operator       ::= /* Sequence of operator symbols like +, -, *, /, =, ->, "
"=>, :, ., etc. */\n"
"INT_LITERAL    ::= /* Integer in decimal, hex (0x...), or binary (0b...) "
"format */\n"
"RAT_LITERAL    ::= /* Rational/float literal (e.g., 1.2, 3.14e-5) */\n"
"STRING_LITERAL ::= /* Double-quoted string \"...\" with escapes */\n"
"Newline        ::= /* \\n or \\r\\n */\n"
"```"
msgstr ""

#: src/guide/syntax-grammar.md:95
msgid "Punctuation and Symbols (Terminals)"
msgstr "標點符號和符號（終結符）"

#: src/guide/trait-and-interface.md:3
msgid ""
"Chester provides two distinct mechanisms for defining abstract types: traits "
"and interfaces. While both serve to define contracts that other types can "
"implement, they differ in their subtyping behavior and intended use cases."
msgstr ""
"Chester提供了兩種不同的機制來定義抽象類型：特質(traits)和介面(interfaces)。雖"
"然它們都用於定義其他類型可以實現的契約，但它們在子類型行為和預期用例方面有所"
"不同。"

#: src/guide/trait-and-interface.md:5
msgid "Traits: Nominal Subtyping"
msgstr "特質：名義子類型"

#: src/guide/trait-and-interface.md:7
msgid ""
"Traits in Chester use nominal subtyping, which means that the name of the "
"type is significant in determining subtype relationships."
msgstr ""
"Chester中的特質使用名義子類型(nominal subtyping)，這意味著類型的名稱在確定子"
"類型關係時很重要。"

#: src/guide/trait-and-interface.md:9
msgid "Here's an example of a trait definition in Chester:"
msgstr "以下是 Chester 中的特質定義範例："

#: src/guide/trait-and-interface.md:11
msgid ""
"```chester,playground,editable\n"
"trait Animal {\n"
"  def makeSound: String;\n"
"}\n"
"\n"
"object Dog <: Animal {\n"
"  override def makeSound: String = \"Woof!\";\n"
"}\n"
"```"
msgstr ""

#: src/guide/trait-and-interface.md:21
msgid ""
"In this example, `Dog` is explicitly declared as a subtype of `Animal` using "
"the `<:` operator. This relationship is based on the names of the types, not "
"just their structure."
msgstr ""
"在此例中，`Dog` 通過使用 `<:` 操作符明確聲明為 `Animal` 的子類型。這種關係基"
"於類型的名稱，而不僅僅是它們的結構。"

#: src/guide/trait-and-interface.md:23
msgid "Interfaces: Structural Subtyping"
msgstr "介面：結構子類型"

#: src/guide/trait-and-interface.md:25
msgid ""
"Interfaces in Chester use structural subtyping, which means that subtype "
"relationships are determined by the structure (methods and properties) of "
"the types, regardless of their names."
msgstr ""
"Chester中的介面使用結構子類型(structural subtyping)，這意味著子類型關係是由類"
"型的結構（方法和屬性）決定的，而不考慮它們的名稱。"

#: src/guide/trait-and-interface.md:27
msgid "Here's an example of an interface definition:"
msgstr "以下是介面定義的範例："

#: src/guide/trait-and-interface.md:29
msgid ""
"```chester,playground,editable\n"
"interface Soundmaker {\n"
"  def makeSound: String;\n"
"}\n"
"\n"
"object Cat {\n"
"  def makeSound: String = \"Meow!\";\n"
"}\n"
"\n"
"// Cat is implicitly a Soundmaker because it has a matching structure\n"
"def soundmaker: Soundmaker = Cat;\n"
"```"
msgstr ""

#: src/guide/trait-and-interface.md:42
msgid ""
"In this case, `Cat` is considered a subtype of `Soundmaker` because it has a "
"matching `makeSound` method, even though it wasn't explicitly declared as "
"such."
msgstr ""
"在這個例子中，`Cat` 被視為 `Soundmaker` 的子類型，因為它有一個匹配的 "
"`makeSound` 方法，即使它並沒有被明確聲明為這樣。"

#: src/guide/trait-and-interface.md:44
msgid "Design Inspiration"
msgstr "設計靈感"

#: src/guide/trait-and-interface.md:46
msgid ""
"This dual approach to abstract types is inspired by the Pony programming "
"language, as described in:"
msgstr "這種對抽象類型的雙重方法受到 Pony 程式語言的啟發，如以下文獻所述："

#: src/guide/trait-and-interface.md:48
msgid ""
"Steed, G., & Drossopoulou, S. (2016). A principled design of capabilities in "
"Pony. URL: https://www.ponylang.io/media/papers/"
"a_prinicipled_design_of_capabilities_in_pony.pdf"
msgstr ""

#: src/guide/trait-and-interface.md:50
msgid ""
"The Pony language uses a similar distinction between traits (which they call "
"\"interfaces\") for nominal subtyping and \"structural types\" for "
"structural subtyping."
msgstr ""

#: src/guide/trait-and-interface.md:52
msgid "Choosing Between Traits and Interfaces"
msgstr "在特質和介面之間選擇"

#: src/guide/trait-and-interface.md:54
msgid ""
"Use traits when you want to create a named hierarchy of types and control "
"which types can be subtypes."
msgstr ""
"當您想要創建命名的類型層次結構並控制哪些類型可以成為子類型時，請使用特質。"

#: src/guide/trait-and-interface.md:55
msgid ""
"Use interfaces when you want to define a contract that any type can "
"implicitly satisfy by implementing the required structure."
msgstr ""
"當您想要定義任何類型都可以通過實現所需結構而隱式滿足的契約時，請使用介面。"

#: src/guide/trait-and-interface.md:57
msgid ""
"This design gives Chester developers flexibility in how they structure their "
"code, allowing for both strict hierarchies and more flexible, duck-typed-"
"style programming where appropriate."
msgstr ""
"這種設計給予Chester開發者靈活性，使他們能夠根據需要同時使用嚴格的類型層次結構"
"和更靈活的鴨子類型風格編程。"

#~ msgid "Union Types Progress"
#~ msgstr "聯合類型進展"

#~ msgid "Platform-Specific Type System Implementation"
#~ msgstr "平台特定類型系統實現"

#~ msgid "\".chester\""
#~ msgstr "\".chester\""
