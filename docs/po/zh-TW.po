msgid ""
msgstr ""
"Project-Id-Version: The Chester Programming Language\n"
"POT-Creation-Date: 2025-05-15T16:13:17+12:00\n"
"PO-Revision-Date: 2025-05-01 20:10+1200\n"
"Last-Translator:  <email@address.com>\n"
"Language-Team: Language zh-TW\n"
"Language: zh-TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: src/SUMMARY.md:1
msgid "https://github.com/rust-lang-nursery/mdBook/issues/677"
msgstr "https://github.com/rust-lang-nursery/mdBook/issues/677"

#: src/SUMMARY.md:2 src/index.md:1
msgid "Chester"
msgstr "Chester"

#: src/SUMMARY.md:3 src/dev/index.md:1
msgid "Chester Development Documentation"
msgstr "Chester é–‹ç™¼æ–‡æª”"

#: src/SUMMARY.md:4 src/dev/TODO.md:1
msgid "TODO"
msgstr "å¾…è¾¦äº‹é …"

#: src/SUMMARY.md:5 src/dev/compiler-backend.md:1
msgid "Chester Compiler Backend Architecture"
msgstr "Chester ç·¨è­¯å™¨å¾Œç«¯æ¶æ§‹"

#: src/SUMMARY.md:6 src/dev/development.md:1
msgid "Development Memo"
msgstr "é–‹ç™¼å‚™å¿˜éŒ„"

#: src/SUMMARY.md:7 src/dev/devlog.md:1
msgid "Development Log"
msgstr "é–‹ç™¼æ—¥èªŒ"

#: src/SUMMARY.md:8 src/dev/effects-implementation-plan.md:1
msgid "Effect System Implementation Plan"
msgstr "æ•ˆæœç³»çµ±å¯¦ç¾è¨ˆåŠƒ"

#: src/SUMMARY.md:9 src/dev/effects-system.md:1
msgid "Effect System Design"
msgstr "æ•ˆæœç³»çµ±è¨­è¨ˆ"

#: src/SUMMARY.md:10 src/dev/elaboration-system.md:1
msgid "Chester Elaboration System"
msgstr ""

#: src/SUMMARY.md:11 src/dev/intellij-idea.md:1
msgid "Intellij Idea configurations"
msgstr ""

#: src/SUMMARY.md:12 src/dev/js2py.md:1
msgid "JavaScript to Python Conversion Process"
msgstr "JavaScript åˆ° Python çš„è½‰æ›éç¨‹"

#: src/SUMMARY.md:13 src/dev/reader.md:1
msgid "Chester Reader Architecture"
msgstr "Chester è®€å–å™¨æ¶æ§‹"

#: src/SUMMARY.md:14 src/dev/scalablytyped-bindings.md:1
msgid "ScalablyTyped Bindings Guide"
msgstr "ScalablyTyped ç¶å®šæŒ‡å—"

#: src/SUMMARY.md:15 src/dev/tyck-improvement-proposal.md:1
msgid "Comprehensive Type System Improvement Proposal"
msgstr "å…¨é¢çš„é¡å‹ç³»çµ±æ”¹é€²ææ¡ˆ"

#: src/SUMMARY.md:16 src/dev/type-checking-system.md:1
msgid "Type Checking System: Propagator Network and Design"
msgstr "é¡å‹æª¢æŸ¥ç³»çµ±ï¼šå‚³æ’­å™¨ç¶²çµ¡å’Œè¨­è¨ˆ"

#: src/SUMMARY.md:17 src/dev/typescript-backend.md:1
msgid "TypeScript Backend Implementation"
msgstr "TypeScript å¾Œç«¯å¯¦ç¾"

#: src/SUMMARY.md:18 src/dev/union_types_progress.md:1
#, fuzzy
msgid "Union Types Implementation"
msgstr "TypeScript å¾Œç«¯å¯¦ç¾"

#: src/SUMMARY.md:19 src/guide/index.md:1
msgid "Chester Guide"
msgstr "Chester æŒ‡å—"

#: src/SUMMARY.md:20 src/guide/Record.md:1
msgid "Record Syntax in Chester"
msgstr "Chester çš„è¨˜éŒ„èªæ³•"

#: src/SUMMARY.md:21 src/dev/compiler-backend.md:198 src/guide/statements.md:1
msgid "Statements"
msgstr "èªå¥"

#: src/SUMMARY.md:22 src/guide/syntax-grammar.md:1
msgid "Chester Syntax Grammar (BNF-like)"
msgstr "Chester èªæ³•æ–‡æ³• (é¡ BNF)"

#: src/SUMMARY.md:23 src/guide/trait-and-interface.md:1
msgid "Traits and Interfaces in Chester"
msgstr "Chester ä¸­çš„ç‰¹è³ªå’Œä»‹é¢"

#: src/index.md:3
msgid ""
"Welcome to the Chester Programming Language documentation! Chester is a "
"modern, expressive language designed to combine the best features of "
"functional and object-oriented programming paradigms."
msgstr ""
"æ­¡è¿ä¾†åˆ° Chester ç¨‹å¼èªè¨€æ–‡ä»¶ï¼Chester æ˜¯ä¸€ç¨®ç¾ä»£ã€è¡¨é”åŠ›å¼·çš„ç¨‹å¼èªè¨€ï¼Œæ—¨åœ¨çµ"
"åˆå‡½æ•¸å¼å’Œç‰©ä»¶å°å‘ç¨‹å¼è¨­è¨ˆçš„æœ€ä½³ç‰¹æ€§ã€‚"

#: src/index.md:5
msgid ""
"This programming language is under active development and not ready for use. "
"Many important features are not implemented yet, including some described in "
"this documentation."
msgstr ""
"æ­¤ç¨‹å¼èªè¨€æ­£åœ¨ç©æ¥µé–‹ç™¼ä¸­ï¼Œå°šæœªæº–å‚™å¥½ä¾›ä½¿ç”¨ã€‚è¨±å¤šé‡è¦åŠŸèƒ½å°šæœªå¯¦ç¾ï¼ŒåŒ…æ‹¬æœ¬æ–‡ä»¶"
"ä¸­æè¿°çš„ä¸€äº›åŠŸèƒ½ã€‚"

#: src/index.md:7
msgid "What is Chester?"
msgstr "Chester æ˜¯ä»€éº¼ï¼Ÿ"

#: src/index.md:9
msgid ""
"Chester is a statically-typed language that aims to provide a balance "
"between expressiveness and safety. It draws inspiration from languages like "
"Scala, Haskell, and Rust, while introducing its own unique features."
msgstr ""
"Chester æ˜¯ä¸€ç¨®éœæ…‹é¡å‹èªè¨€ï¼Œæ—¨åœ¨æä¾›è¡¨é”åŠ›å’Œå®‰å…¨æ€§çš„å¹³è¡¡ã€‚å®ƒå¾åƒ Scalaã€"
"Haskell å’Œ Rust çš„èªè¨€ä¸­æ±²å–éˆæ„Ÿï¼ŒåŒæ™‚å¼•å…¥äº†è‡ªå·±çš„ç¨ç‰¹åŠŸèƒ½ã€‚"

#: src/index.md:11
msgid "Some key characteristics of Chester include:"
msgstr "Chester çš„ä¸€äº›é—œéµç‰¹æ€§åŒ…æ‹¬ï¼š"

#: src/index.md:13
msgid "Strong type system with type inference"
msgstr "å¼·å¤§çš„é¡å‹ç³»çµ±å’Œé¡å‹æ¨æ–·"

#: src/index.md:14
msgid "Support for both functional and object-oriented programming styles"
msgstr "æ”¯æ´å‡½æ•¸å¼å’Œç‰©ä»¶å°å‘ç¨‹å¼è¨­è¨ˆé¢¨æ ¼"

#: src/index.md:15
msgid "Pattern matching and algebraic data types"
msgstr "æ¨¡å¼åŒ¹é…å’Œä»£æ•¸æ•¸æ“šé¡å‹"

#: src/index.md:16
msgid "Effect system for managing side effects"
msgstr "æ•ˆæœç³»çµ±ç”¨æ–¼ç®¡ç†å‰¯ä½œç”¨"

#: src/index.md:17
msgid "Unicode support, allowing for expressive identifiers"
msgstr "Unicode æ”¯æ´ï¼Œå…è¨±è¡¨é”æ€§è­˜åˆ¥ç¬¦"

#: src/index.md:19
msgid "A Glimpse of Chester"
msgstr "Chester çš„ä¸€ç¥"

#: src/index.md:21
msgid ""
"Let's take a look at a simple Chester program to get a feel for the language:"
msgstr "è®“æˆ‘å€‘çœ‹çœ‹ä¸€å€‹ç°¡å–®çš„ Chester ç¨‹å¼ä¾†æ„Ÿå—ä¸€ä¸‹é€™ç¨®èªè¨€ï¼š"

#: src/index.md:23
msgid ""
"```chester,playground,editable\n"
"module ğŸ˜¿ğŸ˜¿;\n"
"\n"
"def me: String = \"ã‚¤ãƒ³ã‚¿ãƒ¼ãƒãƒƒãƒˆãƒ»ã‚¨ãƒ³ã‚¸ã‚§ãƒ«\";\n"
"```"
msgstr ""
"```chester,playground,editable\n"
"module ğŸ˜¿ğŸ˜¿;\n"
"\n"
"def me: String = \"ã‚¤ãƒ³ã‚¿ãƒ¼ãƒãƒƒãƒˆãƒ»ã‚¨ãƒ³ã‚¸ã‚§ãƒ«\";\n"
"```"

#: src/dev/index.md:3
msgid ""
"This section contains technical documentation for Chester's implementation "
"details and development notes."
msgstr "æœ¬ç¯€åŒ…å« Chester å¯¦ç¾ç´°ç¯€å’Œé–‹ç™¼èªªæ˜çš„æŠ€è¡“æ–‡æª”ã€‚"

#: src/dev/index.md:5
msgid "These documents are made for both llm and human."
msgstr ""

#: src/dev/index.md:7
msgid "Documentation Structure"
msgstr "æ–‡æª”çµæ§‹"

#: src/dev/index.md:9
msgid ""
"We use [mdBook](https://rust-lang.github.io/mdBook/) for organizing and "
"presenting our documentation. The documentation is structured as follows:"
msgstr ""
"æˆ‘å€‘ä½¿ç”¨ [mdBook](https://rust-lang.github.io/mdBook/) ä¾†çµ„ç¹”å’Œå±•ç¤ºæˆ‘å€‘çš„æ–‡"
"æª”ã€‚æ–‡æª”çµæ§‹å¦‚ä¸‹ï¼š"

#: src/dev/index.md:11
msgid "Documentation Management"
msgstr "æ–‡æª”ç®¡ç†"

#: src/dev/index.md:13
msgid "The documentation structure is managed through several tools:"
msgstr "æ–‡æª”çµæ§‹é€šéä»¥ä¸‹å¹¾ç¨®å·¥å…·é€²è¡Œç®¡ç†ï¼š"

#: src/dev/index.md:15
msgid "**SUMMARY.md Generation**:"
msgstr "**SUMMARY.md ç”Ÿæˆ**ï¼š"

#: src/dev/index.md:16
msgid ""
"The `SUMMARY.md` file is automatically generated using the `dev.sh` script"
msgstr "`SUMMARY.md` æ–‡ä»¶æ˜¯ä½¿ç”¨ `dev.sh` è…³æœ¬è‡ªå‹•ç”Ÿæˆçš„"

#: src/dev/index.md:17
msgid "To update the summary: `cd docs && ./dev.sh summary`"
msgstr "æ›´æ–°æ‘˜è¦ï¼š`cd docs && ./dev.sh summary`"

#: src/dev/index.md:18
msgid "Do not edit `SUMMARY.md` directly as changes will be overwritten"
msgstr "è«‹å‹¿ç›´æ¥ç·¨è¼¯ `SUMMARY.md`ï¼Œå› ç‚ºè®Šæ›´å°‡è¢«è¦†è“‹"

#: src/dev/index.md:20
msgid "**Building Documentation**:"
msgstr "**æ§‹å»ºæ–‡æª”**ï¼š"

#: src/dev/index.md:21
msgid "Use mdBook to build and preview changes"
msgstr "ä½¿ç”¨ mdBook æ§‹å»ºå’Œé è¦½è®Šæ›´"

#: src/dev/index.md:22
msgid "The `dev.sh` script provides various documentation management commands"
msgstr "`dev.sh` è…³æœ¬æä¾›å„ç¨®æ–‡æª”ç®¡ç†å‘½ä»¤"

#: src/dev/index.md:24
msgid "Contributing"
msgstr "è²¢ç»"

#: src/dev/index.md:26
msgid "When adding new development documentation:"
msgstr "æ·»åŠ æ–°çš„é–‹ç™¼æ–‡æª”æ™‚ï¼š"

#: src/dev/index.md:28
msgid ""
"Create your markdown file in the appropriate subdirectory under `docs/src/"
"dev/`"
msgstr "åœ¨ `docs/src/dev/` ä¸‹çš„é©ç•¶å­ç›®éŒ„ä¸­å‰µå»ºæ‚¨çš„ markdown æ–‡ä»¶"

#: src/dev/index.md:29
msgid "Place development-related documentation in the `dev/` directory"
msgstr "å°‡é–‹ç™¼ç›¸é—œæ–‡æª”æ”¾åœ¨ `dev/` ç›®éŒ„ä¸­"

#: src/dev/index.md:30
msgid "Follow the existing documentation style and structure"
msgstr "éµå¾ªç¾æœ‰çš„æ–‡æª”é¢¨æ ¼å’Œçµæ§‹"

#: src/dev/index.md:31
msgid "Include code examples where appropriate"
msgstr "åœ¨é©ç•¶çš„åœ°æ–¹åŒ…å«ä»£ç¢¼ç¤ºä¾‹"

#: src/dev/index.md:32
msgid "Update this README.md if adding new major components"
msgstr "æ·»åŠ æ–°çš„ä¸»è¦çµ„ä»¶æ™‚æ›´æ–°æ­¤ README.md"

#: src/dev/index.md:33
msgid "Run `./dev.sh summary` to update the documentation structure"
msgstr "é‹è¡Œ `./dev.sh summary` ä¾†æ›´æ–°æ–‡æª”çµæ§‹"

#: src/dev/TODO.md:3
msgid "parse a.b."
msgstr "è§£æ a.b."

#: src/dev/TODO.md:5
msgid "`import a.b.{x,y};`"
msgstr "`import a.b.{x,y};`"

#: src/dev/TODO.md:7
msgid "prompt"
msgstr "æç¤ºè©"

#: src/dev/TODO.md:9
msgid ""
"create a concise prompt introducing the language so that large langiage "
"model can read and write chester"
msgstr ""
"å‰µå»ºä¸€å€‹ç°¡æ½”çš„æç¤ºè©ä»‹ç´¹è©²èªè¨€ï¼Œä½¿å¤§å‹èªè¨€æ¨¡å‹èƒ½å¤ é–±è®€å’Œç·¨å¯« Chester ä»£ç¢¼"

#: src/dev/TODO.md:11
msgid "abstract syntax"
msgstr "æŠ½è±¡èªæ³•"

#: src/dev/TODO.md:13
msgid "maybe create a trait and let graalvm's syntax tree variant implement it"
msgstr "å¯èƒ½éœ€è¦å‰µå»ºä¸€å€‹ç‰¹è³ªä¸¦è®“ GraalVM çš„èªæ³•æ¨¹è®Šé«”å¯¦ç¾å®ƒ"

#: src/dev/TODO.md:15
msgid "block type leak"
msgstr "å€å¡Šé¡å‹æ´©æ¼"

#: src/dev/TODO.md:17
msgid "`{let a = Int; let b: a = 1; b}`"
msgstr "`{let a = Int; let b: a = 1; b}` // å€å¡Šå…§éƒ¨é¡å‹è®Šé‡åœ¨å¤–éƒ¨ä»å¯è¦‹"

#: src/dev/compiler-backend.md:3 src/dev/effects-system.md:5 src/dev/js2py.md:3
#: src/dev/reader.md:5 src/dev/typescript-backend.md:3
msgid "Overview"
msgstr "æ¦‚è¿°"

#: src/dev/compiler-backend.md:5
msgid ""
"This document outlines the backend architecture of the Chester compiler "
"system. The backend is responsible for transforming Chester's internal "
"representation into executable code for various target platforms."
msgstr ""
"æœ¬æ–‡æª”æ¦‚è¿°äº† Chester ç·¨è­¯å™¨ç³»çµ±çš„å¾Œç«¯æ¶æ§‹ã€‚å¾Œç«¯è² è²¬å°‡ Chester çš„å…§éƒ¨è¡¨ç¤ºè½‰æ›"
"ç‚ºå„ç¨®ç›®æ¨™å¹³å°çš„å¯åŸ·è¡Œä»£ç¢¼ã€‚"

#: src/dev/compiler-backend.md:7
msgid "Backend Pipeline"
msgstr "å¾Œç«¯æµæ°´ç·š"

#: src/dev/compiler-backend.md:9
msgid ""
"The Chester compiler backend follows a multi-phase code generation pipeline:"
msgstr "Chester ç·¨è­¯å™¨å¾Œç«¯éµå¾ªå¤šéšæ®µä»£ç¢¼ç”Ÿæˆæµæ°´ç·šï¼š"

#: src/dev/compiler-backend.md:15
msgid "Backend Components"
msgstr "å¾Œç«¯çµ„ä»¶"

#: src/dev/compiler-backend.md:17
msgid "The backend is composed of several key components:"
msgstr "å¾Œç«¯ç”±å¹¾å€‹é—œéµçµ„ä»¶çµ„æˆï¼š"

#: src/dev/compiler-backend.md:19
msgid "Target-Specific AST Generation"
msgstr "ç›®æ¨™ç‰¹å®šçš„ AST ç”Ÿæˆ"

#: src/dev/compiler-backend.md:21
msgid "Each target platform has a specialized AST generation phase:"
msgstr "æ¯å€‹ç›®æ¨™å¹³å°éƒ½æœ‰ä¸€å€‹å°ˆé–€çš„ AST ç”Ÿæˆéšæ®µï¼š"

#: src/dev/compiler-backend.md:23
msgid ""
"**Target AST Construction**: Builds an AST specific to the target language"
msgstr "**ç›®æ¨™ AST æ§‹å»º**ï¼šæ§‹å»ºç‰¹å®šæ–¼ç›®æ¨™èªè¨€çš„ AST"

#: src/dev/compiler-backend.md:24
msgid "**Type Mapping**: Maps Chester types to target language types"
msgstr "**é¡å‹æ˜ å°„**ï¼šå°‡ Chester é¡å‹æ˜ å°„åˆ°ç›®æ¨™èªè¨€é¡å‹"

#: src/dev/compiler-backend.md:25
msgid ""
"**Effect Translation**: Converts Chester effects to target language "
"constructs"
msgstr "**æ•ˆæœè½‰æ›**ï¼šå°‡ Chester æ•ˆæœè½‰æ›ç‚ºç›®æ¨™èªè¨€çµæ§‹"

#: src/dev/compiler-backend.md:26
msgid "**Standard Library Binding**: Connects to platform-specific libraries"
msgstr "**æ¨™æº–åº«ç¶å®š**ï¼šé€£æ¥åˆ°å¹³å°ç‰¹å®šçš„åº«"

#: src/dev/compiler-backend.md:28
msgid "Optimization Engine"
msgstr "å„ªåŒ–å¼•æ“"

#: src/dev/compiler-backend.md:30
msgid "The backend applies target-specific optimizations:"
msgstr "å¾Œç«¯æ‡‰ç”¨ç›®æ¨™ç‰¹å®šçš„å„ªåŒ–ï¼š"

#: src/dev/compiler-backend.md:32
msgid "**Dead Code Elimination**: Removes unused code"
msgstr "**æ­»ç¢¼æ¶ˆé™¤**ï¼šç§»é™¤æœªä½¿ç”¨çš„ä»£ç¢¼"

#: src/dev/compiler-backend.md:33
msgid "**Constant Folding**: Evaluates constant expressions at compile time"
msgstr "**å¸¸é‡æŠ˜ç–Š**ï¼šåœ¨ç·¨è­¯æ™‚è¨ˆç®—å¸¸é‡è¡¨é”å¼"

#: src/dev/compiler-backend.md:34
msgid ""
"**Inlining**: Replaces function calls with function bodies where beneficial"
msgstr "**å…§è¯**ï¼šåœ¨æœ‰ç›Šçš„æƒ…æ³ä¸‹ç”¨å‡½æ•¸é«”æ›¿æ›å‡½æ•¸èª¿ç”¨"

#: src/dev/compiler-backend.md:35
msgid "**Specialization**: Creates specialized versions of generic functions"
msgstr "**ç‰¹åŒ–**ï¼šç‚ºæ³›å‹å‡½æ•¸å‰µå»ºç‰¹å®šç‰ˆæœ¬"

#: src/dev/compiler-backend.md:36
msgid "**Tail Call Optimization**: Optimizes tail-recursive calls"
msgstr "**å°¾èª¿ç”¨å„ªåŒ–**ï¼šå„ªåŒ–å°¾éæ­¸èª¿ç”¨"

#: src/dev/compiler-backend.md:38
msgid "Code Generation"
msgstr "ä»£ç¢¼ç”Ÿæˆ"

#: src/dev/compiler-backend.md:40
msgid "The final phase transforms the optimized target AST to executable code:"
msgstr "æœ€å¾Œéšæ®µå°‡å„ªåŒ–çš„ç›®æ¨™ AST è½‰æ›ç‚ºå¯åŸ·è¡Œä»£ç¢¼ï¼š"

#: src/dev/compiler-backend.md:42
msgid "**Pretty Printing**: Generates formatted source code"
msgstr "**ç¾åŒ–è¼¸å‡º**ï¼šç”Ÿæˆæ ¼å¼åŒ–çš„æºä»£ç¢¼"

#: src/dev/compiler-backend.md:43
msgid ""
"**Native Code Generation**: For targets that compile directly to machine code"
msgstr "**åŸç”Ÿä»£ç¢¼ç”Ÿæˆ**ï¼šç”¨æ–¼ç›´æ¥ç·¨è­¯åˆ°æ©Ÿå™¨ç¢¼çš„ç›®æ¨™"

#: src/dev/compiler-backend.md:44
msgid "**Bytecode Generation**: For VM-based targets like the JVM"
msgstr "**å­—ç¯€ç¢¼ç”Ÿæˆ**ï¼šç”¨æ–¼åŸºæ–¼è™›æ“¬æ©Ÿçš„ç›®æ¨™ï¼Œå¦‚ JVM"

#: src/dev/compiler-backend.md:45
msgid "**Source Maps**: Generates debugging information"
msgstr "**æºç¢¼æ˜ å°„**ï¼šç”Ÿæˆèª¿è©¦ä¿¡æ¯"

#: src/dev/compiler-backend.md:47
msgid "Supported Compiler Targets"
msgstr "æ”¯æŒçš„ç·¨è­¯å™¨ç›®æ¨™"

#: src/dev/compiler-backend.md:49
msgid ""
"Chester supports multiple compiler targets, each with its own backend "
"implementation:"
msgstr "Chester æ”¯æŒå¤šç¨®ç·¨è­¯å™¨ç›®æ¨™ï¼Œæ¯ç¨®ç›®æ¨™éƒ½æœ‰è‡ªå·±çš„å¾Œç«¯å¯¦ç¾ï¼š"

#: src/dev/compiler-backend.md:51 src/dev/compiler-backend.md:135
msgid "JavaScript/TypeScript"
msgstr "JavaScript/TypeScript"

#: src/dev/compiler-backend.md:53
msgid ""
"The JavaScript/TypeScript target (`compiler/shared/src/main/scala/chester/"
"targets/js/AST.scala`) enables running Chester programs in web browsers and "
"Node.js."
msgstr ""
"JavaScript/TypeScript ç›®æ¨™ï¼ˆ`compiler/shared/src/main/scala/chester/targets/"
"js/AST.scala`ï¼‰ä½¿ Chester ç¨‹åºèƒ½å¤ åœ¨ç¶²é ç€è¦½å™¨å’Œ Node.js ä¸­é‹è¡Œã€‚"

#: src/dev/compiler-backend.md:55 src/dev/compiler-backend.md:93
#: src/dev/type-checking-system.md:51
msgid "Architecture"
msgstr "æ¶æ§‹"

#: src/dev/compiler-backend.md:57
msgid "The JavaScript backend consists of:"
msgstr "JavaScript å¾Œç«¯åŒ…æ‹¬ï¼š"

#: src/dev/compiler-backend.md:59
msgid ""
"**AST Nodes**: Comprehensive representation of JavaScript/TypeScript "
"constructs"
msgstr "**AST ç¯€é»**ï¼šJavaScript/TypeScript çµæ§‹çš„å…¨é¢è¡¨ç¤º"

#: src/dev/compiler-backend.md:60
msgid "**Type Translator**: Maps Chester types to TypeScript type annotations"
msgstr "**é¡å‹è½‰æ›å™¨**ï¼šå°‡ Chester é¡å‹æ˜ å°„åˆ° TypeScript é¡å‹è¨»è§£"

#: src/dev/compiler-backend.md:61
msgid ""
"**Effect Handler**: Implements Chester's effect system using JavaScript "
"promises"
msgstr ""
"**æ•ˆæœè™•ç†å™¨**ï¼šä½¿ç”¨ JavaScript æ‰¿è«¾ï¼ˆpromisesï¼‰å¯¦ç¾ Chester çš„æ•ˆæœç³»çµ±"

#: src/dev/compiler-backend.md:62
msgid "**Module System**: Generates ES module exports and imports"
msgstr "**æ¨¡å¡Šç³»çµ±**ï¼šç”Ÿæˆ ES æ¨¡å¡Šå°å‡ºå’Œå°å…¥"

#: src/dev/compiler-backend.md:64 src/dev/compiler-backend.md:102
msgid "Key Features"
msgstr "é—œéµç‰¹æ€§"

#: src/dev/compiler-backend.md:66
msgid "Complete JavaScript language support"
msgstr "å®Œæ•´çš„ JavaScript èªè¨€æ”¯æ´"

#: src/dev/compiler-backend.md:67
msgid "TypeScript type annotations"
msgstr "TypeScript é¡å‹è¨»è§£"

#: src/dev/compiler-backend.md:68
msgid "ECMAScript module system"
msgstr "ECMAScript æ¨¡å¡Šç³»çµ±"

#: src/dev/compiler-backend.md:69
msgid "Web API integration"
msgstr "Web API é›†æˆ"

#: src/dev/compiler-backend.md:70
msgid "Sourcemap generation for debugging"
msgstr "ç”¨æ–¼èª¿è©¦çš„æºç¢¼æ˜ å°„ç”Ÿæˆ"

#: src/dev/compiler-backend.md:72
msgid "JS AST Structure"
msgstr "JS AST çµæ§‹"

#: src/dev/compiler-backend.md:74
msgid "The JavaScript AST is implemented as a set of case classes:"
msgstr "JavaScript AST æ˜¯ä»¥ä¸€çµ„ case class çš„å½¢å¼å¯¦ç¾çš„ï¼š"

#: src/dev/compiler-backend.md:87
msgid ""
"Each node includes a `toDoc` method for pretty printing and source "
"generation."
msgstr "æ¯å€‹ç¯€é»éƒ½åŒ…å«ä¸€å€‹ç”¨æ–¼ç¾åŒ–è¼¸å‡ºå’Œæºä»£ç¢¼ç”Ÿæˆçš„ `toDoc` æ–¹æ³•ã€‚"

#: src/dev/compiler-backend.md:89
msgid "JVM (Java/Scala)"
msgstr "JVM (Java/Scala)"

#: src/dev/compiler-backend.md:91
msgid ""
"The JVM target enables integration with the Java ecosystem and leverages the "
"JVM runtime."
msgstr "JVM ç›®æ¨™å¯¦ç¾äº†èˆ‡ Java ç”Ÿæ…‹ç³»çµ±çš„é›†æˆï¼Œä¸¦åˆ©ç”¨ JVM é‹è¡Œæ™‚ã€‚"

#: src/dev/compiler-backend.md:95
msgid "The JVM backend consists of:"
msgstr "JVM å¾Œç«¯åŒ…å«ï¼š"

#: src/dev/compiler-backend.md:97
msgid "**Bytecode Generation**: Direct generation of JVM bytecode"
msgstr "**å­—ç¯€ç¢¼ç”Ÿæˆ**ï¼šç›´æ¥ç”Ÿæˆ JVM å­—ç¯€ç¢¼"

#: src/dev/compiler-backend.md:98
msgid "**Class Builder**: Creates JVM class files"
msgstr "**é¡åˆ¥æ§‹å»ºå™¨**ï¼šå‰µå»º JVM é¡åˆ¥æ–‡ä»¶"

#: src/dev/compiler-backend.md:99
msgid "**Runtime Library**: Core runtime support for Chester on JVM"
msgstr "**é‹è¡Œæ™‚åº«**ï¼šJVM ä¸Š Chester çš„æ ¸å¿ƒé‹è¡Œæ™‚æ”¯æŒ"

#: src/dev/compiler-backend.md:100
msgid "**Java Interop**: Enables calling Java code from Chester"
msgstr "**Java äº’æ“ä½œ**ï¼šå¯¦ç¾å¾ Chester èª¿ç”¨ Java ä»£ç¢¼"

#: src/dev/compiler-backend.md:104
msgid "Java interoperability"
msgstr "Java äº’æ“ä½œæ€§"

#: src/dev/compiler-backend.md:105
msgid "Scala library integration"
msgstr "Scala åº«é›†æˆ"

#: src/dev/compiler-backend.md:106
msgid "JVM optimizations"
msgstr "JVM å„ªåŒ–"

#: src/dev/compiler-backend.md:107
msgid "Access to the Java standard library"
msgstr "è¨ªå• Java æ¨™æº–åº«"

#: src/dev/compiler-backend.md:108
msgid "Advanced JVM optimizations (inlining, specialization)"
msgstr "é«˜ç´š JVM å„ªåŒ–ï¼ˆå…§è¯ï¼Œç‰¹åŒ–ï¼‰"

#: src/dev/compiler-backend.md:110 src/dev/compiler-backend.md:135
msgid "Native (Planned)"
msgstr "åŸç”Ÿ (è¨ˆåŠƒä¸­)"

#: src/dev/compiler-backend.md:112
msgid "A native code target is planned for high-performance applications."
msgstr "ç‚ºé«˜æ€§èƒ½æ‡‰ç”¨ç¨‹åºè¨ˆåŠƒäº†åŸç”Ÿä»£ç¢¼ç›®æ¨™ã€‚"

#: src/dev/compiler-backend.md:114
msgid "Potential Architecture"
msgstr "æ½›åœ¨æ¶æ§‹"

#: src/dev/compiler-backend.md:116
msgid "The native backend will likely include:"
msgstr "åŸç”Ÿå¾Œç«¯å¯èƒ½åŒ…æ‹¬ï¼š"

#: src/dev/compiler-backend.md:118
msgid "**LLVM IR Generation**: Translation to LLVM intermediate representation"
msgstr "**LLVM IR ç”Ÿæˆ**ï¼šè½‰æ›ç‚º LLVM ä¸­é–“è¡¨ç¤º"

#: src/dev/compiler-backend.md:119
msgid "**Native Runtime**: Minimal runtime support library"
msgstr "**åŸç”Ÿé‹è¡Œæ™‚**ï¼šæœ€å°é‹è¡Œæ™‚æ”¯æŒåº«"

#: src/dev/compiler-backend.md:120
msgid "**ABI Compatibility**: Interoperability with C/C++ code"
msgstr "**ABI å…¼å®¹æ€§**ï¼šèˆ‡ C/C++ ä»£ç¢¼çš„äº’æ“ä½œæ€§"

#: src/dev/compiler-backend.md:121
msgid "**Platform Support**: Cross-compilation for different CPU architectures"
msgstr "**å¹³å°æ”¯æŒ**ï¼šç‚ºä¸åŒ CPU æ¶æ§‹çš„äº¤å‰ç·¨è­¯"

#: src/dev/compiler-backend.md:123
msgid "Planned Features"
msgstr "è¨ˆåŠƒåŠŸèƒ½"

#: src/dev/compiler-backend.md:125
msgid "LLVM-based code generation"
msgstr ""

#: src/dev/compiler-backend.md:126
msgid "Native performance"
msgstr ""

#: src/dev/compiler-backend.md:127
msgid "Low-level memory control"
msgstr ""

#: src/dev/compiler-backend.md:128
msgid "System programming capabilities"
msgstr ""

#: src/dev/compiler-backend.md:129
msgid "Cross-platform support"
msgstr ""

#: src/dev/compiler-backend.md:131
msgid "Type System Mapping"
msgstr ""

#: src/dev/compiler-backend.md:133
msgid ""
"Chester's rich type system needs careful mapping to target language types:"
msgstr ""

#: src/dev/compiler-backend.md:135 src/dev/typescript-backend.md:34
msgid "Chester Type"
msgstr "Chester é¡å‹"

#: src/dev/compiler-backend.md:135
msgid "JVM"
msgstr ""

#: src/dev/compiler-backend.md:137 src/dev/typescript-backend.md:36
msgid "Integer"
msgstr ""

#: src/dev/compiler-backend.md:137 src/dev/compiler-backend.md:138
#: src/dev/typescript-backend.md:36
msgid "number"
msgstr ""

#: src/dev/compiler-backend.md:137 src/dev/compiler-backend.md:138
msgid "scala.BigInt"
msgstr ""

#: src/dev/compiler-backend.md:137
msgid "int64_t"
msgstr ""

#: src/dev/compiler-backend.md:138
msgid "Natural"
msgstr ""

#: src/dev/compiler-backend.md:138
msgid "uint64_t"
msgstr ""

#: src/dev/compiler-backend.md:139 src/dev/typescript-backend.md:38
msgid "Boolean"
msgstr ""

#: src/dev/compiler-backend.md:139 src/dev/typescript-backend.md:38
msgid "boolean"
msgstr ""

#: src/dev/compiler-backend.md:139
msgid "scala.Boolean"
msgstr ""

#: src/dev/compiler-backend.md:139
msgid "bool"
msgstr ""

#: src/dev/compiler-backend.md:140 src/dev/typescript-backend.md:37
msgid "String"
msgstr ""

#: src/dev/compiler-backend.md:140 src/dev/typescript-backend.md:37
msgid "string"
msgstr ""

#: src/dev/compiler-backend.md:140
msgid "java.lang.String"
msgstr ""

#: src/dev/compiler-backend.md:140
msgid "std::string"
msgstr ""

#: src/dev/compiler-backend.md:141
msgid "Union Types (A"
msgstr ""

#: src/dev/compiler-backend.md:141
msgid "B)"
msgstr ""

#: src/dev/compiler-backend.md:141
msgid "A \\| B"
msgstr ""

#: src/dev/compiler-backend.md:141
msgid "Specialized classes"
msgstr ""

#: src/dev/compiler-backend.md:142 src/dev/typescript-backend.md:42
msgid "Record"
msgstr "è¨˜éŒ„"

#: src/dev/compiler-backend.md:142
msgid "interface/class"
msgstr ""

#: src/dev/compiler-backend.md:142
msgid "case class"
msgstr ""

#: src/dev/compiler-backend.md:142
msgid "struct"
msgstr ""

#: src/dev/compiler-backend.md:143
msgid "Functions"
msgstr ""

#: src/dev/compiler-backend.md:143
msgid "function"
msgstr ""

#: src/dev/compiler-backend.md:143
msgid "Function objects"
msgstr ""

#: src/dev/compiler-backend.md:143
msgid "Function pointers"
msgstr ""

#: src/dev/compiler-backend.md:145
msgid "Effects Handling"
msgstr ""

#: src/dev/compiler-backend.md:147
msgid ""
"Chester's effect system is implemented differently for each target language:"
msgstr ""

#: src/dev/compiler-backend.md:149
msgid "**JavaScript/TypeScript**: Using promises or custom effect handlers"
msgstr ""

#: src/dev/compiler-backend.md:150
msgid "**JVM**: Using exceptions and monadic structures"
msgstr ""

#: src/dev/compiler-backend.md:151
msgid "**Native**: Using error codes or custom effect handling"
msgstr ""

#: src/dev/compiler-backend.md:153
msgid "Implementation Example: JavaScript Backend"
msgstr ""

#: src/dev/compiler-backend.md:155
msgid "JavaScript/TypeScript AST Example"
msgstr ""

#: src/dev/compiler-backend.md:157
msgid "The JavaScript target provides a good example of target-specific AST:"
msgstr ""

#: src/dev/compiler-backend.md:160
msgid "// Example: Function declaration in JavaScript AST"
msgstr ""

#: src/dev/compiler-backend.md:162
msgid "\"greet\""
msgstr ""

#: src/dev/compiler-backend.md:163 src/dev/compiler-backend.md:170
msgid "\"name\""
msgstr ""

#: src/dev/compiler-backend.md:169
msgid "\"Hello, \""
msgstr ""

#: src/dev/compiler-backend.md:177
msgid "This represents the TypeScript function:"
msgstr ""

#: src/dev/compiler-backend.md:179
msgid ""
"```typescript\n"
"function greet(name: string): string {\n"
"  return \"Hello, \" + name;\n"
"}\n"
"```"
msgstr ""

#: src/dev/compiler-backend.md:185
msgid "JavaScript AST Node Categories"
msgstr ""

#: src/dev/compiler-backend.md:187
msgid "The JavaScript AST supports a wide range of node types:"
msgstr ""

#: src/dev/compiler-backend.md:189 src/guide/syntax-grammar.md:18
msgid "Expressions"
msgstr "è¡¨é”å¼"

#: src/dev/compiler-backend.md:191
msgid "**Literals**: Numbers, strings, booleans, null, BigInt, RegExp"
msgstr ""

#: src/dev/compiler-backend.md:192
msgid "**Identifiers**: Named references (typed and untyped)"
msgstr ""

#: src/dev/compiler-backend.md:193
msgid "**Operators**: Binary, logical, assignment, unary, update"
msgstr ""

#: src/dev/compiler-backend.md:194
msgid "**Function Expressions**: Regular functions and arrow functions"
msgstr ""

#: src/dev/compiler-backend.md:195
msgid "**Object and Array Expressions**: Object literals and array literals"
msgstr ""

#: src/dev/compiler-backend.md:196
msgid ""
"**Class Expressions**: Class definitions with inheritance and method "
"definitions"
msgstr ""

#: src/dev/compiler-backend.md:200
msgid "**Block Statements**: Groups of statements"
msgstr ""

#: src/dev/compiler-backend.md:201
msgid "**Expression Statements**: Expressions used as statements"
msgstr ""

#: src/dev/compiler-backend.md:202
msgid "**Control Flow Statements**: if/else, while, do-while, for, switch"
msgstr ""

#: src/dev/compiler-backend.md:203
msgid "**Declaration Statements**: let, const, var declarations"
msgstr ""

#: src/dev/compiler-backend.md:205
msgid "TypeScript Features"
msgstr ""

#: src/dev/compiler-backend.md:207
msgid "**Type Annotations**: For variables, parameters, return types"
msgstr ""

#: src/dev/compiler-backend.md:208
msgid "**Interface and Type Declarations**: For defining complex types"
msgstr ""

#: src/dev/compiler-backend.md:209
msgid "**Generics**: Type parameters for functions and classes"
msgstr ""

#: src/dev/compiler-backend.md:210
msgid "**Union and Intersection Types**: Type combinations"
msgstr ""

#: src/dev/compiler-backend.md:212
msgid "Build System Integration"
msgstr ""

#: src/dev/compiler-backend.md:214
msgid "The Chester compiler backend integrates with build systems through:"
msgstr ""

#: src/dev/compiler-backend.md:216
msgid "**SBT Plugin**: For JVM builds"
msgstr ""

#: src/dev/compiler-backend.md:217
msgid "**NPM Package**: For JavaScript/TypeScript integration"
msgstr ""

#: src/dev/compiler-backend.md:218
msgid "**CLI Interface**: For command-line usage"
msgstr ""

#: src/dev/compiler-backend.md:220
msgid "Future Directions"
msgstr ""

#: src/dev/compiler-backend.md:222
msgid "Planned improvements to the compiler backend include:"
msgstr ""

#: src/dev/compiler-backend.md:224
msgid "**WebAssembly Support**: Direct compilation to WebAssembly"
msgstr ""

#: src/dev/compiler-backend.md:225
msgid "**More Native Targets**: Support for various native platforms"
msgstr ""

#: src/dev/compiler-backend.md:226
msgid "**Interoperability Enhancements**: Better interop with target languages"
msgstr ""

#: src/dev/compiler-backend.md:227
msgid "**Performance Optimizations**: Target-specific optimizations"
msgstr ""

#: src/dev/compiler-backend.md:228
msgid "**Cross-Compilation**: Single-command compilation to multiple targets"
msgstr ""

#: src/dev/compiler-backend.md:229
msgid "**Advanced Optimizations**: Target-specific performance improvements"
msgstr ""

#: src/dev/compiler-backend.md:231 src/dev/union_types_progress.md:153
msgid "References"
msgstr "åƒè€ƒè³‡æ–™"

#: src/dev/compiler-backend.md:233
msgid ""
"JavaScript AST is inspired by the [ESTree Spec](https://github.com/estree/"
"estree)"
msgstr ""

#: src/dev/compiler-backend.md:234
msgid ""
"JVM codegen draws from [Scala 3 compiler techniques](https://github.com/"
"lampepfl/dotty)"
msgstr ""

#: src/dev/compiler-backend.md:235
msgid ""
"LLVM-based compilation follows the [LLVM Language Reference](https://"
"llvm.org/docs/LangRef.html)"
msgstr ""

#: src/dev/development.md:3
msgid ""
"NOTE THAT ALL CODE AND DOCUMENTS CAN AND WILL BE OUTDATED OR CONFLICTING. "
"ANALYSE INFORMATION AVAIABLE TO YOU CAREFULLY"
msgstr ""

#: src/dev/development.md:5
msgid "Documentation Guidelines"
msgstr ""

#: src/dev/development.md:7
msgid "**Avoid Meaningless Adjectives**"
msgstr ""

#: src/dev/development.md:8
msgid ""
"âŒ **NEVER USE** subjective qualifiers like: \"better\", \"improved\", "
"\"good\", \"great\", \"enhanced\", \"advanced\", \"beautiful\", "
"\"powerful\", \"robust\", \"excellent\", \"high-quality\""
msgstr ""

#: src/dev/development.md:9
msgid "âœ… **ALWAYS USE** factual, specific, measurable descriptions"
msgstr ""

#: src/dev/development.md:10
msgid "Describe concrete characteristics and behaviors"
msgstr ""

#: src/dev/development.md:11
msgid "Focus on correctness and functionality first"
msgstr ""

#: src/dev/development.md:13
msgid "**Focus on Facts**"
msgstr ""

#: src/dev/development.md:14
msgid "Document what something IS, not how \"good\" you think it is"
msgstr ""

#: src/dev/development.md:15
msgid "Identify concrete capabilities and limitations"
msgstr ""

#: src/dev/development.md:16
msgid ""
"Omit subjective assessments and emotional language (BUT EMPHASIZE ON WHAT "
"ALWAYS DID WRONG BY DEVELOPERS IS OK LIKE EMOJI EMPHASIZE AND UPPERCASE AND "
"**BOLD**)"
msgstr ""

#: src/dev/development.md:17
msgid "Avoid superlatives and value judgments"
msgstr ""

#: src/dev/development.md:19
msgid "**Eliminate Fluff Phrases**"
msgstr ""

#: src/dev/development.md:20
msgid "Remove sentences that don't add information"
msgstr ""

#: src/dev/development.md:21
msgid "Avoid concluding paragraphs that just say \"this is useful\""
msgstr ""

#: src/dev/development.md:22
msgid "Don't add generic statements about quality or value"
msgstr ""

#: src/dev/development.md:23
msgid ""
"Delete phrases like \"comprehensive framework\", \"elegant solution\", etc."
msgstr ""

#: src/dev/development.md:25
msgid "**Be Specific and Concrete**"
msgstr ""

#: src/dev/development.md:26
msgid ""
"Instead of \"improved performance\", describe the specific optimization "
"technique"
msgstr ""

#: src/dev/development.md:27
msgid ""
"Instead of \"enhanced error reporting\", specify exactly what information is "
"included in errors"
msgstr ""

#: src/dev/development.md:28
msgid "Replace \"powerful features\" with a specific list of capabilities"
msgstr ""

#: src/dev/development.md:30
msgid "Development Practices"
msgstr ""

#: src/dev/development.md:32
msgid "Planning Changes"
msgstr ""

#: src/dev/development.md:34
msgid "**Document Before Implementing**"
msgstr ""

#: src/dev/development.md:35
msgid ""
"Always document the steps you plan to take BEFORE making any code changes"
msgstr ""

#: src/dev/development.md:36
msgid "Break down complex changes into clearly defined smaller steps"
msgstr ""

#: src/dev/development.md:37
msgid "For each step, explain:"
msgstr ""

#: src/dev/development.md:38
msgid "What will be changed"
msgstr ""

#: src/dev/development.md:39
msgid "Why the change is needed"
msgstr ""

#: src/dev/development.md:40
msgid "How the change relates to the larger goal"
msgstr ""

#: src/dev/development.md:41
msgid "What tests will verify the change"
msgstr ""

#: src/dev/development.md:42
msgid "Review your plan for completeness before starting implementation"
msgstr ""

#: src/dev/development.md:43
msgid "Document any deviations from the plan that occur during implementation"
msgstr ""

#: src/dev/development.md:45
msgid "**Use Step-by-Step Implementation**"
msgstr ""

#: src/dev/development.md:46
msgid "After documenting your plan, implement one step at a time"
msgstr ""

#: src/dev/development.md:47
msgid "Run the full test suite (`sbt rootJVM/test`) after each step"
msgstr ""

#: src/dev/development.md:48
msgid "Commit logical units of work with clear messages"
msgstr ""

#: src/dev/development.md:49
msgid "Do not proceed to the next step until the current step passes all tests"
msgstr ""

#: src/dev/development.md:51
msgid "Making Changes"
msgstr ""

#: src/dev/development.md:53
msgid "**Keep Changes Small and Focused**"
msgstr ""

#: src/dev/development.md:54
msgid "Make one logical change at a time"
msgstr ""

#: src/dev/development.md:55
msgid "Break down large changes into smaller, independent steps"
msgstr ""

#: src/dev/development.md:56
msgid "Each change should be easily reviewable and testable"
msgstr ""

#: src/dev/development.md:58
msgid "**Testing Requirements**"
msgstr ""

#: src/dev/development.md:59
msgid "**ALWAYS use the following commands for running tests:**"
msgstr ""

#: src/dev/development.md:61
msgid "# Run all tests from the root project\n"
msgstr ""

#: src/dev/development.md:64
msgid "# Run a specific test class from the root project\n"
msgstr ""

#: src/dev/development.md:65 src/dev/development.md:288
#: src/dev/tyck-improvement-proposal.md:203
msgid "\"rootJVM/testOnly chester.tyck.FilesTyckTest\""
msgstr ""

#: src/dev/development.md:67
msgid "# You can also run tests for specific modules when needed\n"
msgstr ""

#: src/dev/development.md:72
msgid "# Run specific test classes in modules\n"
msgstr ""

#: src/dev/development.md:73
msgid "\"reader/testOnly chester.reader.ReaderTest\""
msgstr ""

#: src/dev/development.md:74 src/dev/development.md:113
msgid "\"semantic/testOnly chester.tyck.TheTyckTest\""
msgstr ""

#: src/dev/development.md:75
msgid "\"cli/testOnly chester.cli.CLITest\""
msgstr ""

#: src/dev/development.md:77
msgid ""
"**DO NOT** navigate into subdirectories to run tests (e.g., `cd reader && "
"sbt test`)"
msgstr ""

#: src/dev/development.md:78
msgid "**ALWAYS** run tests from the root project directory"
msgstr ""

#: src/dev/development.md:79 src/dev/development.md:291
msgid "âš ï¸ **CRITICAL: NEVER use the `-z` test filter option** âš ï¸"
msgstr "âš ï¸ **é—œéµï¼šåˆ‡å‹¿ä½¿ç”¨ `-z` æ¸¬è©¦éæ¿¾é¸é …** âš ï¸"

#: src/dev/development.md:80
msgid "`-z` is NOT the correct syntax for filtering tests in MUnit"
msgstr "`-z` ä¸æ˜¯ MUnit ä¸­éæ¿¾æ¸¬è©¦çš„æ­£ç¢ºèªæ³•"

#: src/dev/development.md:81
msgid "This option is broken and produces unreliable results"
msgstr "æ­¤é¸é …å·²æå£ä¸¦ç”¢ç”Ÿä¸å¯é çš„çµæœ"

#: src/dev/development.md:82
msgid "Tests may appear to pass when they actually fail"
msgstr "æ¸¬è©¦å¯èƒ½çœ‹èµ·ä¾†é€šéï¼Œä½†å¯¦éš›ä¸Šå¤±æ•—äº†"

#: src/dev/development.md:83
msgid "This can lead to false confidence in your changes"
msgstr "é€™å¯èƒ½å°è‡´å°æ‚¨çš„æ›´æ”¹ç”¢ç”ŸéŒ¯èª¤çš„ä¿¡å¿ƒ"

#: src/dev/development.md:84
msgid "ScalaTest uses `-z` for filtering, but MUnit uses `--tests=` instead"
msgstr "ScalaTest ä½¿ç”¨ `-z` é€²è¡Œéæ¿¾ï¼Œä½† MUnit ä½¿ç”¨ `--tests=` ä»£æ›¿"

#: src/dev/development.md:85
msgid "âš ï¸ **IMPORTANT: Only use correct MUnit filter syntax with `--`** âš ï¸"
msgstr "âš ï¸ **é‡è¦ï¼šåƒ…ä½¿ç”¨å¸¶æœ‰ `--` çš„æ­£ç¢º MUnit éæ¿¾èªæ³•** âš ï¸"

#: src/dev/development.md:86
msgid "When filtering tests, always use proper MUnit syntax:"
msgstr "éæ¿¾æ¸¬è©¦æ™‚ï¼Œå§‹çµ‚ä½¿ç”¨æ­£ç¢ºçš„ MUnit èªæ³•ï¼š"

#: src/dev/development.md:87
msgid "**CORRECT MUnit syntax examples:**"
msgstr "**æ­£ç¢ºçš„ MUnit èªæ³•ç¤ºä¾‹ï¼š**"

#: src/dev/development.md:89
msgid "# Filter by test name\n"
msgstr "# æŒ‰æ¸¬è©¦åç¨±éæ¿¾\n"

#: src/dev/development.md:90
msgid "\"rootJVM/testOnly -- --tests=myTestName\""
msgstr ""

#: src/dev/development.md:92
msgid "# Filter by glob pattern\n"
msgstr "# æŒ‰å…¨å±€æ¨¡å¼éæ¿¾\n"

#: src/dev/development.md:93
msgid "\"rootJVM/testOnly -- *MyTest\""
msgstr ""

#: src/dev/development.md:95
msgid "**INCORRECT syntax from other frameworks (DO NOT USE):**"
msgstr "**ä¾†è‡ªå…¶ä»–æ¡†æ¶çš„éŒ¯èª¤èªæ³•ï¼ˆä¸è¦ä½¿ç”¨ï¼‰ï¼š**"

#: src/dev/development.md:97
msgid "# ScalaTest style (WRONG with MUnit)\n"
msgstr "# ScalaTest é¢¨æ ¼ï¼ˆèˆ‡ MUnit ä¸€èµ·ä½¿ç”¨æ˜¯éŒ¯èª¤çš„ï¼‰\n"

#: src/dev/development.md:98
msgid "\"rootJVM/testOnly -- -t MyTest\""
msgstr ""

#: src/dev/development.md:100
msgid "# JUnit style (WRONG with MUnit)\n"
msgstr "# JUnit é¢¨æ ¼ï¼ˆèˆ‡ MUnit ä¸€èµ·ä½¿ç”¨æ˜¯éŒ¯èª¤çš„ï¼‰\n"

#: src/dev/development.md:101
msgid "\"rootJVM/testOnly -- -n MyTest\""
msgstr ""

#: src/dev/development.md:103
msgid "# Custom incorrect style\n"
msgstr "# è‡ªå®šç¾©éŒ¯èª¤é¢¨æ ¼\n"

#: src/dev/development.md:104
msgid "\"rootJVM/testOnly -- -only file.chester\""
msgstr ""

#: src/dev/development.md:106
msgid "ALWAYS run `sbt rootJVM/test` before committing changes"
msgstr "æäº¤æ›´æ”¹å‰å§‹çµ‚é‹è¡Œ `sbt rootJVM/test`"

#: src/dev/development.md:107
msgid "Fix any test failures before committing"
msgstr "æäº¤å‰ä¿®å¾©æ‰€æœ‰æ¸¬è©¦å¤±æ•—"

#: src/dev/development.md:108
msgid "Add new tests for new functionality"
msgstr "ç‚ºæ–°åŠŸèƒ½æ·»åŠ æ–°æ¸¬è©¦"

#: src/dev/development.md:109
msgid "Update existing tests when modifying behavior"
msgstr "ä¿®æ”¹è¡Œç‚ºæ™‚æ›´æ–°ç¾æœ‰æ¸¬è©¦"

#: src/dev/development.md:110 src/dev/elaboration-system.md:232
msgid "Test both success and failure cases"
msgstr "æ¸¬è©¦æˆåŠŸå’Œå¤±æ•—çš„æƒ…æ³"

#: src/dev/development.md:111
msgid ""
"**ğŸ’¡ Development Tip:** For quickly adding and testing new type checking "
"scenarios during development, you can add code snippets to the `tests/"
"tyck.chester` file. To run _only_ these snippets for rapid feedback, use the "
"specific test class `chester.tyck.TheTyckTest`. **The correct command for "
"this specific development workflow is:**"
msgstr ""

#: src/dev/development.md:115
msgid ""
"This command targets the test directly within its module (`semantic`), "
"providing a faster feedback loop than running the full suite via `rootJVM/"
"test`. Note that `TheTyckTest` is designed for this temporary testing and is "
"often disabled (`doTest = false`) otherwise. Remember to use `sbt rootJVM/"
"test | cat` for final verification before committing."
msgstr ""

#: src/dev/development.md:116
msgid ""
"**ğŸ“ Post-Development Workflow:** Once the code in `tests/tyck.chester` "
"passes type checking with `TheTyckTest`:"
msgstr ""

#: src/dev/development.md:117
msgid "Move the `tests/tyck.chester` file to the main `tests/tyck/` directory."
msgstr ""

#: src/dev/development.md:118
msgid ""
"Give the file a descriptive name reflecting the feature tested (e.g., `union-"
"assignment.chester`)."
msgstr ""

#: src/dev/development.md:119
msgid ""
"Set the `doTest` flag in `semantic/jvm-native/src/test/scala/chester/tyck/"
"TheTyckTest.scala` to `false` to disable this specific test run until needed "
"again. (Note: Test suites like `FilesTyckTest` automatically discover files "
"in the `tests/tyck/` directory, so no explicit addition is needed)."
msgstr ""

#: src/dev/development.md:121
msgid "For parser changes:"
msgstr ""

#: src/dev/development.md:122
msgid "Many tests now run against both old and new readers (V1 and V2)"
msgstr ""

#: src/dev/development.md:123
msgid "Some complex tests currently only run against V1 (original reader)"
msgstr ""

#: src/dev/development.md:124
msgid "When adding new parser tests:"
msgstr ""

#: src/dev/development.md:125
msgid "Use `parseAndCheckBoth` by default for new tests"
msgstr ""

#: src/dev/development.md:126
msgid "Only use `parseAndCheck` if testing V1-specific features"
msgstr ""

#: src/dev/development.md:127
msgid "Document if test is V1-only and why"
msgstr ""

#: src/dev/development.md:128
msgid "Plan to migrate V1-only tests to V2 when ready"
msgstr ""

#: src/dev/development.md:129
msgid "Test function usage:"
msgstr ""

#: src/dev/development.md:130
msgid "`parseAndCheck`: V1 parser only"
msgstr ""

#: src/dev/development.md:131
msgid "`parseAndCheckBoth`: Both V1 and V2 parsers"
msgstr ""

#: src/dev/development.md:132
msgid "`parseAndCheckV1`: Deprecated alias for parseAndCheckBoth"
msgstr ""

#: src/dev/development.md:133
msgid "Recently migrated tests:"
msgstr ""

#: src/dev/development.md:134
msgid "Basic operator sequence tests"
msgstr ""

#: src/dev/development.md:135
msgid "Pattern matching tests with uniform symbol treatment"
msgstr ""

#: src/dev/development.md:136
msgid "Simple expression tests"
msgstr ""

#: src/dev/development.md:137
msgid "Function call tests"
msgstr ""

#: src/dev/development.md:138
msgid "Dot notation tests"
msgstr ""

#: src/dev/development.md:139
msgid "Object tests"
msgstr ""

#: src/dev/development.md:140
msgid "Tuple tests"
msgstr ""

#: src/dev/development.md:141
msgid "Vararg tests"
msgstr ""

#: src/dev/development.md:142
msgid "Floating-point number parsing tests"
msgstr ""

#: src/dev/development.md:143
msgid "List tests with mixed types"
msgstr ""

#: src/dev/development.md:144
msgid "Tests still needing migration:"
msgstr ""

#: src/dev/development.md:145
msgid "Complex operator sequences (prefix, mixfix)"
msgstr ""

#: src/dev/development.md:146
msgid "Telescope parsing"
msgstr ""

#: src/dev/development.md:147
msgid "Error handling"
msgstr ""

#: src/dev/development.md:148
msgid "Source position tracking"
msgstr ""

#: src/dev/development.md:149
msgid "For type checking changes:"
msgstr ""

#: src/dev/development.md:150
msgid "Test term preservation in elaborated results"
msgstr ""

#: src/dev/development.md:151
msgid "Test type-level computation works correctly"
msgstr ""

#: src/dev/development.md:152
msgid "Test error reporting is accurate"
msgstr ""

#: src/dev/development.md:153
msgid "Test edge cases and corner cases"
msgstr ""

#: src/dev/development.md:155
msgid "**Verify Changes with Git**"
msgstr ""

#: src/dev/development.md:157
msgid ""
"# After each change - ALWAYS use | cat to prevent terminal control issues:\n"
msgstr ""

#: src/dev/development.md:158
msgid "# Review what changed \n"
msgstr ""

#: src/dev/development.md:160
msgid "# Verify staged changes \n"
msgstr ""

#: src/dev/development.md:161
msgid "\"...\"     # Commit with clear message\n"
msgstr ""

#: src/dev/development.md:164
msgid ""
"âš ï¸ **Always append `| cat` to git diff commands to avoid paging issues.**"
msgstr ""

#: src/dev/development.md:166
msgid "**Change Verification Checklist**"
msgstr "**è®Šæ›´é©—è­‰æª¢æŸ¥æ¸…å–®**"

#: src/dev/development.md:167
msgid "Changes are minimal and focused"
msgstr ""

#: src/dev/development.md:168
msgid "Git diff shows only intended changes"
msgstr ""

#: src/dev/development.md:169
msgid "Tests pass after changes"
msgstr ""

#: src/dev/development.md:170
msgid "Changes align with existing code style"
msgstr ""

#: src/dev/development.md:171
msgid "Review the git diff output carefully"
msgstr ""

#: src/dev/development.md:173
msgid "# Before committing, ALWAYS verify changes with:\n"
msgstr ""

#: src/dev/development.md:177
msgid ""
"ğŸ’¡ **WHY THIS MATTERS**: Failure to review diffs properly is the #1 cause of "
"accidental code deletions and introduction of subtle bugs."
msgstr ""

#: src/dev/development.md:178
msgid "Reviewing git diff output is essential for catching:"
msgstr ""

#: src/dev/development.md:179
msgid "Accidental deletions of important methods or logic"
msgstr ""

#: src/dev/development.md:180
msgid "Unintended modification of critical code"
msgstr ""

#: src/dev/development.md:181
msgid "Formatting changes that might impact behavior"
msgstr ""

#: src/dev/development.md:182
msgid "Changes to files you didn't intend to modify"
msgstr ""

#: src/dev/development.md:183
msgid "Pay special attention to large diffs that might hide important changes"
msgstr ""

#: src/dev/development.md:184
msgid "Verify no unrelated changes were included"
msgstr ""

#: src/dev/development.md:185
msgid ""
"When making multiple changes, review each file's diff separately for clarity"
msgstr ""

#: src/dev/development.md:187
msgid "**Post-Commit Verification**"
msgstr ""

#: src/dev/development.md:188
msgid ""
"**âš ï¸ MANDATORY**: Always verify your changes after committing with `git diff "
"HEAD^ HEAD | cat`"
msgstr ""

#: src/dev/development.md:189
msgid "Check the diff output carefully to ensure:"
msgstr ""

#: src/dev/development.md:190
msgid "No unintended changes were included"
msgstr ""

#: src/dev/development.md:191
msgid "All intended changes were properly committed"
msgstr ""

#: src/dev/development.md:192
msgid "File renames and deletions are correctly reflected"
msgstr ""

#: src/dev/development.md:193
msgid "No sensitive or debug code was accidentally committed"
msgstr ""

#: src/dev/development.md:194
msgid "No accidental deletions of important logic"
msgstr ""

#: src/dev/development.md:195
msgid "Verify the commit message accurately describes the changes"
msgstr ""

#: src/dev/development.md:196
msgid ""
"For complex changes involving multiple files, check each file's changes "
"individually"
msgstr ""

#: src/dev/development.md:198
msgid "**Git Command Tips**"
msgstr "**Git å‘½ä»¤æŠ€å·§**"

#: src/dev/development.md:199
msgid "Always use `| cat` with git commands that might trigger paging:"
msgstr "å§‹çµ‚åœ¨å¯èƒ½è§¸ç™¼åˆ†é çš„ git å‘½ä»¤ä¸­ä½¿ç”¨ `| cat`ï¼š"

#: src/dev/development.md:205
msgid "This ensures consistent output and avoids interactive paging"
msgstr "é€™ç¢ºä¿äº†ä¸€è‡´çš„è¼¸å‡ºä¸¦é¿å…äº†äº’å‹•å¼åˆ†é "

#: src/dev/development.md:207
msgid "Terminal Control with Git Commands"
msgstr "ä½¿ç”¨ Git å‘½ä»¤çš„çµ‚ç«¯æ§åˆ¶"

#: src/dev/development.md:209
msgid "**âš ï¸ CRITICAL: ALWAYS Use `| cat` Suffix**"
msgstr "**âš ï¸ é—œéµ: å§‹çµ‚ä½¿ç”¨ `| cat` å¾Œç¶´**"

#: src/dev/development.md:210
msgid ""
"Git commands that might trigger paging or interactive prompts MUST ALWAYS "
"end with `| cat`"
msgstr "å¯èƒ½è§¸ç™¼åˆ†é æˆ–äº’å‹•æç¤ºçš„ Git å‘½ä»¤å¿…é ˆå§‹çµ‚ä»¥ `| cat` çµå°¾"

#: src/dev/development.md:211
msgid "This is a MANDATORY practice, not a suggestion"
msgstr "é€™æ˜¯å¼·åˆ¶æ€§çš„åšæ³•ï¼Œè€Œä¸æ˜¯å»ºè­°"

#: src/dev/development.md:212
msgid "This ensures consistent output and prevents terminal control issues"
msgstr "é€™å¯ç¢ºä¿è¼¸å‡ºä¸€è‡´ä¸¦é˜²æ­¢çµ‚ç«¯æ§åˆ¶å•é¡Œ"

#: src/dev/development.md:213
msgid ""
"Failure to use `| cat` is the leading cause of incomplete reviews and missed "
"errors"
msgstr "æœªä½¿ç”¨ `| cat` æ˜¯å°è‡´å¯©æŸ¥ä¸å®Œæ•´å’ŒéŒ¯ééŒ¯èª¤çš„ä¸»è¦åŸå› "

#: src/dev/development.md:214 src/dev/devlog.md:357
#: src/dev/effects-system.md:25
msgid "Examples:"
msgstr "ç¯„ä¾‹ï¼š"

#: src/dev/development.md:224
msgid "**Common Git Operations**"
msgstr "**å¸¸è¦‹ Git æ“ä½œ**"

#: src/dev/development.md:226
msgid "# Switching branches\n"
msgstr ""

#: src/dev/development.md:230
msgid "# Merging\n"
msgstr ""

#: src/dev/development.md:232
msgid "# If merge conflicts occur\n"
msgstr ""

#: src/dev/development.md:234
msgid "# Viewing changes\n"
msgstr ""

#: src/dev/development.md:239
msgid "# Committing\n"
msgstr ""

#: src/dev/development.md:241
msgid "\"type: description\""
msgstr ""

#: src/dev/development.md:244 src/dev/development.md:529
msgid "**Why This Matters**"
msgstr "**ç‚ºä»€éº¼é€™å¾ˆé‡è¦**"

#: src/dev/development.md:245
msgid "Prevents terminal from entering interactive mode"
msgstr "é˜²æ­¢çµ‚ç«¯é€²å…¥äº’å‹•æ¨¡å¼"

#: src/dev/development.md:246
msgid "Ensures consistent output formatting"
msgstr "ç¢ºä¿è¼¸å‡ºæ ¼å¼ä¸€è‡´"

#: src/dev/development.md:247
msgid "Avoids getting stuck in pagers like `less`"
msgstr "é¿å…å¡åœ¨åƒ `less` é€™æ¨£çš„åˆ†é å™¨ä¸­"

#: src/dev/development.md:248
msgid "Makes automation and scripting more reliable"
msgstr "ä½¿è‡ªå‹•åŒ–å’Œè…³æœ¬æ›´å¯é "

#: src/dev/development.md:250
msgid "Troubleshooting Development Issues"
msgstr "ç–‘é›£æ’è§£é–‹ç™¼å•é¡Œ"

#: src/dev/development.md:252
msgid "**Recovering from Broken Edit Tools**"
msgstr "**å¾æå£çš„ç·¨è¼¯å·¥å…·ä¸­æ¢å¾©**"

#: src/dev/development.md:253
msgid ""
"If edit tools in your IDE or development environment are broken/"
"malfunctioning, you can use git to recover:"
msgstr ""

#: src/dev/development.md:255
msgid "# Discard changes to a specific file\n"
msgstr ""

#: src/dev/development.md:258
msgid "# Discard all changes in the working directory\n"
msgstr ""

#: src/dev/development.md:261
msgid "# Revert to a specific commit\n"
msgstr ""

#: src/dev/development.md:264
msgid ""
"This approach is especially useful when tools that normally handle editing "
"break unexpectedly"
msgstr ""

#: src/dev/development.md:265
msgid ""
"Always verify what you're checking out before executing the command to avoid "
"losing important changes"
msgstr ""

#: src/dev/development.md:267
msgid "AI Agent Testing Instructions"
msgstr "AI ä»£ç†æ¸¬è©¦èªªæ˜"

#: src/dev/development.md:269
msgid "**Terminal Interruption Issues**"
msgstr "**çµ‚ç«¯ä¸­æ–·å•é¡Œ**"

#: src/dev/development.md:270
msgid "If you are an AI agent working on Chester code and notice:"
msgstr "å¦‚æœä½ æ˜¯ä¸€å€‹è™•ç† Chester ä»£ç¢¼çš„ AI ä»£ç†ä¸¦æ³¨æ„åˆ°ï¼š"

#: src/dev/development.md:271
msgid "Frequent `^C` characters appearing in command output"
msgstr "å‘½ä»¤è¼¸å‡ºä¸­é »ç¹å‡ºç¾ `^C` å­—ç¬¦"

#: src/dev/development.md:272
msgid "Commands being interrupted prematurely"
msgstr "å‘½ä»¤è¢«æå‰ä¸­æ–·"

#: src/dev/development.md:273
msgid "Test results not displaying properly"
msgstr "æ¸¬è©¦çµæœé¡¯ç¤ºä¸æ­£ç¢º"

#: src/dev/development.md:274
msgid "Terminal output being cut off"
msgstr "çµ‚ç«¯è¼¸å‡ºè¢«åˆ‡æ–·"

#: src/dev/development.md:275
msgid "STOP attempting to run tests and:"
msgstr "åœæ­¢å˜—è©¦é‹è¡Œæ¸¬è©¦ä¸¦ä¸”ï¼š"

#: src/dev/development.md:276
msgid "Inform the user about the terminal connection issues"
msgstr "å‘ŠçŸ¥ç”¨æˆ¶æœ‰é—œçµ‚ç«¯é€£æ¥å•é¡Œ"

#: src/dev/development.md:277
msgid "Ask the user to run the tests manually"
msgstr "è«‹ç”¨æˆ¶æ‰‹å‹•é‹è¡Œæ¸¬è©¦"

#: src/dev/development.md:278
msgid "Request that the user provide the test results"
msgstr "è«‹ç”¨æˆ¶æä¾›æ¸¬è©¦çµæœ"

#: src/dev/development.md:279
msgid ""
"This indicates a problem with the terminal connection, not with the code "
"itself"
msgstr "é€™è¡¨ç¤ºçµ‚ç«¯é€£æ¥å­˜åœ¨å•é¡Œï¼Œè€Œéä»£ç¢¼æœ¬èº«çš„å•é¡Œ"

#: src/dev/development.md:281
msgid "**Test Running Best Practices for AI Agents**"
msgstr "**AI ä»£ç†é‹è¡Œæ¸¬è©¦çš„æœ€ä½³å¯¦è¸**"

#: src/dev/development.md:282
msgid "**ALWAYS use these exact commands for running tests:**"
msgstr "**å§‹çµ‚ä½¿ç”¨é€™äº›ç¢ºåˆ‡çš„å‘½ä»¤ä¾†é‹è¡Œæ¸¬è©¦ï¼š**"

#: src/dev/development.md:284
msgid "# Run all tests\n"
msgstr ""

#: src/dev/development.md:287
msgid "# Run a specific test class (include quotation marks)\n"
msgstr ""

#: src/dev/development.md:290
msgid ""
"**NEVER** attempt to run tests with other project paths like `cli/test`, "
"`semantic/test`, etc."
msgstr ""
"**åˆ‡å‹¿**å˜—è©¦ä½¿ç”¨å…¶ä»–é …ç›®è·¯å¾‘ï¼ˆå¦‚ `cli/test`ã€`semantic/test` ç­‰ï¼‰ä¾†é‹è¡Œæ¸¬è©¦ã€‚"

#: src/dev/development.md:292
msgid ""
"Example of what NOT to do: `sbt \"rootJVM/testOnly "
"chester.tyck.FilesTyckTest -z myTest\"`"
msgstr ""

#: src/dev/development.md:293
msgid "The `-z` flag is completely broken and will cause misleading results"
msgstr ""

#: src/dev/development.md:294
msgid "Tests might appear to pass when they should fail"
msgstr ""

#: src/dev/development.md:295
msgid "Using `-z` will lead to incorrect conclusions about code behavior"
msgstr ""

#: src/dev/development.md:296
msgid "âš ï¸ **CRITICAL: NEVER use `--` to pass arguments to tests** âš ï¸"
msgstr ""

#: src/dev/development.md:297
msgid "Example of what NOT to do: `sbt \"rootJVM/testOnly -- -t MyTest\"`"
msgstr ""

#: src/dev/development.md:298
msgid "This will cause tests to run incorrectly or not at all"
msgstr ""

#: src/dev/development.md:299
msgid "No arguments should be passed after the test class name"
msgstr ""

#: src/dev/development.md:300
msgid "Always run full test suites rather than individual tests when possible"
msgstr ""

#: src/dev/development.md:301
msgid "Verify that terminal commands execute completely before proceeding"
msgstr ""

#: src/dev/development.md:302
msgid "If a test command produces an error about not finding the test class:"
msgstr ""

#: src/dev/development.md:303
msgid "First try the full `rootJVM/test` command to run all tests"
msgstr ""

#: src/dev/development.md:304
msgid "Then check if the test class path is correct"
msgstr ""

#: src/dev/development.md:305
msgid "Do not experiment with different project paths"
msgstr ""

#: src/dev/development.md:306
msgid ""
"If tests are taking too long to complete, inform the user and suggest they "
"run the tests locally"
msgstr ""

#: src/dev/development.md:308
#, fuzzy
msgid "Term System Architecture"
msgstr "Chester è®€å–å™¨æ¶æ§‹"

#: src/dev/development.md:310
msgid ""
"Chester uses a unified term representation architecture to support multiple "
"platforms:"
msgstr ""

#: src/dev/development.md:312
#, fuzzy
msgid "Term Definition Structure"
msgstr "æ–‡æª”çµæ§‹"

#: src/dev/development.md:314
msgid "**Unified Term Definition**"
msgstr ""

#: src/dev/development.md:315
msgid ""
"All term types are defined in a single file: `syntax/shared/src/main/scala/"
"chester/syntax/core/Term.scala`"
msgstr ""

#: src/dev/development.md:316
msgid ""
"This approach simplifies the codebase and eliminates the need for separate "
"platform-specific implementations"
msgstr ""

#: src/dev/development.md:317
msgid ""
"Each term type follows a consistent pattern with standard methods and field "
"annotations"
msgstr ""

#: src/dev/development.md:319
msgid "Import Guidelines"
msgstr ""

#: src/dev/development.md:321
msgid "**DO** use `import chester.syntax.core.*`"
msgstr ""

#: src/dev/development.md:322
msgid "This will give you access to all term implementations"
msgstr ""

#: src/dev/development.md:325 src/dev/development.md:338
msgid "// CORRECT"
msgstr ""

#: src/dev/development.md:327
msgid "// INCORRECT - unnecessarily specific imports"
msgstr ""

#: src/dev/development.md:333
msgid "Pattern Matching and Type Usage"
msgstr "æ¨¡å¼åŒ¹é…å’Œé¡å‹ä½¿ç”¨"

#: src/dev/development.md:335
msgid "Use concrete term types directly for pattern matching:"
msgstr ""

#: src/dev/development.md:346
#, fuzzy
msgid "Term Type Implementation Pattern"
msgstr "æ•ˆæœç³»çµ±å¯¦ç¾è¨ˆåŠƒ"

#: src/dev/development.md:348
msgid "All term types follow a consistent implementation pattern:"
msgstr ""

#: src/dev/development.md:352
msgid "// Use @child for term fields that should be traversed"
msgstr ""

#: src/dev/development.md:353
msgid "// Use @const for non-term fields "
msgstr ""

#: src/dev/development.md:358
msgid "// Pretty printing method"
msgstr ""

#: src/dev/development.md:360
#, fuzzy
msgid "\"ExampleTerm(\""
msgstr "ç¯„ä¾‹"

#: src/dev/development.md:360 src/dev/development.md:389
msgid "\")\""
msgstr ""

#: src/dev/development.md:362
msgid "// Tree traversal method"
msgstr ""

#: src/dev/development.md:368
msgid "Adding New Term Types"
msgstr ""

#: src/dev/development.md:370
#, fuzzy
msgid "When adding a new term type:"
msgstr "æ·»åŠ æ–°çš„é–‹ç™¼æ–‡æª”æ™‚ï¼š"

#: src/dev/development.md:372
msgid "Add it directly to `Term.scala`"
msgstr ""

#: src/dev/development.md:373
#, fuzzy
msgid "Follow the existing pattern for similar term types"
msgstr "éµå¾ªç¾æœ‰çš„æ–‡æª”é¢¨æ ¼å’Œçµæ§‹"

#: src/dev/development.md:374
msgid "Implement all required methods (`toDoc`, `descent`, etc.)"
msgstr ""

#: src/dev/development.md:375
msgid "Use correct field annotations (`@child`, `@const`)"
msgstr ""

#: src/dev/development.md:376
msgid "Extend the appropriate base type (e.g., `TypeTerm`, `ExprTerm`)"
msgstr ""

#: src/dev/development.md:378
msgid "Example: Adding a New Term Type"
msgstr ""

#: src/dev/development.md:380
msgid "For example, to add a new term type for union types:"
msgstr ""

#: src/dev/development.md:389
msgid "\"UnionType(\""
msgstr ""

#: src/dev/development.md:389
msgid "\", \""
msgstr ""

#: src/dev/development.md:395
#, fuzzy
msgid "Key Term Types"
msgstr "Chester é¡å‹"

#: src/dev/development.md:397
msgid "The system includes several important term categories:"
msgstr ""

#: src/dev/development.md:399
msgid ""
"**Expression Terms**: Represent runtime values (variables, function calls, "
"literals)"
msgstr ""

#: src/dev/development.md:400
msgid ""
"**Type Terms**: Represent type information (primitive types, function types, "
"union types)"
msgstr ""

#: src/dev/development.md:401
msgid ""
"**Statement Terms**: Represent declarations and control flow (let/def "
"bindings, trait definitions)"
msgstr ""

#: src/dev/development.md:402
msgid "**Pattern Terms**: Represent pattern matching constructs"
msgstr ""

#: src/dev/development.md:403
msgid ""
"**Special Terms**: Represent special language constructs (holes, "
"placeholders)"
msgstr ""

#: src/dev/development.md:405
msgid "Each category has a base trait that defines its common behavior."
msgstr ""

#: src/dev/development.md:407
msgid "Why This Matters"
msgstr ""

#: src/dev/development.md:409
msgid ""
"**Simplified Architecture**: The unified term definition makes the codebase "
"more maintainable"
msgstr ""

#: src/dev/development.md:410
msgid ""
"**Cross-Platform Compatibility**: All platforms use the same term "
"representation"
msgstr ""

#: src/dev/development.md:411
msgid ""
"**Consistent Patterns**: All term types follow the same implementation "
"pattern"
msgstr ""

#: src/dev/development.md:412
msgid ""
"**Easier Extensions**: Adding new term types follows a clear and consistent "
"approach"
msgstr ""

#: src/dev/development.md:414
msgid "Elaboration and Reduction Strategy"
msgstr ""

#: src/dev/development.md:416
msgid "Reduction During Type Checking"
msgstr ""

#: src/dev/development.md:418
msgid "**Keep Original Forms**"
msgstr ""

#: src/dev/development.md:419
msgid "The elaborator MUST preserve original terms in the elaborated result"
msgstr ""

#: src/dev/development.md:420
msgid "NEVER reduce during elaboration"
msgstr ""

#: src/dev/development.md:421 src/dev/elaboration-system.md:220
msgid ""
"Only use reduction internally during type checking when absolutely necessary"
msgstr ""

#: src/dev/development.md:422
msgid "This makes the elaborated code identical to source code, making it:"
msgstr ""

#: src/dev/development.md:423
msgid "Easier to debug"
msgstr ""

#: src/dev/development.md:424
msgid "Easier to understand"
msgstr ""

#: src/dev/development.md:425
msgid "Better for error messages"
msgstr ""

#: src/dev/development.md:426
msgid "More suitable for further transformations"
msgstr ""

#: src/dev/development.md:428
msgid "**When to Reduce**"
msgstr ""

#: src/dev/development.md:429
msgid "Only TWO places should use reduction:"
msgstr ""

#: src/dev/development.md:430
msgid "Type equality checking in unification"
msgstr ""

#: src/dev/development.md:431
msgid "Field access checking on type-level terms"
msgstr ""

#: src/dev/development.md:432 src/dev/tyck-improvement-proposal.md:177
msgid "Use `ReduceMode.TypeLevel` for these internal reductions"
msgstr ""

#: src/dev/development.md:433
msgid "NEVER use reduction in elaborated results"
msgstr ""

#: src/dev/development.md:435
msgid "Example:"
msgstr "ç¯„ä¾‹ï¼š"

#: src/dev/development.md:437
msgid "// Original code"
msgstr ""

#: src/dev/development.md:441
msgid "// WRONG - reducing during elaboration:"
msgstr ""

#: src/dev/development.md:444
msgid "// RIGHT - keeping original term:"
msgstr ""

#: src/dev/development.md:447
msgid "// RIGHT - internal reduction only for field checking:"
msgstr ""

#: src/dev/development.md:450
msgid "// Use type-level reduction only for checking field existence"
msgstr ""

#: src/dev/development.md:451
msgid "// Keep original term in result"
msgstr ""

#: src/dev/development.md:452 src/dev/devlog.md:755 src/dev/devlog.md:764
#: src/dev/devlog.md:921
msgid "// ..."
msgstr ""

#: src/dev/development.md:456
msgid "Reduction Context and Type Checking"
msgstr ""

#: src/dev/development.md:458
msgid "**Reduction Context Setup**"
msgstr ""

#: src/dev/development.md:459
msgid ""
"Each `Context` instance provides its own reduction context via "
"`toReduceContext`"
msgstr ""

#: src/dev/development.md:460
msgid "This ensures consistent reduction behavior during type checking"
msgstr ""

#: src/dev/development.md:461
msgid "Allows for future extensions to reduction context"
msgstr ""

#: src/dev/development.md:463
msgid "**Type-Level Reduction**"
msgstr ""

#: src/dev/development.md:464
msgid "Only reduce type-level terms when necessary for type checking"
msgstr ""

#: src/dev/development.md:465 src/dev/tyck-improvement-proposal.md:170
msgid "Keep original terms in elaborated results"
msgstr ""

#: src/dev/development.md:466
msgid "Use `ReduceMode.TypeLevel` to control reduction behavior"
msgstr ""

#: src/dev/development.md:468
msgid "**Field Access Checking**"
msgstr ""

#: src/dev/development.md:469
msgid "Use type-level reduction to verify field existence"
msgstr ""

#: src/dev/development.md:470
msgid "Keep original terms in field access expressions"
msgstr ""

#: src/dev/development.md:471
msgid "Report errors using original terms for better error messages"
msgstr ""

#: src/dev/development.md:473
msgid "Common Pitfalls"
msgstr ""

#: src/dev/development.md:475
msgid "**Over-reduction**"
msgstr ""

#: src/dev/development.md:476
msgid "Don't reduce terms during elaboration"
msgstr ""

#: src/dev/development.md:477
msgid "Don't reduce terms when adding to context"
msgstr ""

#: src/dev/development.md:478
msgid "Only reduce when needed for type checking"
msgstr ""

#: src/dev/development.md:480
msgid "**Loss of Original Terms**"
msgstr ""

#: src/dev/development.md:481
msgid "Always preserve original terms in elaborated results"
msgstr ""

#: src/dev/development.md:482
msgid "Don't reflect internal reductions in output"
msgstr ""

#: src/dev/development.md:483
msgid "Keep source code structure intact"
msgstr ""

#: src/dev/development.md:485
msgid "**Incorrect Reduction Context**"
msgstr ""

#: src/dev/development.md:486
msgid "Always use proper reduction context from current context"
msgstr ""

#: src/dev/development.md:487
msgid "Don't create new reduction contexts unnecessarily"
msgstr ""

#: src/dev/development.md:488
msgid "Use consistent reduction mode for type checking"
msgstr ""

#: src/dev/development.md:490
msgid "Coding Conventions"
msgstr ""

#: src/dev/development.md:492
msgid "Imports"
msgstr ""

#: src/dev/development.md:494
msgid ""
"**Document Utilities:** When using utilities from the `chester.utils.doc` "
"package (such as `Doc`, `PrettierOptions`, or extension methods like "
"`render`), prefer using a single wildcard import: `import "
"chester.utils.doc.*`."
msgstr ""

#: src/dev/development.md:496
msgid "String Formatting and Internationalization"
msgstr ""

#: src/dev/development.md:498
msgid "**Use Template Strings for User-Facing Text**"
msgstr ""

#: src/dev/development.md:499
msgid ""
"ALWAYS use template strings (`t\"\"`) for user-facing messages, not string "
"interpolation (`s\"\"`)"
msgstr ""

#: src/dev/development.md:500
msgid ""
"ALWAYS use template strings (`t\"\"`) for plain user-facing text, even "
"without variables"
msgstr ""

#: src/dev/development.md:501
msgid "Always import the internationalization package: `import chester.i18n.*`"
msgstr ""

#: src/dev/development.md:502
msgid "This ensures proper internationalization and localization support"
msgstr ""

#: src/dev/development.md:504
msgid "// CORRECT - using template strings for user-facing text"
msgstr ""

#: src/dev/development.md:507
msgid "\"Alice\""
msgstr ""

#: src/dev/development.md:508
msgid "t\"Hello $username, welcome to Chester!\""
msgstr ""

#: src/dev/development.md:510
msgid "// CORRECT - using template strings for plain text without variables"
msgstr ""

#: src/dev/development.md:511
msgid "t\"Operation failed. Please try again.\""
msgstr ""

#: src/dev/development.md:513
msgid "// INCORRECT - using string interpolation for user-facing text"
msgstr ""

#: src/dev/development.md:514
msgid "s\"Hello $username, welcome to Chester!\""
msgstr ""

#: src/dev/development.md:516
msgid "// INCORRECT - using regular string literals for user-facing text"
msgstr ""

#: src/dev/development.md:517
msgid "\"Operation failed. Please try again.\""
msgstr ""

#: src/dev/development.md:520
msgid "**String Interpolation for Internal Use Only**"
msgstr ""

#: src/dev/development.md:521
msgid ""
"Only use string interpolation (`s\"\"`) for internal, non-user-facing strings"
msgstr ""

#: src/dev/development.md:522
msgid ""
"Examples include debug logging, internal identifiers, and non-displayed text"
msgstr ""

#: src/dev/development.md:524
msgid "// CORRECT - using string interpolation for internal/technical content"
msgstr ""

#: src/dev/development.md:525
msgid "s\"DEBUG: Processing request from $username with params $params\""
msgstr ""

#: src/dev/development.md:526
msgid "s\"${"
msgstr ""

#: src/dev/development.md:526
msgid "}_${"
msgstr ""

#: src/dev/development.md:526
msgid "}\""
msgstr ""

#: src/dev/development.md:530
msgid "Template strings enable automatic translation and localization"
msgstr ""

#: src/dev/development.md:531
msgid "They maintain consistent messaging across the application"
msgstr ""

#: src/dev/development.md:532
msgid "They allow for future language additions without code changes"
msgstr ""

#: src/dev/development.md:533
msgid "They ensure a better experience for non-English users"
msgstr ""

#: src/dev/development.md:535
msgid "Core Principles"
msgstr ""

#: src/dev/development.md:537
msgid "**Use C-style Braces**"
msgstr ""

#: src/dev/development.md:538
msgid "Always use braces for control structures, even for single-line blocks"
msgstr ""

#: src/dev/development.md:539
msgid "Opening brace on the same line"
msgstr ""

#: src/dev/development.md:540
msgid "Closing brace on its own line"
msgstr ""

#: src/dev/development.md:542 src/dev/development.md:563
#: src/dev/development.md:584 src/dev/development.md:598
#: src/dev/development.md:619 src/dev/development.md:648
msgid "// Good"
msgstr ""

#: src/dev/development.md:549
msgid "// Bad - No braces"
msgstr ""

#: src/dev/development.md:553
msgid "// Bad - Indentation-based syntax"
msgstr ""

#: src/dev/development.md:556
msgid "// Unclear scope"
msgstr ""

#: src/dev/development.md:559
msgid "**No Indentation-Based Syntax**"
msgstr ""

#: src/dev/development.md:560
msgid "Do not rely on indentation for scope"
msgstr ""

#: src/dev/development.md:561
msgid "Always use explicit braces to define scope"
msgstr ""

#: src/dev/development.md:572
msgid "// Bad - Indentation-based"
msgstr ""

#: src/dev/development.md:580
msgid "**Function Definitions**"
msgstr ""

#: src/dev/development.md:581
msgid "Opening brace on the same line as the function definition"
msgstr ""

#: src/dev/development.md:582
msgid "Use explicit return types"
msgstr ""

#: src/dev/development.md:586 src/dev/development.md:591
msgid "// implementation"
msgstr ""

#: src/dev/development.md:589 src/dev/development.md:608
#: src/dev/development.md:627 src/dev/development.md:655
msgid "// Bad"
msgstr ""

#: src/dev/development.md:594
msgid "**Pattern Matching**"
msgstr ""

#: src/dev/development.md:595
msgid "Use braces for case blocks"
msgstr ""

#: src/dev/development.md:596
msgid "Align case statements"
msgstr ""

#: src/dev/development.md:616
msgid "**For Comprehensions**"
msgstr ""

#: src/dev/development.md:617
msgid "Use braces instead of indentation"
msgstr ""

#: src/dev/development.md:634
msgid "Additional Guidelines"
msgstr ""

#: src/dev/development.md:636
msgid "Use parentheses for method calls even when they could be omitted"
msgstr ""

#: src/dev/development.md:637
msgid "Prefer multi-line formatting with braces for complex expressions"
msgstr ""

#: src/dev/development.md:638
msgid "Use explicit type annotations for public APIs"
msgstr ""

#: src/dev/development.md:639
msgid "Keep line length reasonable (max 120 characters)"
msgstr ""

#: src/dev/development.md:640
msgid "Use two-space indentation within braces"
msgstr ""

#: src/dev/development.md:642
msgid "Enum Usage"
msgstr ""

#: src/dev/development.md:644
msgid "**Prefer Enums Over String Literals**"
msgstr ""

#: src/dev/development.md:645
msgid "Use enums for representing categories, types, or states"
msgstr ""

#: src/dev/development.md:646
msgid "Never use string literals as pseudo-enums"
msgstr ""

#: src/dev/development.md:656
msgid "\"CELL\" // Using string literals as enum values"
msgstr ""

#: src/dev/development.md:659
msgid "**Enum Naming Conventions**"
msgstr ""

#: src/dev/development.md:660
msgid "Use PascalCase for enum type names"
msgstr ""

#: src/dev/development.md:661
msgid "Use PascalCase for enum values"
msgstr ""

#: src/dev/development.md:662
msgid "Keep enum names clear and descriptive"
msgstr ""

#: src/dev/development.md:664
msgid "**Enum Usage**"
msgstr ""

#: src/dev/development.md:665
msgid "Import enum values when needed"
msgstr ""

#: src/dev/development.md:666
msgid "Use qualified access for clarity in other contexts"
msgstr ""

#: src/dev/development.md:667
msgid "Use pattern matching for exhaustive handling"
msgstr ""

#: src/dev/development.md:669
msgid "// Good usage"
msgstr ""

#: src/dev/development.md:681
msgid "Debugging Practices"
msgstr ""

#: src/dev/development.md:683
msgid "**Understand Before Fixing**"
msgstr ""

#: src/dev/development.md:684
msgid ""
"Always understand the root cause of an issue before attempting to fix it"
msgstr ""

#: src/dev/development.md:685
msgid ""
"Use the Debug utility with appropriate categories to trace program execution"
msgstr ""

#: src/dev/development.md:686
msgid "Analyze call stacks to identify where issues occur"
msgstr ""

#: src/dev/development.md:687
msgid "Create minimal test cases that reproduce the issue"
msgstr ""

#: src/dev/development.md:689
msgid "**Systematic Debugging Process**"
msgstr ""

#: src/dev/development.md:690
msgid "Enable relevant debug logging (`Debug.enable(DebugCategory.XXX)`)"
msgstr ""

#: src/dev/development.md:691
msgid "Add strategic logging points to track object state and method execution"
msgstr ""

#: src/dev/development.md:692
msgid "Verify assumptions about code behavior using logs and assertions"
msgstr ""

#: src/dev/development.md:693
msgid "Isolate the issue by creating focused test cases"
msgstr ""

#: src/dev/development.md:694
msgid "Document your findings to help others understand the problem"
msgstr ""

#: src/dev/development.md:696
msgid "**Debug-First Approach**"
msgstr ""

#: src/dev/development.md:697
msgid "When facing complex issues, prioritize debugging over immediate fixes"
msgstr ""

#: src/dev/development.md:698
msgid ""
"Add temporary debugging code when needed, but mark it clearly and remove "
"when done"
msgstr ""

#: src/dev/development.md:699
msgid "Consider adding permanent debugging hooks for areas prone to issues"
msgstr ""

#: src/dev/development.md:700
msgid "Document debugging insights even if they seem obvious"
msgstr ""

#: src/dev/devlog.md:3
msgid "2025-04-24"
msgstr ""

#: src/dev/devlog.md:5
msgid "LexerV2 Parser Completion"
msgstr ""

#: src/dev/devlog.md:7
msgid "**Completed Implementation**:"
msgstr ""

#: src/dev/devlog.md:8
msgid "**Block Termination Pattern**"
msgstr ""

#: src/dev/devlog.md:9
msgid "Implemented robust `}\\n` pattern detection with context awareness"
msgstr ""

#: src/dev/devlog.md:10
msgid ""
"Added state tracking via `newLineAfterBlockMeansEnds` flag in LexerState"
msgstr ""

#: src/dev/devlog.md:11
msgid "Ensured consistent handling between V1/V2 parsers"
msgstr ""

#: src/dev/devlog.md:12
msgid "Preserved uniform symbol treatment principles"
msgstr ""

#: src/dev/devlog.md:14
msgid "**Object Expression Enhancements**"
msgstr ""

#: src/dev/devlog.md:15
msgid "Added comprehensive support for multiple key types:"
msgstr ""

#: src/dev/devlog.md:16 src/dev/reader.md:96
msgid "Identifier keys (e.g., `{ x = 1 }`)"
msgstr ""

#: src/dev/devlog.md:17 src/dev/reader.md:97
msgid "String literal keys (e.g., `{ \"x\" = 1 }`)"
msgstr ""

#: src/dev/devlog.md:18 src/dev/reader.md:98
msgid "Symbol literal keys (e.g., `{ 'x = 1 }`)"
msgstr ""

#: src/dev/devlog.md:19
msgid "Implemented support for both `=` and `=>` operators in object clauses"
msgstr ""

#: src/dev/devlog.md:20
msgid "Added proper field parsing with comma-separated clauses"
msgstr ""

#: src/dev/devlog.md:21
msgid "Enhanced error reporting for malformed objects"
msgstr ""

#: src/dev/devlog.md:23
msgid "**Comment Handling Optimization**"
msgstr ""

#: src/dev/devlog.md:24
msgid "Replaced recursive comment collection with more efficient methods"
msgstr ""

#: src/dev/devlog.md:25
msgid ""
"Implemented `skipComments()` and `pullComments()` for better performance"
msgstr ""

#: src/dev/devlog.md:26
msgid "Added metadata merging for proper comment preservation"
msgstr ""

#: src/dev/devlog.md:27
msgid "Ensured consistent handling across different parsing contexts"
msgstr ""

#: src/dev/devlog.md:29
msgid "**Function Call and Block Argument Improvements**"
msgstr ""

#: src/dev/devlog.md:30
msgid "Added special handling for blocks used as function arguments"
msgstr ""

#: src/dev/devlog.md:31
msgid ""
"Implemented context-aware parsing of function calls with block arguments"
msgstr ""

#: src/dev/devlog.md:32
msgid "Ensured proper metadata preservation for source positions"
msgstr ""

#: src/dev/devlog.md:33
msgid "Added consistent handling of nested function calls"
msgstr ""

#: src/dev/devlog.md:35 src/dev/devlog.md:145
msgid "**Implementation Strategy**:"
msgstr ""

#: src/dev/devlog.md:36
msgid "Used token-based state machine approach for better performance"
msgstr ""

#: src/dev/devlog.md:37 src/dev/devlog.md:147
msgid "Maintained uniform symbol treatment for all operators"
msgstr ""

#: src/dev/devlog.md:38
msgid "Implemented comprehensive error handling"
msgstr ""

#: src/dev/devlog.md:39
msgid "Added extensive debug logging for easier maintenance"
msgstr ""

#: src/dev/devlog.md:41 src/dev/devlog.md:849
msgid "**Completed Features**:"
msgstr "**å·²å®ŒæˆåŠŸèƒ½**ï¼š"

#: src/dev/devlog.md:42 src/dev/devlog.md:153
msgid "âœ… Block termination with context tracking"
msgstr ""

#: src/dev/devlog.md:43
msgid "âœ… Object expressions with multiple key types"
msgstr ""

#: src/dev/devlog.md:44
msgid "âœ… Comment preservation and optimization"
msgstr ""

#: src/dev/devlog.md:45
msgid "âœ… Function call and block argument handling"
msgstr ""

#: src/dev/devlog.md:46
msgid ""
"âœ… **âš ï¸ IMPORTANT**: Flat operator sequence representation without precedence "
"handling (intentional design principle, often misunderstood)"
msgstr ""

#: src/dev/devlog.md:48 src/dev/devlog.md:89 src/dev/devlog.md:122
#: src/dev/devlog.md:220 src/dev/devlog.md:560 src/dev/devlog.md:600
#: src/dev/devlog.md:631 src/dev/devlog.md:680 src/dev/devlog.md:937
#: src/dev/devlog.md:1544
msgid "**Files Modified**:"
msgstr ""

#: src/dev/devlog.md:49 src/dev/devlog.md:1545
msgid "`reader/shared/src/main/scala/chester/readerv2/LexerV2.scala`"
msgstr ""

#: src/dev/devlog.md:50
msgid "Documentation files"
msgstr ""

#: src/dev/devlog.md:52
msgid "2025-04-21"
msgstr ""

#: src/dev/devlog.md:54
msgid "Simplified Type Constraint System by Removing Hacky Approach"
msgstr ""

#: src/dev/devlog.md:56
msgid ""
"**Problem**: The previous approach for handling type constraints used a "
"complicated \"cell coverage\" system that felt like a hack. The "
"`AutoConnect` propagator and `createTermStructureConstraints` method added "
"unnecessary complexity and indirection to the type system."
msgstr ""

#: src/dev/devlog.md:58
msgid ""
"**Solution**: Completely redesigned the approach to directly handle type "
"relationships without intermediate propagators."
msgstr ""

#: src/dev/devlog.md:60
msgid "**Implementation Details**:"
msgstr "**å¯¦ç¾ç´°ç¯€**ï¼š"

#: src/dev/devlog.md:61
msgid "**Removed Hacky Components**:"
msgstr ""

#: src/dev/devlog.md:62
msgid "Eliminated the `AutoConnect` propagator entirely"
msgstr ""

#: src/dev/devlog.md:63
msgid ""
"Removed `establishTypeConstraints` and all related \"cell coverage\" methods"
msgstr ""

#: src/dev/devlog.md:64
msgid "Simplified the code by removing several layers of indirection"
msgstr ""

#: src/dev/devlog.md:66
msgid "**Direct Type Relationship Handling**:"
msgstr ""

#: src/dev/devlog.md:67
msgid "Added direct connections between types directly during unification"
msgstr ""

#: src/dev/devlog.md:68
msgid "Created explicit relationships between union types and their components"
msgstr ""

#: src/dev/devlog.md:69
msgid "Connected function call components immediately when encountered"
msgstr ""

#: src/dev/devlog.md:70
msgid ""
"Simplified codebase by handling type constraints at the point where types "
"are created or unified"
msgstr ""

#: src/dev/devlog.md:72
msgid "**Improved Union Type Management**:"
msgstr ""

#: src/dev/devlog.md:73
msgid ""
"Enhanced handling of union-to-union subtyping with direct component "
"connections"
msgstr ""

#: src/dev/devlog.md:74
msgid "Improved union-to-specific and specific-to-union handling"
msgstr ""

#: src/dev/devlog.md:75
msgid "Created clearer, more maintainable code for union type relationships"
msgstr ""

#: src/dev/devlog.md:77
msgid "**Function Call Processing**:"
msgstr ""

#: src/dev/devlog.md:78
msgid "Implemented direct processing of function call components"
msgstr ""

#: src/dev/devlog.md:79
msgid "Added recursive handling for nested function calls"
msgstr ""

#: src/dev/devlog.md:80
msgid "Eliminated redundant constraint establishment code"
msgstr ""

#: src/dev/devlog.md:82 src/dev/devlog.md:127 src/dev/devlog.md:233
#: src/dev/devlog.md:645 src/dev/devlog.md:954 src/dev/devlog.md:972
#: src/dev/devlog.md:989 src/dev/devlog.md:1005 src/dev/devlog.md:1020
#: src/dev/devlog.md:1061 src/dev/devlog.md:1080 src/dev/devlog.md:1098
#: src/dev/devlog.md:1116 src/dev/devlog.md:1521
msgid "**Benefits**:"
msgstr ""

#: src/dev/devlog.md:83
msgid ""
"**Cleaner Code**: Removed a complicated system that was difficult to reason "
"about"
msgstr ""

#: src/dev/devlog.md:84
msgid ""
"**More Direct**: Handles type constraints at the point where types are "
"created or unified"
msgstr ""

#: src/dev/devlog.md:85
msgid ""
"**Better Maintainability**: Simpler, more understandable code with fewer "
"moving parts"
msgstr ""

#: src/dev/devlog.md:86
msgid ""
"**Less Indirection**: Eliminated multiple layers of function calls for basic "
"operations"
msgstr ""

#: src/dev/devlog.md:87
msgid ""
"**Same Functionality**: Maintains the same type checking capabilities with "
"cleaner implementation"
msgstr ""

#: src/dev/devlog.md:90 src/dev/devlog.md:123 src/dev/devlog.md:601
#: src/dev/devlog.md:681 src/dev/devlog.md:938
msgid "`semantic/shared/src/main/scala/chester/tyck/TyckPropagator.scala`"
msgstr ""

#: src/dev/devlog.md:91 src/dev/devlog.md:124 src/dev/devlog.md:602
#: src/dev/devlog.md:939
msgid "`semantic/shared/src/main/scala/chester/tyck/Elaborater.scala`"
msgstr ""

#: src/dev/devlog.md:93
msgid "**Verification**:"
msgstr ""

#: src/dev/devlog.md:94
msgid "All existing tests continue to pass"
msgstr ""

#: src/dev/devlog.md:95
msgid "Compiler successfully builds the project"
msgstr ""

#: src/dev/devlog.md:96
msgid "Type error reporting works as expected"
msgstr ""

#: src/dev/devlog.md:98
msgid "Replaced EnsureCellCoverage Hack with AutoConnect Propagator"
msgstr ""

#: src/dev/devlog.md:100 src/dev/devlog.md:570 src/dev/devlog.md:655
msgid "**Implemented Improvements**:"
msgstr ""

#: src/dev/devlog.md:101
msgid "**Replaced EnsureCellCoverage with AutoConnect**"
msgstr ""

#: src/dev/devlog.md:102
msgid ""
"Removed the old placeholder EnsureCellCoverage propagator that only marked "
"cells as covered"
msgstr ""

#: src/dev/devlog.md:103
msgid ""
"Implemented new AutoConnect propagator that establishes proper type "
"connections based on term structure"
msgstr ""

#: src/dev/devlog.md:104
msgid ""
"Added logic to analyze different term types (unions, intersections, function "
"calls) and create appropriate connections"
msgstr ""

#: src/dev/devlog.md:106
msgid "**Enhanced Cell Coverage Mechanisms**"
msgstr ""

#: src/dev/devlog.md:107
msgid ""
"Added support for creating proper connections between terms and their "
"components"
msgstr ""

#: src/dev/devlog.md:108
msgid ""
"Implemented smart term structure analysis to establish meaningful type "
"relationships"
msgstr ""

#: src/dev/devlog.md:109
msgid ""
"Added default value support for unconstrained type variables using Any type"
msgstr ""

#: src/dev/devlog.md:111
msgid "**Improved Function Call Handling**"
msgstr ""

#: src/dev/devlog.md:112
msgid "Added recursive connection for function calls and their arguments"
msgstr ""

#: src/dev/devlog.md:113
msgid ""
"Special handling for complex argument terms including nested function calls"
msgstr ""

#: src/dev/devlog.md:114
msgid ""
"Improved handling of CallingArgTerm to ensure all components are properly "
"connected"
msgstr ""

#: src/dev/devlog.md:116 src/dev/devlog.md:687
msgid "**Implementation Approach**:"
msgstr ""

#: src/dev/devlog.md:117
msgid "Replaced all EnsureCellCoverage instances with AutoConnect calls"
msgstr ""

#: src/dev/devlog.md:118
msgid "Updated Elaborater and TyckPropagator to use the new approach"
msgstr ""

#: src/dev/devlog.md:119
msgid "Added cell management helper methods and proper zonking support"
msgstr ""

#: src/dev/devlog.md:120
msgid "Added support for default values in unconstrained cells"
msgstr ""

#: src/dev/devlog.md:125
msgid ""
"`semantic/shared/src/main/scala/chester/utils/propagator/ProvideCellId.scala`"
msgstr ""

#: src/dev/devlog.md:128
msgid "Eliminated artificial cell coverage without meaningful constraints"
msgstr ""

#: src/dev/devlog.md:129
msgid "Improved type error detection through proper constraint checking"
msgstr ""

#: src/dev/devlog.md:130
msgid "Reduced conceptual complexity in the propagator network"
msgstr ""

#: src/dev/devlog.md:131
msgid "Enhanced maintainability as the type system evolves"
msgstr ""

#: src/dev/devlog.md:132
msgid "Fixed cell coverage issues for union types and other complex types"
msgstr ""

#: src/dev/devlog.md:134
msgid "2025-04-05"
msgstr ""

#: src/dev/devlog.md:136
msgid "LexerV2 Parser Enhancements"
msgstr ""

#: src/dev/devlog.md:138
msgid ""
"**Block Termination**: Implemented context tracking for `}\\n` pattern "
"detection, ensuring consistent handling between V1/V2 parsers while "
"preserving uniform symbol treatment"
msgstr ""

#: src/dev/devlog.md:139
msgid ""
"**Object Expressions**: Added support for identifier, string, and symbol "
"keys with both `=` and `=>` operators"
msgstr ""

#: src/dev/devlog.md:140
msgid "**Token Optimization**:"
msgstr ""

#: src/dev/devlog.md:141
msgid "Simplified token extractors using common helper methods"
msgstr ""

#: src/dev/devlog.md:142
msgid "Enhanced comment collection and attachment"
msgstr ""

#: src/dev/devlog.md:143
msgid "Improved handling of leading/trailing comments"
msgstr ""

#: src/dev/devlog.md:146
msgid "Added context tracking for block termination"
msgstr ""

#: src/dev/devlog.md:148
msgid "Enhanced object expression parsing"
msgstr ""

#: src/dev/devlog.md:149
msgid "Optimized token handling for better maintainability"
msgstr ""

#: src/dev/devlog.md:151
msgid "**Migration Status**:"
msgstr ""

#: src/dev/devlog.md:152
msgid "âœ… Pattern matching with proper block handling"
msgstr ""

#: src/dev/devlog.md:154
msgid "âœ… Basic object expressions"
msgstr ""

#: src/dev/devlog.md:155
msgid "âœ… Comment preservation"
msgstr ""

#: src/dev/devlog.md:156
msgid "ğŸŸ¡ Complex object expressions (in progress)"
msgstr ""

#: src/dev/devlog.md:157
msgid "ğŸ”´ Source maps and error recovery (planned)"
msgstr ""

#: src/dev/devlog.md:159
msgid "**Modified**: `LexerV2.scala`, documentation files"
msgstr ""

#: src/dev/devlog.md:161
msgid "2025-03-14"
msgstr ""

#: src/dev/devlog.md:163
msgid "Parser Improvements and Refactoring"
msgstr ""

#: src/dev/devlog.md:164 src/dev/devlog.md:884
msgid "**Completed Improvements**:"
msgstr ""

#: src/dev/devlog.md:165
msgid "**Operator Precedence Enhancement**"
msgstr ""

#: src/dev/devlog.md:166
msgid "**Issue**: Complex operator sequences not handled correctly"
msgstr ""

#: src/dev/devlog.md:167
msgid "**Improvement**: Added operator precedence table and parsing logic"
msgstr ""

#: src/dev/devlog.md:168
msgid "**Benefits**: Better handling of complex expressions"
msgstr ""

#: src/dev/devlog.md:169
msgid "**Implementation**: Added precedence table and parsing logic"
msgstr ""

#: src/dev/devlog.md:171
msgid "**Whitespace Handling Enhancement**"
msgstr ""

#: src/dev/devlog.md:172
msgid "**Issue**: Inconsistent whitespace handling"
msgstr ""

#: src/dev/devlog.md:173
msgid "**Improvement**: Added dedicated whitespace parsing"
msgstr ""

#: src/dev/devlog.md:174
msgid "**Benefits**: More consistent parsing behavior"
msgstr ""

#: src/dev/devlog.md:175
msgid "**Implementation**: Added whitespace parsing logic"
msgstr ""

#: src/dev/devlog.md:177
msgid "**Error Recovery Enhancement**"
msgstr ""

#: src/dev/devlog.md:178
msgid "**Issue**: Parser failed on first error"
msgstr ""

#: src/dev/devlog.md:179
msgid "**Improvement**: Added error recovery mechanisms"
msgstr ""

#: src/dev/devlog.md:180
msgid "**Benefits**: Better error reporting and recovery"
msgstr ""

#: src/dev/devlog.md:181
msgid "**Implementation**: Added error recovery logic"
msgstr ""

#: src/dev/devlog.md:183
msgid "**Token Type Enhancement**"
msgstr ""

#: src/dev/devlog.md:184
msgid "**Issue**: Limited token type support"
msgstr ""

#: src/dev/devlog.md:185
msgid "**Improvement**: Added more token types"
msgstr ""

#: src/dev/devlog.md:186
msgid "**Benefits**: Better token categorization"
msgstr ""

#: src/dev/devlog.md:187
msgid "**Implementation**: Added new token types"
msgstr ""

#: src/dev/devlog.md:189
msgid "**Source Position Tracking**"
msgstr ""

#: src/dev/devlog.md:190
msgid "**Issue**: Inaccurate error locations"
msgstr ""

#: src/dev/devlog.md:191
msgid "**Improvement**: Enhanced position tracking"
msgstr ""

#: src/dev/devlog.md:192
msgid "**Benefits**: Better error messages"
msgstr ""

#: src/dev/devlog.md:193
msgid "**Implementation**: Added position tracking"
msgstr ""

#: src/dev/devlog.md:195
msgid "**Test Coverage Enhancement**"
msgstr ""

#: src/dev/devlog.md:196
msgid "**Issue**: Limited test coverage"
msgstr ""

#: src/dev/devlog.md:197
msgid "**Improvement**: Added more test cases"
msgstr ""

#: src/dev/devlog.md:198
msgid "**Benefits**: Better code quality"
msgstr ""

#: src/dev/devlog.md:199
msgid "**Implementation**: Added test cases"
msgstr ""

#: src/dev/devlog.md:201
msgid "**Uniform Operator Handling**"
msgstr ""

#: src/dev/devlog.md:202
msgid "**Issue**: Special case handling for \"=>\" operator"
msgstr ""

#: src/dev/devlog.md:203
msgid "**Improvement**: Removed special cases, unified operator parsing"
msgstr ""

#: src/dev/devlog.md:204
msgid "**Benefits**: More consistent operator handling"
msgstr ""

#: src/dev/devlog.md:205 src/dev/devlog.md:214 src/dev/devlog.md:959
#: src/dev/devlog.md:977 src/dev/devlog.md:993 src/dev/devlog.md:1009
#: src/dev/devlog.md:1024 src/dev/devlog.md:1066 src/dev/devlog.md:1085
#: src/dev/devlog.md:1103 src/dev/devlog.md:1121
msgid "**Implementation**:"
msgstr "**å¯¦ä½œ**ï¼š"

#: src/dev/devlog.md:206
msgid "Removed special case in `parseOperator()`"
msgstr ""

#: src/dev/devlog.md:207
msgid "Now using StringBuilder for all operators"
msgstr ""

#: src/dev/devlog.md:208
msgid "All tests passing"
msgstr ""

#: src/dev/devlog.md:210
msgid "**LexerV2 Optimization and Refactoring**"
msgstr ""

#: src/dev/devlog.md:211
msgid "**Issue**: Code duplication and maintainability issues"
msgstr ""

#: src/dev/devlog.md:212
msgid "**Improvement**: Restructured for modularity and conciseness"
msgstr ""

#: src/dev/devlog.md:213
msgid "**Benefits**: Better code organization and maintainability"
msgstr ""

#: src/dev/devlog.md:215
msgid "Extracted repeated logic into helper methods"
msgstr ""

#: src/dev/devlog.md:216
msgid "Improved state management"
msgstr ""

#: src/dev/devlog.md:217
msgid "Fixed compilation error (replaced advance() with state.advance())"
msgstr ""

#: src/dev/devlog.md:218
msgid ""
"Remaining warnings about unused private members and pattern match "
"exhaustiveness"
msgstr ""

#: src/dev/devlog.md:221 src/dev/devlog.md:837 src/dev/devlog.md:1492
msgid "`reader/src/main/scala/chester/readerv2/LexerV2.scala`"
msgstr ""

#: src/dev/devlog.md:222
msgid "`reader/src/main/scala/chester/readerv2/Tokenizer.scala`"
msgstr ""

#: src/dev/devlog.md:223
msgid "**Tests**: All existing tests passing"
msgstr ""

#: src/dev/devlog.md:225
msgid "V1/V2 Semantic Consistency"
msgstr ""

#: src/dev/devlog.md:226 src/dev/devlog.md:240 src/dev/devlog.md:249
msgid "**Implementation Plan**:"
msgstr "**å¯¦ç¾è¨ˆåŠƒ**ï¼š"

#: src/dev/devlog.md:227
msgid ""
"Analyze test files still using `parseAndCheck` to identify semantic "
"differences"
msgstr ""

#: src/dev/devlog.md:228
msgid "Prioritize addressing the complex operator sequence handling first"
msgstr ""

#: src/dev/devlog.md:229
msgid "Implement proper handling for prefix and mixfix operators in V2"
msgstr ""

#: src/dev/devlog.md:230
msgid "Test and verify with existing test cases"
msgstr ""

#: src/dev/devlog.md:231
msgid "Update tests to use `parseAndCheckBoth` once they pass"
msgstr ""

#: src/dev/devlog.md:232
msgid "Document any intentional semantic differences that won't be addressed"
msgstr ""

#: src/dev/devlog.md:234
msgid "More consistent parsing behavior between V1 and V2"
msgstr ""

#: src/dev/devlog.md:235
msgid "Higher confidence in V2 parser for all use cases"
msgstr ""

#: src/dev/devlog.md:236
msgid "Easier migration path from V1 to V2"
msgstr ""

#: src/dev/devlog.md:237
msgid "More tests running against both parsers"
msgstr ""

#: src/dev/devlog.md:239
msgid "Object Expressions"
msgstr ""

#: src/dev/devlog.md:241
msgid "Review current object parsing implementation"
msgstr ""

#: src/dev/devlog.md:242
msgid "Identify missing features compared to V1"
msgstr ""

#: src/dev/devlog.md:243
msgid "Implement support for complex object syntax"
msgstr ""

#: src/dev/devlog.md:244
msgid "Test with a variety of object expressions"
msgstr ""

#: src/dev/devlog.md:246
msgid "Telescope Parsing"
msgstr ""

#: src/dev/devlog.md:247
msgid "**Issue**: Telescope parsing is not yet implemented in V2"
msgstr ""

#: src/dev/devlog.md:248
msgid ""
"**Improvement**: Implement telescope parsing in V2 to match V1 semantics"
msgstr ""

#: src/dev/devlog.md:250
msgid "Analyze V1 telescope parsing implementation"
msgstr ""

#: src/dev/devlog.md:251
msgid "Design and implement equivalent functionality in V2"
msgstr ""

#: src/dev/devlog.md:252
msgid "Test with existing telescope tests"
msgstr ""

#: src/dev/devlog.md:254
msgid "Block Termination and Newline Handling in V2 Parser"
msgstr ""

#: src/dev/devlog.md:256
msgid "Problem Analysis:"
msgstr ""

#: src/dev/devlog.md:257
msgid ""
"When examining why the pattern matching test fails with V2 parser, I "
"identified several issues:"
msgstr ""

#: src/dev/devlog.md:259
msgid "**Newline Handling:**"
msgstr ""

#: src/dev/devlog.md:260
msgid ""
"V1 parser has implicit newline handling that affects expression termination"
msgstr ""

#: src/dev/devlog.md:261
msgid "This is particularly important for blocks that end with `}`"
msgstr ""

#: src/dev/devlog.md:262
msgid ""
"V2 parser needs to check for `Token.Newline` after a block and terminate "
"expressions appropriately"
msgstr ""

#: src/dev/devlog.md:263
msgid "This affects the `parseRest` method in `LexerV2.scala`"
msgstr ""

#: src/dev/devlog.md:265
msgid "**Pattern Matching Block Structure:**"
msgstr ""

#: src/dev/devlog.md:266
msgid "Pattern matching has a unique structure: `identifier match { ... }`"
msgstr ""

#: src/dev/devlog.md:267
msgid ""
"The V2 parser needs a general approach to handle this construct without "
"introducing special cases"
msgstr ""

#: src/dev/devlog.md:268
msgid ""
"The challenge is maintaining uniform handling while correctly parsing "
"pattern matching"
msgstr ""

#: src/dev/devlog.md:270
msgid "**Test Compatibility:**"
msgstr ""

#: src/dev/devlog.md:271
msgid "Many tests use `parseAndCheckBoth` which runs both V1 and V2 parsers"
msgstr ""

#: src/dev/devlog.md:272
msgid ""
"Tests with newlines after blocks fail because V2 doesn't terminate "
"expressions correctly"
msgstr ""

#: src/dev/devlog.md:273
msgid "Pattern matching tests are particularly affected by this issue"
msgstr ""

#: src/dev/devlog.md:275
msgid "**StringIndexOutOfBoundsException in Error Reporting:**"
msgstr ""

#: src/dev/devlog.md:276
msgid ""
"When using `parseAndCheckBoth`, error reporting code in "
"`parseAndCheck.scala` can throw `StringIndexOutOfBoundsException`"
msgstr ""

#: src/dev/devlog.md:277
msgid "This happens when trying to extract line information for error messages"
msgstr ""

#: src/dev/devlog.md:278
msgid "Requires bounds checking to prevent exceptions"
msgstr ""

#: src/dev/devlog.md:280
msgid "**Parser Architecture Tradeoffs:**"
msgstr ""

#: src/dev/devlog.md:281
msgid "We need to balance flexibility with consistency"
msgstr ""

#: src/dev/devlog.md:282
msgid ""
"Simple tokenization approach makes it hard to handle significant whitespace/"
"newlines"
msgstr ""

#: src/dev/devlog.md:283
msgid ""
"Excessive special cases make the parser harder to maintain and reason about"
msgstr ""

#: src/dev/devlog.md:284
msgid ""
"**Context-free parsing is strongly preferred over context-dependent "
"approaches**"
msgstr ""

#: src/dev/devlog.md:285
msgid ""
"A simple, uniform rule (like always ending an OpSeq when seeing `}\\n`) is "
"better than complex contextual rules"
msgstr ""

#: src/dev/devlog.md:287
msgid "Possible Approaches:"
msgstr ""

#: src/dev/devlog.md:289
msgid "**Context-Free Newline Handling (PREFERRED):**"
msgstr ""

#: src/dev/devlog.md:290
msgid ""
"Always end OpSeq expression when encountering `}\\n` (closing brace followed "
"by newline)"
msgstr ""

#: src/dev/devlog.md:291
msgid "Apply this rule uniformly regardless of surrounding context"
msgstr ""

#: src/dev/devlog.md:292
msgid "Uniform treatment of all block terminations without special cases"
msgstr ""

#: src/dev/devlog.md:293
msgid "No need to track or analyze the meaning of identifiers like \"match\""
msgstr ""

#: src/dev/devlog.md:294
msgid ""
"Simple, predictable parsing behavior that aligns with Chester's design "
"principles"
msgstr ""

#: src/dev/devlog.md:296
msgid "**Token Differentiation Strategy:**"
msgstr ""

#: src/dev/devlog.md:297
msgid "Enhance tokenizer to differentiate between whitespace and newlines"
msgstr ""

#: src/dev/devlog.md:298
msgid "This allows the parser to recognize expression boundaries better"
msgstr ""

#: src/dev/devlog.md:299
msgid "Requires minimal special-casing in the parser"
msgstr ""

#: src/dev/devlog.md:301
msgid "**Whitespace with Newline Flag:**"
msgstr ""

#: src/dev/devlog.md:302
msgid ""
"Instead of creating a separate `Token.Newline` class, enhance "
"`Token.Whitespace` with a boolean flag"
msgstr ""

#: src/dev/devlog.md:303
msgid ""
"Add a `canActAsNewline` flag to indicate if this whitespace contains "
"characters that can terminate expressions"
msgstr ""

#: src/dev/devlog.md:304
msgid ""
"This simplifies tokenization while still providing the necessary information "
"to the parser"
msgstr ""

#: src/dev/devlog.md:305
msgid ""
"Reduces token type proliferation and maintains a cleaner token hierarchy"
msgstr ""

#: src/dev/devlog.md:306
msgid ""
"Parser can check `token.isWhitespace && token.canActAsNewline` when making "
"termination decisions"
msgstr ""

#: src/dev/devlog.md:307
msgid ""
"Avoids the overhead of creating a completely new token type while gaining "
"the same benefits"
msgstr ""

#: src/dev/devlog.md:309
msgid "**Enhanced Block Parsing:**"
msgstr ""

#: src/dev/devlog.md:310
msgid ""
"Modify block parsing to handle different types of blocks in a more general "
"way"
msgstr ""

#: src/dev/devlog.md:311
msgid "Use structural information rather than keyword recognition"
msgstr ""

#: src/dev/devlog.md:312
msgid ""
"This approach maintains parser consistency while handling pattern matching"
msgstr ""

#: src/dev/devlog.md:314
msgid "**Contextual Parsing (LEAST PREFERRED):**"
msgstr ""

#: src/dev/devlog.md:315
msgid ""
"Use context information to parse expressions differently in different "
"situations"
msgstr ""

#: src/dev/devlog.md:316
msgid "For pattern matching, recognize the context and adjust parsing rules"
msgstr ""

#: src/dev/devlog.md:317
msgid "More complex and violates the preference for context-free parsing"
msgstr ""

#: src/dev/devlog.md:318
msgid "Harder to maintain and reason about"
msgstr ""

#: src/dev/devlog.md:320
msgid ""
"**Recommended Approach:** The **Context-Free Newline Handling** approach "
"combined with the **Whitespace with Newline Flag** provides the simplest and "
"most maintainable solution. This approach:"
msgstr ""

#: src/dev/devlog.md:322
msgid "Maintains Chester's core design principles of uniform symbol treatment"
msgstr ""

#: src/dev/devlog.md:323
msgid "Preserves strict separation of parsing from semantic analysis"
msgstr ""

#: src/dev/devlog.md:324
msgid ""
"Applies a consistent rule for all block terminations without special cases"
msgstr ""

#: src/dev/devlog.md:325
msgid "Avoids context-dependent parsing which is harder to maintain"
msgstr ""

#: src/dev/devlog.md:326
msgid ""
"Treats `}\\n` as a syntactic boundary in all contexts, which is simpler and "
"more predictable"
msgstr ""

#: src/dev/devlog.md:328
msgid ""
"The parser should simply terminate an OpSeq when encountering a `}\\n` "
"pattern, regardless of what identifiers (like \"match\") may be present in "
"the sequence. This maintains the context-free nature of the parser and "
"avoids the complexity of context-dependent rules."
msgstr ""

#: src/dev/devlog.md:330
msgid "Integration with Existing Code:"
msgstr ""

#: src/dev/devlog.md:332
msgid ""
"The proposed changes will affect several components of the current codebase:"
msgstr ""

#: src/dev/devlog.md:334
msgid "**Consistency with Operator Handling:**"
msgstr ""

#: src/dev/devlog.md:335
msgid ""
"The parser will continue to treat all symbols uniformly, including 'match'"
msgstr ""

#: src/dev/devlog.md:336
msgid "No special precedence rules will be added in the parser itself"
msgstr ""

#: src/dev/devlog.md:337
msgid "Pattern matching will be represented as a standard OpSeq in the AST"
msgstr ""

#: src/dev/devlog.md:338
msgid ""
"Any special handling of 'match' will occur in subsequent passes, not in the "
"parser"
msgstr ""

#: src/dev/devlog.md:340
msgid "**Interaction with Block Parsing:**"
msgstr ""

#: src/dev/devlog.md:341
msgid "Block parsing will remain unchanged"
msgstr ""

#: src/dev/devlog.md:342
msgid "The parser will create a standard OpSeq structure for match expressions"
msgstr ""

#: src/dev/devlog.md:343
msgid "Semantic analysis of pattern matching occurs after parsing, not during"
msgstr ""

#: src/dev/devlog.md:345
msgid "Performance Considerations:"
msgstr ""

#: src/dev/devlog.md:347
msgid "**Token Differentiation Impact:**"
msgstr ""

#: src/dev/devlog.md:348
msgid ""
"Adding Token.Newline will slightly increase token count but with negligible "
"memory overhead"
msgstr ""

#: src/dev/devlog.md:349
msgid "Parsing performance should not be significantly affected"
msgstr ""

#: src/dev/devlog.md:350
msgid ""
"May improve performance by reducing backtracking and error recovery needs"
msgstr ""

#: src/dev/devlog.md:352
msgid "**Operator-Based Solution Efficiency:**"
msgstr ""

#: src/dev/devlog.md:353
msgid "Leverages existing operator handling machinery"
msgstr ""

#: src/dev/devlog.md:354
msgid "No additional parsing passes required"
msgstr ""

#: src/dev/devlog.md:355
msgid "Consistent with current performance profile of operator parsing"
msgstr ""

#: src/dev/devlog.md:359
msgid "**Current Parsing Result (V1):**"
msgstr ""

#: src/dev/devlog.md:361
msgid "// Input:"
msgstr ""

#: src/dev/devlog.md:366
msgid "// AST (simplified):"
msgstr ""

#: src/dev/devlog.md:369 src/dev/devlog.md:384
msgid "\"notification\""
msgstr ""

#: src/dev/devlog.md:370 src/dev/devlog.md:385
msgid "\"match\""
msgstr ""

#: src/dev/devlog.md:372 src/dev/devlog.md:373 src/dev/devlog.md:387
#: src/dev/devlog.md:388
msgid "\"case\""
msgstr ""

#: src/dev/devlog.md:372 src/dev/devlog.md:387
msgid "\"Email\""
msgstr ""

#: src/dev/devlog.md:372 src/dev/devlog.md:373 src/dev/devlog.md:387
#: src/dev/devlog.md:388
msgid "\"=>\""
msgstr ""

#: src/dev/devlog.md:373 src/dev/devlog.md:388
msgid "\"SMS\""
msgstr ""

#: src/dev/devlog.md:378
msgid "**Desired V2 Parsing Result:**"
msgstr ""

#: src/dev/devlog.md:380
msgid "// Same input should produce identical AST structure with flat OpSeq"
msgstr ""

#: src/dev/devlog.md:380
msgid ""
"// The parser has no knowledge of what 'match' means - it's just an "
"identifier"
msgstr ""

#: src/dev/devlog.md:381
msgid "// Structure interpretation happens in later passes, not during parsing"
msgstr ""

#: src/dev/devlog.md:393
msgid "Reference Implementation Strategy:"
msgstr ""

#: src/dev/devlog.md:395
msgid "**Phased Approach:**"
msgstr ""

#: src/dev/devlog.md:396
msgid "First implement the whitespace enhancement with newline flag"
msgstr ""

#: src/dev/devlog.md:397
msgid "Ensure the parser treats 'match' just like any other identifier"
msgstr ""

#: src/dev/devlog.md:398
msgid "Verify match expressions produce standard OpSeq nodes"
msgstr ""

#: src/dev/devlog.md:399
msgid ""
"Test with existing pattern matching tests to ensure correct AST structure"
msgstr ""

#: src/dev/devlog.md:401
msgid "**Validation Criteria:**"
msgstr ""

#: src/dev/devlog.md:402
msgid "All existing tests should pass when using both parsers"
msgstr ""

#: src/dev/devlog.md:403
msgid "Parser should produce identical AST structures for both V1 and V2"
msgstr ""

#: src/dev/devlog.md:404
msgid "No special handling for any identifiers including 'match' in the parser"
msgstr ""

#: src/dev/devlog.md:405
msgid "Maintain uniform treatment of symbols throughout the parser"
msgstr ""

#: src/dev/devlog.md:406
msgid "Preserve strict separation between parsing and semantic analysis"
msgstr ""

#: src/dev/devlog.md:408
msgid "Learning from Other Languages:"
msgstr ""

#: src/dev/devlog.md:410
msgid "**Scala's Approach:**"
msgstr ""

#: src/dev/devlog.md:411
msgid "Scala treats 'match' as a special keyword with defined precedence"
msgstr ""

#: src/dev/devlog.md:412
msgid "Pattern matching is handled as a distinct grammar construct"
msgstr "æ¨¡å¼åŒ¹é…è¢«è™•ç†ç‚ºç¨ç‰¹çš„èªæ³•çµæ§‹"

#: src/dev/devlog.md:413
msgid "This differs from Chester's uniform symbol treatment philosophy"
msgstr ""

#: src/dev/devlog.md:415
msgid "**Rust's Approach:**"
msgstr ""

#: src/dev/devlog.md:416
msgid "Rust uses match expressions with block-based syntax"
msgstr ""

#: src/dev/devlog.md:417
msgid "Parser explicitly recognizes the 'match' keyword"
msgstr ""

#: src/dev/devlog.md:418
msgid "Arms of match expressions have specific parsing rules"
msgstr ""

#: src/dev/devlog.md:419
msgid ""
"Chester can adapt Rust's block structure handling while maintaining uniform "
"symbol treatment"
msgstr ""

#: src/dev/devlog.md:421
msgid "Backward Compatibility Guarantees:"
msgstr ""

#: src/dev/devlog.md:423
msgid "**Parsing Output Compatibility:**"
msgstr ""

#: src/dev/devlog.md:424
msgid ""
"The V2 parser will produce ASTs semantically equivalent to V1 for pattern "
"matching"
msgstr ""

#: src/dev/devlog.md:425
msgid ""
"Existing code that consumes ASTs will continue to work without modification"
msgstr ""

#: src/dev/devlog.md:426
msgid "The structure of OpSeq nodes for pattern matching will be preserved"
msgstr ""

#: src/dev/devlog.md:428
msgid "**What Might Change:**"
msgstr ""

#: src/dev/devlog.md:429
msgid "Internal source position information might be slightly different"
msgstr ""

#: src/dev/devlog.md:430
msgid "Comment attachment points could vary in edge cases"
msgstr ""

#: src/dev/devlog.md:431
msgid "Error messages may be more precise or different in wording"
msgstr ""

#: src/dev/devlog.md:433
msgid "Transition Plan:"
msgstr ""

#: src/dev/devlog.md:435
msgid "**For Test Code:**"
msgstr ""

#: src/dev/devlog.md:436
msgid "Gradually migrate tests from parseAndCheck to parseAndCheckBoth"
msgstr ""

#: src/dev/devlog.md:437
msgid "Document any tests that must remain on V1 parser temporarily"
msgstr ""

#: src/dev/devlog.md:438
msgid "Add specific tests for pattern matching edge cases"
msgstr ""

#: src/dev/devlog.md:440
msgid "**For Production Code:**"
msgstr ""

#: src/dev/devlog.md:441
msgid "The V2 parser implementation can be introduced behind a feature flag"
msgstr ""

#: src/dev/devlog.md:442
msgid "Allow both parsers to run in parallel initially for validation"
msgstr ""

#: src/dev/devlog.md:443
msgid "Collect metrics on parsing compatibility and performance"
msgstr ""

#: src/dev/devlog.md:444
msgid "Full migration only after all tests pass with both parsers"
msgstr ""

#: src/dev/devlog.md:446
msgid "**For Documentation:**"
msgstr ""

#: src/dev/devlog.md:447
msgid "Update parser documentation to reflect the new approach"
msgstr ""

#: src/dev/devlog.md:448
msgid "Provide migration notes for any edge cases"
msgstr ""

#: src/dev/devlog.md:449
msgid "Document the rationale behind the design decisions"
msgstr ""

#: src/dev/devlog.md:451
msgid "Implementation Plan:"
msgstr ""

#: src/dev/devlog.md:453
msgid "**Whitespace Enhancement:**"
msgstr ""

#: src/dev/devlog.md:454
msgid "Enhance `Token.Whitespace` with a `canActAsNewline` flag"
msgstr ""

#: src/dev/devlog.md:455
msgid ""
"Modify tokenizer to set this flag appropriately when encountering newline "
"characters"
msgstr ""

#: src/dev/devlog.md:456
msgid "Keep token handling simple and uniform"
msgstr ""

#: src/dev/devlog.md:458
msgid "**Context-Free Expression Termination:**"
msgstr ""

#: src/dev/devlog.md:459
msgid ""
"Update `LexerV2.parseRest()` to implement simple `}\\n` termination rule"
msgstr ""

#: src/dev/devlog.md:460
msgid ""
"Add condition: `if (previousToken == \"}\" && currentToken.isWhitespace && "
"currentToken.canActAsNewline)`"
msgstr ""

#: src/dev/devlog.md:461
msgid ""
"Always terminate OpSeq when this pattern is encountered, regardless of "
"context"
msgstr ""

#: src/dev/devlog.md:462
msgid "No special cases or context-dependent decisions"
msgstr ""

#: src/dev/devlog.md:463
msgid "Consistent rule application across all expressions"
msgstr ""

#: src/dev/devlog.md:465
msgid "**Uniform Symbol Treatment:**"
msgstr ""

#: src/dev/devlog.md:466
msgid ""
"Maintain the flat OpSeq production for all expressions including pattern "
"matching"
msgstr ""

#: src/dev/devlog.md:467
msgid "No special handling for any identifiers (including 'match')"
msgstr ""

#: src/dev/devlog.md:468
msgid ""
"Apply termination rules based purely on token patterns, not semantic meaning"
msgstr ""

#: src/dev/devlog.md:469
msgid "Let later passes handle pattern matching semantics"
msgstr ""

#: src/dev/devlog.md:471
msgid "**Error Handling Improvements:**"
msgstr ""

#: src/dev/devlog.md:472
msgid ""
"Add bounds checking in `parseAndCheck.scala` to prevent "
"`StringIndexOutOfBoundsException`"
msgstr ""

#: src/dev/devlog.md:473
msgid "Ensure safe substring extraction for error messages"
msgstr ""

#: src/dev/devlog.md:475
msgid "**Testing Strategy:**"
msgstr ""

#: src/dev/devlog.md:476
msgid ""
"Fix the core expression termination in V2 parser using the context-free "
"approach"
msgstr ""

#: src/dev/devlog.md:477
msgid "Verify pattern matching tests pass with both parsers"
msgstr ""

#: src/dev/devlog.md:478
msgid "Gradually migrate more tests to use `parseAndCheckBoth`"
msgstr ""

#: src/dev/devlog.md:480
msgid "Current Status:"
msgstr ""

#: src/dev/devlog.md:481
msgid "Need to implement newline token handling"
msgstr ""

#: src/dev/devlog.md:482
msgid "Need to enhance operator-based approach for pattern matching"
msgstr ""

#: src/dev/devlog.md:483
msgid "Need to improve error reporting with bounds checking"
msgstr ""

#: src/dev/devlog.md:484
msgid "Pattern matching test runs with V1 parser but fails with V2"
msgstr ""

#: src/dev/devlog.md:485
msgid ""
"More work needed on general parsing of pattern matching without special cases"
msgstr ""

#: src/dev/devlog.md:487
msgid "The `}\\n` Pattern Problem"
msgstr ""

#: src/dev/devlog.md:489
msgid ""
"The Chester parser treats the `}\\n` pattern (closing brace followed by "
"newline) as a significant syntax element for terminating expressions in "
"specific contexts. This pattern plays a crucial role in:"
msgstr ""

#: src/dev/devlog.md:491
msgid "**Function/Method Definitions**"
msgstr ""

#: src/dev/devlog.md:492
msgid ""
"```\n"
"def factorial(n) {\n"
"  if n <= 1 then 1\n"
"  else n * factorial(n - 1)\n"
"}  // <- newline here ends the function definition\n"
"\n"
"val result = factorial(5); // Next statement\n"
"```"
msgstr ""

#: src/dev/devlog.md:501
msgid "**Match Expressions**"
msgstr ""

#: src/dev/devlog.md:502
msgid ""
"```\n"
"val result = notification match {\n"
"  case Email(sender, _) => {\n"
"    println(sender);\n"
"    \"Email received\"\n"
"  }  // <- block for this case\n"
"  case SMS(number, _) => \"SMS received\";\n"
"}  // <- newline here ends the match expression\n"
"\n"
"println(result); // Next statement\n"
"```"
msgstr ""

#: src/dev/devlog.md:514
msgid "Current Implementation Issues"
msgstr ""

#: src/dev/devlog.md:516
msgid "In the V2 parser:"
msgstr ""

#: src/dev/devlog.md:517
msgid ""
"The `parseBlock` method in `LexerV2.scala` recognizes the closing brace "
"(`RBrace`) as terminating a block but doesn't consider what follows it "
"(newline or not)"
msgstr ""

#: src/dev/devlog.md:518
msgid ""
"This causes inconsistencies between V1 and V2 parsers in how expressions are "
"terminated"
msgstr ""

#: src/dev/devlog.md:519
msgid ""
"The V1 parser considers what comes after the closing brace, but the V2 "
"parser currently doesn't"
msgstr ""

#: src/dev/devlog.md:521
msgid "Proposed Solution"
msgstr ""

#: src/dev/devlog.md:523
msgid ""
"To address this issue while maintaining context-free parsing principles:"
msgstr ""

#: src/dev/devlog.md:525
msgid "**Extend Token State Tracking**"
msgstr ""

#: src/dev/devlog.md:526
msgid "Modify the `LexerState` to track if the previous token was a `RBrace`"
msgstr ""

#: src/dev/devlog.md:527
msgid "Add a helper method like `isAfterClosingBrace()` to check this state"
msgstr ""

#: src/dev/devlog.md:529
msgid "**Update Expression Termination Logic**"
msgstr ""

#: src/dev/devlog.md:530
msgid ""
"In key expression parsing methods, check for the `}\\n` pattern by testing "
"if:"
msgstr ""

#: src/dev/devlog.md:531
msgid "Previous token was `RBrace`"
msgstr ""

#: src/dev/devlog.md:532
msgid "Current token is `Whitespace` containing a newline or is `EOF`"
msgstr ""

#: src/dev/devlog.md:533
msgid ""
"This check should be made in both the `parseExpr` and `parseExprList` methods"
msgstr ""

#: src/dev/devlog.md:535
msgid "**Ensure Uniform Treatment**"
msgstr ""

#: src/dev/devlog.md:536
msgid ""
"Apply the same termination rules consistently across all expression contexts"
msgstr ""

#: src/dev/devlog.md:537
msgid ""
"This maintains the context-free parsing principle while addressing the "
"termination issue"
msgstr ""

#: src/dev/devlog.md:539
msgid "**Add Test Cases**"
msgstr ""

#: src/dev/devlog.md:540
msgid "Create specific test cases for the `}\\n` pattern in different contexts"
msgstr ""

#: src/dev/devlog.md:541
msgid "Verify that both parsers (V1 and V2) handle the pattern identically"
msgstr ""

#: src/dev/devlog.md:543
msgid ""
"This solution preserves the uniform symbol treatment principle while "
"ensuring that the `}\\n` pattern is properly handled as a syntactic "
"terminator where appropriate."
msgstr ""

#: src/dev/devlog.md:545
msgid "Implementation Strategy"
msgstr ""

#: src/dev/devlog.md:547
msgid ""
"Start with smaller, isolated improvements that don't affect the overall "
"architecture"
msgstr ""

#: src/dev/devlog.md:548
msgid "Add comprehensive tests before making significant changes"
msgstr ""

#: src/dev/devlog.md:549
msgid "Update one component fully before moving to the next"
msgstr ""

#: src/dev/devlog.md:550
msgid "Prioritize improvements that enhance maintainability first"
msgstr ""

#: src/dev/devlog.md:551
msgid ""
"Verify each change with existing tests before proceeding to the next "
"improvement"
msgstr ""

#: src/dev/devlog.md:552
msgid "Complete high-priority features like comment preservation"
msgstr ""

#: src/dev/devlog.md:553
msgid "Update documentation to reflect implementation progress"
msgstr ""

#: src/dev/devlog.md:555
msgid "2025-03-09"
msgstr ""

#: src/dev/devlog.md:557
msgid "Fixed OnceCell Concurrent Write Issue"
msgstr ""

#: src/dev/devlog.md:558
msgid ""
"**Root Cause**: Type-level function applications attempted multiple writes "
"to same OnceCell"
msgstr ""

#: src/dev/devlog.md:559
msgid "**Solution**: Added existence check before cell population"
msgstr ""

#: src/dev/devlog.md:561
msgid "`tyck/src/main/scala/chester/tyck/TyckPropagator.scala`"
msgstr ""

#: src/dev/devlog.md:562
msgid "`tyck/src/test/scala/chester/tyck/TypeCellSpec.scala`"
msgstr ""

#: src/dev/devlog.md:563
msgid "**Tests Added**:"
msgstr ""

#: src/dev/devlog.md:564
msgid "Concurrent type-level function application collisions"
msgstr ""

#: src/dev/devlog.md:565
msgid "Stress test with 100 parallel cell writes"
msgstr ""

#: src/dev/devlog.md:567
msgid "2025-03-15"
msgstr ""

#: src/dev/devlog.md:569
msgid "Type System Improvements Completed"
msgstr ""

#: src/dev/devlog.md:571
msgid "**Enhanced Type Structure Reduction in DefaultReducer**"
msgstr ""

#: src/dev/devlog.md:572
msgid "Improved `reduceTypeStructure` method to properly handle:"
msgstr ""

#: src/dev/devlog.md:573
msgid "Union types by recursively reducing their component types"
msgstr ""

#: src/dev/devlog.md:574
msgid "Intersection types with proper reduction"
msgstr ""

#: src/dev/devlog.md:575
msgid ""
"Type-level function applications with recursive reduction for complex result "
"types"
msgstr ""

#: src/dev/devlog.md:576
msgid "Enhanced handling of nested function applications"
msgstr ""

#: src/dev/devlog.md:578
msgid "**Alpha-Equivalence Checking in TyckPropagator**"
msgstr ""

#: src/dev/devlog.md:579
msgid "Enhanced `areAlphaEquivalent` method to:"
msgstr ""

#: src/dev/devlog.md:580
msgid "Properly handle function types with bound variables"
msgstr ""

#: src/dev/devlog.md:581
msgid "Compare union and intersection types correctly"
msgstr ""

#: src/dev/devlog.md:582
msgid "Fall back to regular equality for other cases"
msgstr ""

#: src/dev/devlog.md:583
msgid "Added bound variable tracking in alpha-equivalence"
msgstr ""

#: src/dev/devlog.md:585
msgid "**Enhanced Type Level Comparison**"
msgstr ""

#: src/dev/devlog.md:586
msgid "Improved type level comparison in `tryUnify` method:"
msgstr ""

#: src/dev/devlog.md:587
msgid ""
"Implemented more flexible compatibility rules between different level types"
msgstr ""

#: src/dev/devlog.md:588
msgid "Allow finite level types to be compatible with unrestricted level types"
msgstr ""

#: src/dev/devlog.md:589
msgid "Maintain controlled asymmetric compatibility"
msgstr ""

#: src/dev/devlog.md:591
msgid "**Cell Coverage Mechanisms**"
msgstr ""

#: src/dev/devlog.md:592
msgid "Added dedicated helper method to ensure cell coverage"
msgstr ""

#: src/dev/devlog.md:593
msgid "Implemented self-coverage for union type components"
msgstr ""

#: src/dev/devlog.md:594
msgid "Fixed early returns that left cells uncovered"
msgstr ""

#: src/dev/devlog.md:596
msgid "**TraitCallTerm Implementation**"
msgstr ""

#: src/dev/devlog.md:597
msgid "Added `TraitCallTerm` in Term.scala"
msgstr ""

#: src/dev/devlog.md:598
msgid "Laid groundwork for trait-record subtyping relationships"
msgstr ""

#: src/dev/devlog.md:603 src/dev/devlog.md:940
msgid "`semantic/shared/src/main/scala/chester/reduce/Reducer.scala`"
msgstr ""

#: src/dev/devlog.md:604 src/dev/devlog.md:632 src/dev/devlog.md:941
msgid "`syntax/shared/src/main/scala/chester/syntax/core/Term.scala`"
msgstr ""

#: src/dev/devlog.md:606 src/dev/devlog.md:698
msgid "**Next Steps**:"
msgstr "**ä¸‹ä¸€æ­¥**ï¼š"

#: src/dev/devlog.md:607
msgid "Complete trait-record subtyping implementation"
msgstr ""

#: src/dev/devlog.md:608
msgid "Implement union-to-union subtyping case"
msgstr ""

#: src/dev/devlog.md:609
msgid "Fix remaining cell coverage issues in union-subtype.chester"
msgstr ""

#: src/dev/devlog.md:610
msgid "Add comprehensive test suite for traits and union types"
msgstr ""

#: src/dev/devlog.md:612
msgid "2025-03-16"
msgstr ""

#: src/dev/devlog.md:614
msgid "Term Definition Refactoring"
msgstr ""

#: src/dev/devlog.md:615
msgid "**Implemented Changes**:"
msgstr ""

#: src/dev/devlog.md:616
msgid "**Unified Term Definitions**"
msgstr ""

#: src/dev/devlog.md:617
msgid "Consolidated all Term definitions into a single Term.scala file"
msgstr ""

#: src/dev/devlog.md:618
msgid "Eliminated the separate spec/simple/truffle files"
msgstr ""

#: src/dev/devlog.md:619
msgid "Simplified the codebase by removing the need for converters"
msgstr ""

#: src/dev/devlog.md:621
msgid "**Updated Documentation**"
msgstr ""

#: src/dev/devlog.md:622
msgid "Updated development.md with new Term implementation approach"
msgstr ""

#: src/dev/devlog.md:623
msgid "Updated tyck-improvement-proposal.md to reflect Term changes"
msgstr ""

#: src/dev/devlog.md:624
msgid "Updated type-checking-system.md with current Term usage examples"
msgstr ""

#: src/dev/devlog.md:626
msgid "**Simplified Type System**"
msgstr ""

#: src/dev/devlog.md:627
msgid "Removed the need for trait interfaces with \\*C and \\*F suffixes"
msgstr ""

#: src/dev/devlog.md:628
msgid "Streamlined the inheritance hierarchy"
msgstr ""

#: src/dev/devlog.md:629
msgid "Made the codebase more maintainable with simplified Term definitions"
msgstr ""

#: src/dev/devlog.md:633
msgid "`docs/src/dev/development.md`"
msgstr ""

#: src/dev/devlog.md:634
msgid "`docs/src/dev/tyck-improvement-proposal.md`"
msgstr ""

#: src/dev/devlog.md:635
msgid "`docs/src/dev/type-checking-system.md`"
msgstr ""

#: src/dev/devlog.md:636 src/dev/devlog.md:1548
msgid "`docs/src/dev/devlog.md`"
msgstr ""

#: src/dev/devlog.md:638
msgid "**Files Removed**:"
msgstr ""

#: src/dev/devlog.md:639
msgid "`syntax/shared/src/main/scala/chester/syntax/core/spec/Term.scala`"
msgstr ""

#: src/dev/devlog.md:640
msgid "`syntax/shared/src/main/scala/chester/syntax/core/simple.scala`"
msgstr ""

#: src/dev/devlog.md:641
msgid "`syntax/jvm/src/main/scala/chester/syntax/core/truffle.scala`"
msgstr ""

#: src/dev/devlog.md:642
msgid "`syntax/jvm/src/main/scala/chester/syntax/core/convertToTruffle.scala`"
msgstr ""

#: src/dev/devlog.md:643
msgid ""
"`syntax/shared/src/main/scala/chester/syntax/core/convertToSimple.scala`"
msgstr ""

#: src/dev/devlog.md:646
msgid "Simplified codebase structure"
msgstr ""

#: src/dev/devlog.md:647
msgid "Reduced code duplication"
msgstr ""

#: src/dev/devlog.md:648
msgid "Eliminated need for converters"
msgstr ""

#: src/dev/devlog.md:649
msgid "Made adding new Term types easier and less error-prone"
msgstr ""

#: src/dev/devlog.md:650
msgid "Improved maintainability"
msgstr ""

#: src/dev/devlog.md:652
msgid "2025-03-19"
msgstr ""

#: src/dev/devlog.md:654
msgid "Trait Implementation Completed"
msgstr ""

#: src/dev/devlog.md:656
msgid "**Basic Trait Support**"
msgstr ""

#: src/dev/devlog.md:657
msgid "Added support for empty traits and record extension using `<:` syntax"
msgstr ""

#: src/dev/devlog.md:658
msgid "Implemented trait-record subtyping relation in type system"
msgstr ""

#: src/dev/devlog.md:659
msgid "Added proper trait type representation with `TraitTypeTerm`"
msgstr ""

#: src/dev/devlog.md:660
msgid "Added appropriate error reporting for trait implementation issues"
msgstr ""

#: src/dev/devlog.md:662
msgid "**Modified Elaborater for Trait Handling**"
msgstr ""

#: src/dev/devlog.md:663
msgid ""
"Enhanced `ElaboraterBlock.processTraitStmt` to handle trait bodies properly"
msgstr ""

#: src/dev/devlog.md:664
msgid "Updated `processRecordStmt` to elaborate the `extendsClause` for traits"
msgstr ""

#: src/dev/devlog.md:665
msgid "Added handling for trait extension in subtyping relationships"
msgstr ""

#: src/dev/devlog.md:666
msgid "Implemented trait-to-trait inheritance checks in `TyckPropagator`"
msgstr ""

#: src/dev/devlog.md:668
msgid "**Trait Field Handling**"
msgstr ""

#: src/dev/devlog.md:669
msgid "Added special handling for field declarations within trait bodies"
msgstr ""

#: src/dev/devlog.md:670
msgid "Implemented context tracking to recognize trait processing context"
msgstr ""

#: src/dev/devlog.md:671
msgid "Added `withProcessingType` method to track context in elaboration"
msgstr ""

#: src/dev/devlog.md:672
msgid "Created system to handle trait field requirements (future work)"
msgstr ""

#: src/dev/devlog.md:674
msgid "**Error Types for Traits**"
msgstr ""

#: src/dev/devlog.md:675
msgid "Added `NotATrait` error type for using non-traits in extends clause"
msgstr ""

#: src/dev/devlog.md:676
msgid "Added `NotImplementingTrait` for trait implementation errors"
msgstr ""

#: src/dev/devlog.md:677
msgid "Added `MissingTraitField` for missing required trait fields"
msgstr ""

#: src/dev/devlog.md:678
msgid "Enhanced error reporting for trait-related issues"
msgstr ""

#: src/dev/devlog.md:682 src/dev/devlog.md:942
msgid "`semantic/shared/src/main/scala/chester/tyck/ElaboraterBlock.scala`"
msgstr ""

#: src/dev/devlog.md:683
msgid "`semantic/shared/src/main/scala/chester/tyck/Context.scala`"
msgstr ""

#: src/dev/devlog.md:684
msgid "`semantic/shared/src/main/scala/chester/tyck/Context2.scala`"
msgstr ""

#: src/dev/devlog.md:685
msgid "`tests/tyck/basic-trait.chester`"
msgstr ""

#: src/dev/devlog.md:688
msgid ""
"Created temporary solution for trait field declarations to get basic traits "
"working"
msgstr ""

#: src/dev/devlog.md:689
msgid "Added field for tracking processing context in the `Context` class"
msgstr ""

#: src/dev/devlog.md:690
msgid "Simplified trait checking to focus on basic extension relationship"
msgstr ""

#: src/dev/devlog.md:691
msgid "Used the propagator network for maintaining trait subtyping constraints"
msgstr ""

#: src/dev/devlog.md:693
msgid "**Test Status**:"
msgstr "**æ¸¬è©¦ç‹€æ…‹**ï¼š"

#: src/dev/devlog.md:694
msgid "All tests passing, including the basic-trait test"
msgstr ""

#: src/dev/devlog.md:695
msgid "Added support for more complex traits with field requirements"
msgstr ""

#: src/dev/devlog.md:696
msgid "Test coverage for basic trait extension and trait field access"
msgstr ""

#: src/dev/devlog.md:699
msgid ""
"Enhance trait field checking for complete field requirement verification"
msgstr ""

#: src/dev/devlog.md:700
msgid "Add support for multiple trait inheritance"
msgstr ""

#: src/dev/devlog.md:701
msgid "Implement trait method and default implementations"
msgstr ""

#: src/dev/devlog.md:702
msgid "Add more comprehensive trait test cases"
msgstr ""

#: src/dev/devlog.md:704
msgid "2025-03-22"
msgstr ""

#: src/dev/devlog.md:706
msgid "Pattern Matching Fix Implementation for V2 Parser"
msgstr ""

#: src/dev/devlog.md:708 src/dev/devlog.md:1455
msgid "Problem Analysis"
msgstr ""

#: src/dev/devlog.md:710
msgid ""
"The V2 parser was failing to correctly parse pattern matching expressions "
"with blocks after the `=>` operator. This issue was particularly visible in "
"the `match2` test in `PatternMatchingTest`, which showed a mismatch between "
"expected and actual AST structures."
msgstr ""

#: src/dev/devlog.md:712
msgid "Root Cause"
msgstr ""

#: src/dev/devlog.md:714
msgid "**Missing Context Tracking**:"
msgstr ""

#: src/dev/devlog.md:715
msgid ""
"V1 parser used `ParsingContext(newLineAfterBlockMeansEnds = true)` for "
"contextual parsing"
msgstr ""

#: src/dev/devlog.md:716
msgid ""
"V2 parser lacked this contextual awareness for block termination after "
"newlines"
msgstr ""

#: src/dev/devlog.md:718
msgid "**AST Structure Discrepancies**:"
msgstr ""

#: src/dev/devlog.md:719
msgid "V1 produces consistent OpSeq structures with Identifiers for operators"
msgstr ""

#: src/dev/devlog.md:720
msgid ""
"V2 wasn't properly maintaining this structure in pattern matching contexts"
msgstr ""

#: src/dev/devlog.md:722
msgid "Critical Insight: Uniform Symbol Treatment"
msgstr ""

#: src/dev/devlog.md:724
msgid ""
"The key insight that guided our solution was the need to maintain Chester's "
"uniform symbol treatment:"
msgstr ""

#: src/dev/devlog.md:726
msgid "V1 parser treats ALL operators uniformly with no special cases"
msgstr ""

#: src/dev/devlog.md:727
msgid "`=>` is handled as a plain identifier, not a special operator"
msgstr ""

#: src/dev/devlog.md:728
msgid "Context affects only block termination, not token parsing"
msgstr ""

#: src/dev/devlog.md:730 src/dev/devlog.md:1460
msgid "Implementation Approach"
msgstr "å¯¦ä½œæ–¹æ³•"

#: src/dev/devlog.md:732
msgid "We implemented a 3-step fix that maintains uniform symbol treatment:"
msgstr "æˆ‘å€‘å¯¦ç¾äº†ä¸€å€‹ä¿æŒçµ±ä¸€ç¬¦è™Ÿè™•ç†çš„ä¸‰æ­¥é©Ÿä¿®å¾©æ–¹æ¡ˆï¼š"

#: src/dev/devlog.md:734
msgid "**Added Context to LexerState**:"
msgstr "**å‘ LexerState æ·»åŠ ä¸Šä¸‹æ–‡**ï¼š"

#: src/dev/devlog.md:737
msgid "// Existing fields..."
msgstr ""

#: src/dev/devlog.md:746
msgid "**Updated `checkForRBraceNewlinePattern`**:"
msgstr ""

#: src/dev/devlog.md:747
msgid ""
"Added context-awareness to only terminate expressions in the right context"
msgstr ""

#: src/dev/devlog.md:748
msgid "Maintained the existing newline detection logic"
msgstr ""

#: src/dev/devlog.md:751
msgid "// Only consider }\\n as terminating if we're in the right context"
msgstr ""

#: src/dev/devlog.md:754
msgid "// Rest of existing implementation"
msgstr ""

#: src/dev/devlog.md:759
msgid "**Enabled Context for All Blocks**:"
msgstr ""

#: src/dev/devlog.md:763
msgid "// Rest of implementation using contextState"
msgstr ""

#: src/dev/devlog.md:768
msgid "AST Structure Matching"
msgstr ""

#: src/dev/devlog.md:770
msgid ""
"While the block termination fix allows basic pattern matching to work, there "
"remain differences in the AST structure between V1 and V2 parsers:"
msgstr ""

#: src/dev/devlog.md:772
msgid ""
"```\n"
"=> Diff (- expected, + obtained)\n"
"           meta = None\n"
"-        )\n"
"-      ),\n"
"-      meta = None\n"
"-    ),\n"
"-    OpSeq(\n"
"-      seq = Vector(\n"
"+        ),\n"
"         Identifier(\n"
"               Identifier(\n"
"+                name = \"name\",\n"
"+                meta = None\n"
"+              ),\n"
"+              Identifier(\n"
"                 name = ...,\n"
"                 meta = ...\n"
"-              ),\n"
"-              ...\n"
"+              )\n"
"             ),\n"
"```"
msgstr ""

#: src/dev/devlog.md:796
msgid ""
"These structural differences need to be resolved to ensure full "
"compatibility between parsers. Current theories:"
msgstr ""

#: src/dev/devlog.md:797
msgid "Different handling of nested OpSeq structures"
msgstr ""

#: src/dev/devlog.md:798
msgid "Variance in how block expressions are attached to pattern matches"
msgstr ""

#: src/dev/devlog.md:799
msgid "Potential issues with comment attachment or source positions"
msgstr ""

#: src/dev/devlog.md:801 src/dev/elaboration-system.md:205
msgid "Testing Approach"
msgstr ""

#: src/dev/devlog.md:803
msgid "We're using a phased testing approach:"
msgstr ""

#: src/dev/devlog.md:806
msgid "// Current test approach - used during development"
msgstr ""

#: src/dev/devlog.md:807
msgid "// Tests with V1 parser only"
msgstr ""

#: src/dev/devlog.md:808
msgid "// Goal after full AST compatibility is achieved"
msgstr ""

#: src/dev/devlog.md:810
msgid "// Tests with both V1 and V2 parsers"
msgstr ""

#: src/dev/devlog.md:813
msgid "Current tests in `PatternMatchingTest` show:"
msgstr ""

#: src/dev/devlog.md:814
msgid "All tests using `parseAndCheck` pass with V1 parser"
msgstr ""

#: src/dev/devlog.md:815
msgid ""
"Simple pattern matching (no blocks after `=>`) passes with "
"`parseAndCheckBoth`"
msgstr ""

#: src/dev/devlog.md:816
msgid "Complex pattern matching with blocks still shows AST differences"
msgstr ""

#: src/dev/devlog.md:818 src/dev/devlog.md:928 src/dev/devlog.md:1139
msgid "Next Steps"
msgstr ""

#: src/dev/devlog.md:820
msgid "Investigate exact AST structural differences"
msgstr ""

#: src/dev/devlog.md:821
msgid "Run detailed tests with AST structure dumps"
msgstr ""

#: src/dev/devlog.md:822
msgid "Compare parsing behavior for complex pattern matching"
msgstr ""

#: src/dev/devlog.md:824
msgid "Enhance debug output"
msgstr ""

#: src/dev/devlog.md:825
msgid "Add more detailed logging of AST structures"
msgstr ""

#: src/dev/devlog.md:826
msgid "Enable easier comparison between V1 and V2 outputs"
msgstr ""

#: src/dev/devlog.md:828
msgid "Add targeted fixes for AST compatibility"
msgstr ""

#: src/dev/devlog.md:829
msgid "Maintain uniform symbol treatment"
msgstr ""

#: src/dev/devlog.md:830
msgid "Ensure consistent structure for nested expressions"
msgstr ""

#: src/dev/devlog.md:832
msgid "Update tests to use `parseAndCheckBoth` when fully fixed"
msgstr ""

#: src/dev/devlog.md:833
msgid "Migrate tests incrementally as compatibility issues are resolved"
msgstr ""

#: src/dev/devlog.md:834
msgid "Document any intentional differences"
msgstr ""

#: src/dev/devlog.md:836 src/dev/devlog.md:1491
msgid "Files Modified"
msgstr ""

#: src/dev/devlog.md:839
msgid ""
"This implementation represents significant progress in aligning V1 and V2 "
"parser behaviors while maintaining Chester's core design principles of "
"uniform symbol treatment and context-free parsing."
msgstr ""

#: src/dev/devlog.md:841
msgid "2025-03-23"
msgstr ""

#: src/dev/devlog.md:843
msgid "Comprehensive Type System Improvements Summary"
msgstr ""

#: src/dev/devlog.md:845
msgid ""
"The type system for Chester has undergone significant improvements, "
"particularly in the areas of union types, cell coverage, and trait "
"implementation. Key completed improvements include:"
msgstr ""

#: src/dev/devlog.md:847
msgid "1. Union Type Subtyping Implementation"
msgstr ""

#: src/dev/devlog.md:850
msgid "Implemented three key union subtyping scenarios:"
msgstr ""

#: src/dev/devlog.md:851
msgid ""
"**Union-to-Union Subtyping**: `(A|B) <: (C|D)` with proper component type "
"relationships"
msgstr ""

#: src/dev/devlog.md:852
msgid ""
"**Specific-to-Union Subtyping**: `A <: (B|C)` for cases like passing "
"`Integer` to `Integer|String`"
msgstr ""

#: src/dev/devlog.md:853
msgid ""
"**Union-to-Specific Subtyping**: `(A|B) <: C` for returning a union from a "
"function with specific return type"
msgstr ""

#: src/dev/devlog.md:855
msgid "Added cell coverage for all union types and their components:"
msgstr ""

#: src/dev/devlog.md:862
msgid ""
"// Connect cell to itself to ensure it's covered by at least one propagator"
msgstr ""

#: src/dev/devlog.md:867
msgid "Implemented proper connections in the propagator network:"
msgstr ""

#: src/dev/devlog.md:868
msgid "Added direct connections between union types"
msgstr ""

#: src/dev/devlog.md:869
msgid "Added connections from union types to their components"
msgstr ""

#: src/dev/devlog.md:870
msgid "Ensured all cells are covered by propagators during unification"
msgstr ""

#: src/dev/devlog.md:872
msgid "2. Cell Coverage Mechanisms"
msgstr ""

#: src/dev/devlog.md:874
msgid "**Implemented Solutions**:"
msgstr ""

#: src/dev/devlog.md:875
msgid ""
"Added self-coverage mechanism to prevent \"cells not covered\" errors during "
"zonking"
msgstr ""

#: src/dev/devlog.md:876
msgid ""
"Implemented comprehensive coverage for complex types and their components"
msgstr ""

#: src/dev/devlog.md:877
msgid ""
"Added safeguards to avoid early returns that could leave cells uncovered"
msgstr ""

#: src/dev/devlog.md:878
msgid "Added debugging support for cell coverage issues"
msgstr ""

#: src/dev/devlog.md:880
msgid ""
"This solution systematically addresses cell coverage issues by ensuring "
"every cell in the propagator network is properly connected, which is "
"essential for the constraint-based type checking system to function "
"correctly."
msgstr ""

#: src/dev/devlog.md:882
msgid "3. Enhanced Type Level Comparison"
msgstr ""

#: src/dev/devlog.md:885
msgid ""
"Enhanced how type levels are compared during unification with asymmetric "
"compatibility:"
msgstr ""

#: src/dev/devlog.md:889
msgid "// Finite is compatible with unrestricted"
msgstr ""

#: src/dev/devlog.md:890
msgid "// Unrestricted is not compatible with finite"
msgstr ""

#: src/dev/devlog.md:891
msgid "// For other cases, keep exact equality"
msgstr ""

#: src/dev/devlog.md:895
msgid "Added recursive reduction for type-level function applications"
msgstr ""

#: src/dev/devlog.md:896
msgid "Improved alpha-equivalence checking for dependent types"
msgstr ""

#: src/dev/devlog.md:898
msgid "4. Trait Implementation"
msgstr ""

#: src/dev/devlog.md:900
msgid "**Implemented Features**:"
msgstr ""

#: src/dev/devlog.md:901
msgid "Added basic trait definition and record extension with `<:` syntax"
msgstr ""

#: src/dev/devlog.md:902
msgid "Implemented trait-record subtyping relation in the type system"
msgstr ""

#: src/dev/devlog.md:903
msgid "Added trait type representation with `TraitTypeTerm`"
msgstr ""

#: src/dev/devlog.md:904
msgid "Added trait-to-trait inheritance checking"
msgstr ""

#: src/dev/devlog.md:905
msgid "Implemented context tracking for trait field declarations"
msgstr ""

#: src/dev/devlog.md:906
msgid "Added appropriate error reporting for trait-related issues"
msgstr ""

#: src/dev/devlog.md:908
msgid ""
"The trait implementation provides a solid foundation for more advanced "
"features planned in future work, such as complete field requirement "
"verification, multiple trait inheritance, and trait methods with default "
"implementations."
msgstr ""

#: src/dev/devlog.md:910
msgid "5. Type Structure Reduction Improvements"
msgstr ""

#: src/dev/devlog.md:912
msgid "Enhanced the reducer to properly handle union and intersection types:"
msgstr ""

#: src/dev/devlog.md:920
msgid "// Similar handling for Intersection and function calls"
msgstr ""

#: src/dev/devlog.md:926
msgid ""
"Added special handling for type-level function applications within type "
"comparisons"
msgstr ""

#: src/dev/devlog.md:930
msgid "While significant progress has been made, some areas still need work:"
msgstr ""

#: src/dev/devlog.md:931
msgid "Fix remaining edge cases in union-subtype.chester.todo test"
msgstr ""

#: src/dev/devlog.md:932
msgid ""
"Complete type-level function application enhancement for nested applications"
msgstr ""

#: src/dev/devlog.md:933
msgid "Enhance trait field requirement verification"
msgstr ""

#: src/dev/devlog.md:934
msgid "Implement multiple trait inheritance support"
msgstr ""

#: src/dev/devlog.md:935
msgid "Add trait methods and default implementations"
msgstr ""

#: src/dev/devlog.md:944
msgid "2025-03-24"
msgstr ""

#: src/dev/devlog.md:946
msgid "Parser Improvements Completed"
msgstr ""

#: src/dev/devlog.md:948
msgid "Uniform Operator Handling"
msgstr ""

#: src/dev/devlog.md:949
msgid ""
"**Issue**: Special case handling for the \"=>\" and \"=\" operators in "
"`parseOperator()` method"
msgstr ""

#: src/dev/devlog.md:950 src/dev/devlog.md:967 src/dev/devlog.md:985
#: src/dev/devlog.md:1001 src/dev/devlog.md:1016 src/dev/devlog.md:1056
#: src/dev/devlog.md:1075 src/dev/devlog.md:1093 src/dev/devlog.md:1111
msgid "**Improvement**:"
msgstr ""

#: src/dev/devlog.md:951
msgid "Removed special case handling for the \"=>\" operator"
msgstr ""

#: src/dev/devlog.md:952
msgid "Ensured operators are treated uniformly in the tokenizer"
msgstr ""

#: src/dev/devlog.md:953
msgid "Treated \"=>\" like any other operator in the tokenizing process"
msgstr ""

#: src/dev/devlog.md:955
msgid "More consistent operator handling"
msgstr ""

#: src/dev/devlog.md:956
msgid "Simplified code in the `parseOperator()` method"
msgstr ""

#: src/dev/devlog.md:957
msgid "Reduced special cases, making the code more maintainable"
msgstr ""

#: src/dev/devlog.md:958
msgid ""
"Better alignment with Chester's design principles of uniform symbol treatment"
msgstr ""

#: src/dev/devlog.md:960
msgid ""
"Removed special case code for the \"=>\" operator in the `parseOperator()` "
"method"
msgstr ""

#: src/dev/devlog.md:961
msgid ""
"Modified the method to uniformly parse all operators using a `StringBuilder`"
msgstr ""

#: src/dev/devlog.md:962
msgid "Verified all tests pass with the change, including operator tests"
msgstr ""

#: src/dev/devlog.md:963
msgid "Ensured consistent behavior with the original implementation"
msgstr ""

#: src/dev/devlog.md:965
msgid "LexerV2 Optimization and Refactoring"
msgstr ""

#: src/dev/devlog.md:966
msgid ""
"**Issue**: `LexerV2.scala` had redundant code and a missing state.advance() "
"method reference"
msgstr ""

#: src/dev/devlog.md:968
msgid "Optimized and refactored the code structure for better maintainability"
msgstr ""

#: src/dev/devlog.md:969
msgid "Fixed compilation errors by replacing advance() with state.advance()"
msgstr ""

#: src/dev/devlog.md:970
msgid "Improved modularity by extracting repeated logic into helper methods"
msgstr ""

#: src/dev/devlog.md:971
msgid "Enhanced state management for better consistency across the codebase"
msgstr ""

#: src/dev/devlog.md:973
msgid "Improved maintainability and readability of the lexer code"
msgstr ""

#: src/dev/devlog.md:974
msgid "Fixed compilation errors resulting in more stable code"
msgstr ""

#: src/dev/devlog.md:975
msgid "Better organization of related functionality"
msgstr ""

#: src/dev/devlog.md:976
msgid "Reduced duplication for easier future updates"
msgstr ""

#: src/dev/devlog.md:978
msgid "Replaced direct advance() calls with state.advance() where appropriate"
msgstr ""

#: src/dev/devlog.md:979
msgid "Restructured code for better organization and clarity"
msgstr ""

#: src/dev/devlog.md:980
msgid "Maintained functionality while improving code quality"
msgstr ""

#: src/dev/devlog.md:981
msgid "Ensured all tests continued to pass after changes"
msgstr ""

#: src/dev/devlog.md:983
msgid "Comment Preservation Implementation"
msgstr ""

#: src/dev/devlog.md:984
msgid "**Issue**: V2 parser didn't preserve comments in the AST, unlike V1"
msgstr ""

#: src/dev/devlog.md:986
msgid "Added comment collection and attachment similar to V1 parser"
msgstr ""

#: src/dev/devlog.md:987
msgid "Implemented support for both leading and trailing comments"
msgstr ""

#: src/dev/devlog.md:988
msgid ""
"Created mechanism for handling comments in blocks and at block boundaries"
msgstr ""

#: src/dev/devlog.md:990
msgid "Full feature parity with V1 parser for comment handling"
msgstr ""

#: src/dev/devlog.md:991
msgid "Source code formatting preservation"
msgstr ""

#: src/dev/devlog.md:992
msgid "Support for documentation generation tools"
msgstr ""

#: src/dev/devlog.md:994
msgid "Added methods to collect and categorize comments during parsing"
msgstr ""

#: src/dev/devlog.md:995
msgid "Integrated with ExprMeta and CommentInfo structures"
msgstr ""

#: src/dev/devlog.md:996
msgid "Enhanced expression creation to include comment attachment"
msgstr ""

#: src/dev/devlog.md:997
msgid "Added test cases with various comment placements"
msgstr ""

#: src/dev/devlog.md:999
msgid "TokenExtractors Refinement"
msgstr ""

#: src/dev/devlog.md:1000
msgid ""
"**Issue**: Verbose and redundant token extractors made the code harder to "
"maintain"
msgstr ""

#: src/dev/devlog.md:1002
msgid "Simplified token extractors using a common helper function"
msgstr ""

#: src/dev/devlog.md:1003
msgid "Reduced code duplication for source position extraction"
msgstr ""

#: src/dev/devlog.md:1004
msgid "Made the code more maintainable with concise patterns"
msgstr ""

#: src/dev/devlog.md:1006
msgid "More readable and maintainable token handling"
msgstr ""

#: src/dev/devlog.md:1007
msgid "Less code duplication"
msgstr ""

#: src/dev/devlog.md:1008
msgid "Better abstraction of common patterns"
msgstr ""

#: src/dev/devlog.md:1010
msgid "Created a `posExtract` function to centralize extraction logic"
msgstr ""

#: src/dev/devlog.md:1011
msgid "Refactored individual token extractors to use the helper"
msgstr ""

#: src/dev/devlog.md:1012
msgid "Maintained the same semantics with less code"
msgstr ""

#: src/dev/devlog.md:1014
msgid "Pattern Matching Block Termination Fix"
msgstr ""

#: src/dev/devlog.md:1015
msgid ""
"**Issue**: Inconsistent handling of the `}\\n` pattern between V1 and V2 "
"parsers in pattern matching"
msgstr ""

#: src/dev/devlog.md:1017
msgid "Added context tracking to LexerState"
msgstr ""

#: src/dev/devlog.md:1018
msgid "Implemented context-aware block termination checks"
msgstr ""

#: src/dev/devlog.md:1019
msgid "Enabled context for all blocks uniformly"
msgstr ""

#: src/dev/devlog.md:1021
msgid "Consistent behavior between V1 and V2 parsers"
msgstr ""

#: src/dev/devlog.md:1022
msgid "Maintained uniform symbol treatment principle"
msgstr ""

#: src/dev/devlog.md:1023
msgid "Fixed pattern matching tests"
msgstr ""

#: src/dev/devlog.md:1025
msgid "Added `newLineAfterBlockMeansEnds` flag to LexerState"
msgstr ""

#: src/dev/devlog.md:1026
msgid "Created `withNewLineTermination` helper method"
msgstr ""

#: src/dev/devlog.md:1027
msgid "Updated `checkForRBraceNewlinePattern` to consider context"
msgstr ""

#: src/dev/devlog.md:1028
msgid "Enabled context for all blocks in `parseBlock`"
msgstr ""

#: src/dev/devlog.md:1030
msgid "Previously Completed Improvements"
msgstr ""

#: src/dev/devlog.md:1032
msgid "**Number Parsing Refactoring**"
msgstr ""

#: src/dev/devlog.md:1033
msgid "Extracted specialized methods for different number formats"
msgstr ""

#: src/dev/devlog.md:1034
msgid "Improved error handling for number parsing"
msgstr ""

#: src/dev/devlog.md:1036
msgid "**Enhanced Escape Character Handling**"
msgstr ""

#: src/dev/devlog.md:1037
msgid "Extended support for escape sequences (Unicode, octal, hex)"
msgstr ""

#: src/dev/devlog.md:1038
msgid "Improved error reporting for invalid escape sequences"
msgstr ""

#: src/dev/devlog.md:1040
msgid "**Basic Operator Parsing Clean-Up**"
msgstr ""

#: src/dev/devlog.md:1041
msgid "Extracted comment parsing to a separate method"
msgstr ""

#: src/dev/devlog.md:1042
msgid "Improved structure of `parseOperator()` method"
msgstr ""

#: src/dev/devlog.md:1044
msgid "**Identifier Parsing Correctness**"
msgstr ""

#: src/dev/devlog.md:1045
msgid "Aligned with IdentifierRules for consistent character validation"
msgstr ""

#: src/dev/devlog.md:1046
msgid "Improved handling of Unicode characters and emoji"
msgstr ""

#: src/dev/devlog.md:1048
msgid "**SourcePos Creation Efficiency**"
msgstr ""

#: src/dev/devlog.md:1049
msgid "Implemented caching for UTF-16 offset calculations"
msgstr ""

#: src/dev/devlog.md:1050
msgid "Reduced tokenization time for complex expressions"
msgstr ""

#: src/dev/devlog.md:1052
msgid "Ultra-Compact Tokenizer Implementation"
msgstr ""

#: src/dev/devlog.md:1054
msgid "Tokenizer Size Reduction"
msgstr ""

#: src/dev/devlog.md:1055
msgid "**Issue**: The Tokenizer.scala implementation was longer than necessary"
msgstr ""

#: src/dev/devlog.md:1057
msgid "Dramatically reduced code size (>25% reduction)"
msgstr ""

#: src/dev/devlog.md:1058
msgid "Consolidated similar methods"
msgstr ""

#: src/dev/devlog.md:1059
msgid "Simplified UTF-16 position tracking"
msgstr ""

#: src/dev/devlog.md:1060
msgid "Enhanced token generation pipeline"
msgstr ""

#: src/dev/devlog.md:1062
msgid "More maintainable codebase"
msgstr ""

#: src/dev/devlog.md:1063
msgid "Better readability"
msgstr ""

#: src/dev/devlog.md:1064
msgid "Easier to extend with new token types"
msgstr ""

#: src/dev/devlog.md:1065
msgid "More focused implementation"
msgstr ""

#: src/dev/devlog.md:1067
msgid "Created lookup tables for token types"
msgstr ""

#: src/dev/devlog.md:1068
msgid "Used more functional patterns for token creation"
msgstr ""

#: src/dev/devlog.md:1069
msgid "Streamlined number parsing logic"
msgstr ""

#: src/dev/devlog.md:1070
msgid "Improved string processing with boundary control"
msgstr ""

#: src/dev/devlog.md:1071
msgid "Consolidated position tracking logic"
msgstr ""

#: src/dev/devlog.md:1073
msgid "Functional Style Enhancement"
msgstr ""

#: src/dev/devlog.md:1074
msgid "**Issue**: Imperative style code was harder to maintain"
msgstr ""

#: src/dev/devlog.md:1076
msgid "Added more functional approach to tokenization"
msgstr ""

#: src/dev/devlog.md:1077
msgid "Implemented lazy stream-based token generation"
msgstr ""

#: src/dev/devlog.md:1078
msgid "Created more concise token construction helpers"
msgstr ""

#: src/dev/devlog.md:1079
msgid "Improved pattern matching throughout the codebase"
msgstr ""

#: src/dev/devlog.md:1081
msgid "Code more closely aligned with Scala best practices"
msgstr ""

#: src/dev/devlog.md:1082
msgid "Better composability"
msgstr ""

#: src/dev/devlog.md:1083
msgid "More declarative implementation"
msgstr ""

#: src/dev/devlog.md:1084
msgid "Easier to test individual components"
msgstr ""

#: src/dev/devlog.md:1086
msgid "Used LazyList for token stream generation"
msgstr ""

#: src/dev/devlog.md:1087
msgid "Implemented functional helpers for token creation"
msgstr ""

#: src/dev/devlog.md:1088
msgid "Enhanced pattern matching for token type dispatch"
msgstr ""

#: src/dev/devlog.md:1089
msgid "Added more concise function definitions"
msgstr ""

#: src/dev/devlog.md:1091
msgid "Unicode and Emoji Support Enhancements"
msgstr ""

#: src/dev/devlog.md:1092
msgid ""
"**Issue**: Complex Unicode handling with surrogate pairs needed improvement"
msgstr ""

#: src/dev/devlog.md:1094
msgid "Enhanced support for supplementary characters"
msgstr ""

#: src/dev/devlog.md:1095
msgid "Improved UTF-16 position mapping"
msgstr ""

#: src/dev/devlog.md:1096
msgid "Streamlined surrogate pair handling"
msgstr ""

#: src/dev/devlog.md:1097
msgid "Added more comprehensive emoji support"
msgstr ""

#: src/dev/devlog.md:1099
msgid "Better internationalization support"
msgstr ""

#: src/dev/devlog.md:1100
msgid "Correct handling of modern emoji"
msgstr ""

#: src/dev/devlog.md:1101
msgid "Proper source position mapping for all character types"
msgstr ""

#: src/dev/devlog.md:1102
msgid "More robust parsing for all Unicode scripts"
msgstr ""

#: src/dev/devlog.md:1104
msgid "Used Java's Character API for proper codepoint handling"
msgstr ""

#: src/dev/devlog.md:1105
msgid "Added special cases for supplementary characters"
msgstr ""

#: src/dev/devlog.md:1106
msgid "Improved UTF-16 position calculation"
msgstr ""

#: src/dev/devlog.md:1107
msgid "Enhanced identifier parsing with Unicode support"
msgstr ""

#: src/dev/devlog.md:1109
msgid "Performance Optimization"
msgstr ""

#: src/dev/devlog.md:1110
msgid "**Issue**: Tokenizer performance could be improved"
msgstr ""

#: src/dev/devlog.md:1112
msgid "Reduced memory allocations"
msgstr ""

#: src/dev/devlog.md:1113
msgid "Simplified position tracking"
msgstr ""

#: src/dev/devlog.md:1114
msgid "Optimized string building"
msgstr ""

#: src/dev/devlog.md:1115
msgid "Enhanced token stream generation"
msgstr ""

#: src/dev/devlog.md:1117
msgid "Faster tokenization"
msgstr ""

#: src/dev/devlog.md:1118
msgid "Lower memory usage"
msgstr ""

#: src/dev/devlog.md:1119
msgid "Better scalability for large files"
msgstr ""

#: src/dev/devlog.md:1120
msgid "More efficient pipeline"
msgstr ""

#: src/dev/devlog.md:1122
msgid "Used StringBuilder for efficient string concatenation"
msgstr ""

#: src/dev/devlog.md:1123
msgid "Implemented smarter UTF-16 position tracking"
msgstr ""

#: src/dev/devlog.md:1124
msgid "Optimized character and token processing"
msgstr ""

#: src/dev/devlog.md:1125
msgid "Enhanced error detection and handling"
msgstr ""

#: src/dev/devlog.md:1127
msgid "Updated Feature Coverage"
msgstr ""

#: src/dev/devlog.md:1129
msgid "The V2 parser now has complete implementations for:"
msgstr ""

#: src/dev/devlog.md:1130
msgid "Basic literals (integers, floating-point numbers)"
msgstr ""

#: src/dev/devlog.md:1131
msgid "Function calls (including nested and with type parameters)"
msgstr ""

#: src/dev/devlog.md:1132
msgid "Pattern matching (with correct block termination)"
msgstr ""

#: src/dev/devlog.md:1133
msgid "Operator sequences (with uniform treatment)"
msgstr ""

#: src/dev/devlog.md:1134
msgid "Generic type parameters (including complex and nested generics)"
msgstr ""

#: src/dev/devlog.md:1135
msgid "Block arguments"
msgstr ""

#: src/dev/devlog.md:1136
msgid "Lists with mixed types"
msgstr ""

#: src/dev/devlog.md:1137
msgid "Comment preservation (leading and trailing)"
msgstr ""

#: src/dev/devlog.md:1140
msgid "Focus is now shifting to:"
msgstr ""

#: src/dev/devlog.md:1141
msgid "Object expressions implementation"
msgstr ""

#: src/dev/devlog.md:1142
msgid "Source maps support"
msgstr ""

#: src/dev/devlog.md:1143
msgid "Error recovery mechanisms"
msgstr ""

#: src/dev/devlog.md:1144
msgid "Migrating remaining V1-only tests"
msgstr ""

#: src/dev/devlog.md:1146 src/dev/devlog.md:1291
msgid "2025-03-25"
msgstr ""

#: src/dev/devlog.md:1148
msgid "Union Type Subtyping Implementation Details"
msgstr ""

#: src/dev/devlog.md:1150
msgid ""
"Following the comprehensive type system improvements from March 23rd, here "
"are the detailed implementation specifics for union type subtyping and cell "
"coverage mechanisms:"
msgstr ""

#: src/dev/devlog.md:1152
msgid "1. Enhanced Union Subtyping Implementation"
msgstr ""

#: src/dev/devlog.md:1154
msgid ""
"The implementation now fully supports all three union subtyping scenarios "
"with proper propagator connections:"
msgstr ""

#: src/dev/devlog.md:1156
msgid "**Union-to-Union Subtyping** (`A|B <: C|D`):"
msgstr ""

#: src/dev/devlog.md:1158
msgid ""
"// For each type in RHS union, at least one type in LHS union must accept it"
msgstr ""

#: src/dev/devlog.md:1168
msgid "**Specific-to-Union Subtyping** (`A <: B|C`):"
msgstr ""

#: src/dev/devlog.md:1170
msgid "// Delegate to the connectSpecificAndUnion helper method"
msgstr ""

#: src/dev/devlog.md:1180
msgid "**Union-to-Specific Subtyping** (`A|B <: C`):"
msgstr ""

#: src/dev/devlog.md:1182
msgid ""
"// A union can be used where a specific type is expected if all components "
"match it"
msgstr ""

#: src/dev/devlog.md:1186
msgid "2. Advanced Cell Coverage Mechanisms"
msgstr ""

#: src/dev/devlog.md:1188
msgid ""
"To solve the \"cells not covered by any propagator\" error, several key "
"mechanisms have been implemented:"
msgstr ""

#: src/dev/devlog.md:1190
msgid "**EnsureCellCoverage Propagator**:"
msgstr ""

#: src/dev/devlog.md:1200
msgid "// Always succeeds - just ensures the cell is covered"
msgstr ""

#: src/dev/devlog.md:1208
msgid "**Helper Methods for Union Component Coverage**:"
msgstr ""

#: src/dev/devlog.md:1210
msgid "// Ensures coverage for all cells within a union type"
msgstr ""

#: src/dev/devlog.md:1223
msgid "**Connection of Union Types to Components**:"
msgstr ""

#: src/dev/devlog.md:1225
msgid "// Creates UnionOf propagator to connect union cell to its components"
msgstr ""

#: src/dev/devlog.md:1235
msgid "**Special Handling for Function Calls**:"
msgstr ""

#: src/dev/devlog.md:1237
msgid "// Recursively processes function calls to ensure cell coverage"
msgstr ""

#: src/dev/devlog.md:1250
msgid "// No further processing for simple terms"
msgstr ""

#: src/dev/devlog.md:1255
msgid "3. Improvements to Type Compatibility Checking"
msgstr ""

#: src/dev/devlog.md:1257
msgid ""
"The implementation now includes enhanced compatibility checks for working "
"with union types:"
msgstr ""

#: src/dev/devlog.md:1259
msgid "**Union Compatibility Methods**:"
msgstr ""

#: src/dev/devlog.md:1260
msgid ""
"Added specialized methods for checking compatibility between union and non-"
"union types"
msgstr ""

#: src/dev/devlog.md:1261
msgid "Implemented bidirectional compatibility checking for union types"
msgstr ""

#: src/dev/devlog.md:1262
msgid "Enhanced subtyping relationships with proper union type handling"
msgstr ""

#: src/dev/devlog.md:1264
msgid "**Special Handling for Literal Types with Unions**:"
msgstr ""

#: src/dev/devlog.md:1265
msgid "Added special case handling for integer literals with union types"
msgstr ""

#: src/dev/devlog.md:1266
msgid ""
"Implemented type compatibility checking for literals against union types"
msgstr ""

#: src/dev/devlog.md:1267
msgid "Added support for both direct and indirect type matching"
msgstr ""

#: src/dev/devlog.md:1269
msgid ""
"These improvements ensure that union types work seamlessly with the rest of "
"the type system, including with literals, function types, and in both "
"widening and narrowing contexts."
msgstr ""

#: src/dev/devlog.md:1271
msgid "4. Type-Level Function Application Enhancements"
msgstr ""

#: src/dev/devlog.md:1273
msgid ""
"The implementation includes improvements to how type-level function "
"applications are handled:"
msgstr ""

#: src/dev/devlog.md:1275
msgid "**Reduction for Type Checking**:"
msgstr ""

#: src/dev/devlog.md:1276
msgid "Added specialized reduction mode for type-level expressions"
msgstr ""

#: src/dev/devlog.md:1277
msgid "Implemented proper context handling for type equality checking"
msgstr ""

#: src/dev/devlog.md:1278
msgid "Enhanced type comparison with reduction-based equality"
msgstr ""

#: src/dev/devlog.md:1280
msgid "**Term Reference Resolution**:"
msgstr ""

#: src/dev/devlog.md:1281
msgid "Added recursive reference resolution for deeper type analysis"
msgstr ""

#: src/dev/devlog.md:1282
msgid "Implemented proper handling of nested references in types"
msgstr ""

#: src/dev/devlog.md:1283
msgid "Enhanced type comparison with fully resolved references"
msgstr ""

#: src/dev/devlog.md:1285
msgid ""
"All these implementations follow the design principles outlined in the type "
"improvement proposal, ensuring that:"
msgstr ""

#: src/dev/devlog.md:1286
msgid "Original terms are preserved in elaborated results"
msgstr ""

#: src/dev/devlog.md:1287
msgid "Reduction is only used for type checking, not for elaboration"
msgstr ""

#: src/dev/devlog.md:1288
msgid "Union types behave correctly in all subtyping scenarios"
msgstr ""

#: src/dev/devlog.md:1289
msgid ""
"Cell coverage is guaranteed to prevent \"cells not covered by propagator\" "
"errors"
msgstr ""

#: src/dev/devlog.md:1293
msgid "Enhanced Trait Implementation Details"
msgstr ""

#: src/dev/devlog.md:1295
msgid ""
"Building on the basic trait implementation completed on March 19, several "
"enhancements have been added to the trait system:"
msgstr ""

#: src/dev/devlog.md:1297
msgid "1. Advanced Trait Context Tracking"
msgstr ""

#: src/dev/devlog.md:1299
msgid ""
"To properly handle trait fields and method declarations, the Context system "
"now includes special tracking for the current declaration context:"
msgstr ""

#: src/dev/devlog.md:1303
msgid "// Existing fields"
msgstr ""

#: src/dev/devlog.md:1304
msgid "\"\" // Can be \"trait\", \"record\", etc."
msgstr ""

#: src/dev/devlog.md:1306
msgid ""
"// Helper method to create a new context with a specific processing type"
msgstr ""

#: src/dev/devlog.md:1309
msgid "// Rest of the implementation"
msgstr ""

#: src/dev/devlog.md:1313
msgid ""
"This allows the elaborator to recognize when it's processing fields inside a "
"trait definition versus a record definition, which affects how those fields "
"are processed."
msgstr ""

#: src/dev/devlog.md:1315
msgid "2. Trait Statement Elaboration"
msgstr ""

#: src/dev/devlog.md:1317
msgid ""
"The `processTraitStmt` method now fully handles trait declarations with "
"proper context management:"
msgstr ""

#: src/dev/devlog.md:1332
msgid "// Process extends clause if present"
msgstr ""

#: src/dev/devlog.md:1344 src/dev/devlog.md:1445
msgid "// Other cases"
msgstr ""

#: src/dev/devlog.md:1346
msgid "// More processing"
msgstr ""

#: src/dev/devlog.md:1349
msgid "// Elaborate the body within a trait-specific context"
msgstr ""

#: src/dev/devlog.md:1351
msgid "\"trait\""
msgstr ""

#: src/dev/devlog.md:1354
msgid "// Create and return the TraitStmtTerm"
msgstr ""

#: src/dev/devlog.md:1367
msgid ""
"The key improvement is using `ctx.withProcessingType(\"trait\")` to indicate "
"when we're elaborating a trait body."
msgstr ""

#: src/dev/devlog.md:1369
msgid "3. Record-Trait Subtyping Verification"
msgstr ""

#: src/dev/devlog.md:1371
msgid ""
"The trait implementation now includes proper record-trait subtyping "
"relationship verification:"
msgstr ""

#: src/dev/devlog.md:1383
msgid "// Check for a direct extension relationship"
msgstr ""

#: src/dev/devlog.md:1391
msgid "// Report error if record doesn't explicitly extend the trait"
msgstr ""

#: src/dev/devlog.md:1400
msgid "4. Trait-Trait Extension Checking"
msgstr ""

#: src/dev/devlog.md:1402
msgid "Similarly, trait-trait inheritance is now properly verified:"
msgstr ""

#: src/dev/devlog.md:1414
msgid "// Check if they're the same trait (reflexivity)"
msgstr ""

#: src/dev/devlog.md:1419
msgid "// Check direct parent"
msgstr ""

#: src/dev/devlog.md:1430
msgid "5. Special Handling in Type Unification"
msgstr ""

#: src/dev/devlog.md:1432
msgid ""
"The trait subtyping rules are now properly integrated into the type "
"unification system:"
msgstr ""

#: src/dev/devlog.md:1435
msgid "// In unify method"
msgstr ""

#: src/dev/devlog.md:1437
msgid "// Record implementing trait (structural subtyping)"
msgstr ""

#: src/dev/devlog.md:1441
msgid "// Trait extending trait (structural subtyping)"
msgstr ""

#: src/dev/devlog.md:1449
msgid ""
"These implementations provide a solid foundation for trait-based programming "
"in Chester, with support for basic field requirements and type inheritance. "
"Future work will focus on more advanced trait features like method "
"implementations, default values, and multiple inheritance."
msgstr ""

#: src/dev/devlog.md:1451
msgid "2025-04-01"
msgstr ""

#: src/dev/devlog.md:1453
msgid "Generalized Block Termination Implementation for V2 Parser"
msgstr ""

#: src/dev/devlog.md:1456
msgid ""
"**Issue**: V2 parser needed a general solution for the `}\\n` pattern "
"without special-casing keywords"
msgstr ""

#: src/dev/devlog.md:1457
msgid ""
"**Core Principle Violation**: Previous implementation relied on checking if "
"expressions were Blocks"
msgstr ""

#: src/dev/devlog.md:1458
msgid ""
"**Design Requirement**: Need context-free parsing with uniform token pattern "
"detection"
msgstr ""

#: src/dev/devlog.md:1461
msgid ""
"**Solution Strategy**: Implemented a generalized `}\\n` pattern detection "
"mechanism"
msgstr ""

#: src/dev/devlog.md:1462
msgid "**Key Changes**:"
msgstr ""

#: src/dev/devlog.md:1463
msgid ""
"Modified `checkForRBraceNewlinePattern` to check previous token instead of "
"expression type"
msgstr ""

#: src/dev/devlog.md:1464
msgid "Added support for EOF as an implicit newline terminator"
msgstr ""

#: src/dev/devlog.md:1465
msgid "Renamed `separateCaseStatements` to `processMixedStatements`"
msgstr ""

#: src/dev/devlog.md:1466
msgid "Made statement splitting logic more general while preserving behavior"
msgstr ""

#: src/dev/devlog.md:1468
msgid "Technical Implementation"
msgstr ""

#: src/dev/devlog.md:1469
msgid "**Token Pattern Detection**:"
msgstr ""

#: src/dev/devlog.md:1470
msgid "Check if previous token was a closing brace (RBrace)"
msgstr ""

#: src/dev/devlog.md:1471
msgid "Verify if current token is whitespace containing a newline or EOF"
msgstr ""

#: src/dev/devlog.md:1472
msgid "Apply termination rules based purely on syntax, not semantics"
msgstr ""

#: src/dev/devlog.md:1473
msgid "**Statement Processing**:"
msgstr ""

#: src/dev/devlog.md:1474
msgid "Preserve existing multiple statements without changes"
msgstr ""

#: src/dev/devlog.md:1475
msgid ""
"Split single OpSeq statements when they contain multiple logical statements"
msgstr ""

#: src/dev/devlog.md:1476
msgid ""
"Detect natural statement boundaries at certain identifiers like \"case\""
msgstr ""

#: src/dev/devlog.md:1477
msgid "Maintain consistent behavior with V1 parser"
msgstr ""

#: src/dev/devlog.md:1479
msgid "Benefits"
msgstr ""

#: src/dev/devlog.md:1480
msgid "**Alignment with Core Principles**:"
msgstr ""

#: src/dev/devlog.md:1481
msgid "Maintains strict context-free parsing"
msgstr ""

#: src/dev/devlog.md:1482
msgid "Treats all blocks uniformly"
msgstr ""

#: src/dev/devlog.md:1483
msgid "Applies consistent rules for expression termination"
msgstr ""

#: src/dev/devlog.md:1484
msgid "Better separation between syntax and semantics"
msgstr ""

#: src/dev/devlog.md:1485
msgid "**Technical Improvements**:"
msgstr ""

#: src/dev/devlog.md:1486
msgid "More maintainable parser with fewer special cases"
msgstr ""

#: src/dev/devlog.md:1487
msgid "Simplified codebase with clearer termination rules"
msgstr ""

#: src/dev/devlog.md:1488
msgid "Better alignment between V1 and V2 parsers"
msgstr ""

#: src/dev/devlog.md:1489
msgid "All relevant tests now pass with identical behavior"
msgstr ""

#: src/dev/devlog.md:1494
msgid ""
"This implementation properly adheres to Chester's core parsing principles by "
"treating all `}\\n` patterns uniformly, regardless of their context."
msgstr ""

#: src/dev/devlog.md:1496
msgid "2025-04-02"
msgstr ""

#: src/dev/devlog.md:1498
msgid "Fixed Outdated Pattern in Reducer.scala"
msgstr ""

#: src/dev/devlog.md:1500
msgid ""
"During a comprehensive code review to align with Chester's term architecture "
"principles:"
msgstr ""

#: src/dev/devlog.md:1502
msgid ""
"**Issue Identified**: Found outdated pattern in `reduceStandard` method in "
"`Reducer.scala` that was using explicit type casting with pattern matching "
"on `StmtTerm`"
msgstr ""

#: src/dev/devlog.md:1503
msgid ""
"**Fix Applied**: Updated the code to maintain type safety while avoiding "
"unnecessary pattern matching"
msgstr ""

#: src/dev/devlog.md:1504
msgid "**Before**:"
msgstr ""

#: src/dev/devlog.md:1510
msgid "**After**:"
msgstr ""

#: src/dev/devlog.md:1513
msgid "// Keep the type information while reducing"
msgstr ""

#: src/dev/devlog.md:1517
msgid ""
"**Alignment with Principles**: The solution balances Chester's design "
"principles with type safety requirements by:"
msgstr ""

#: src/dev/devlog.md:1518
msgid "Avoiding pattern matching with `*C` and `*T` suffix traits"
msgstr ""

#: src/dev/devlog.md:1519
msgid "Keeping necessary type casts for type safety"
msgstr ""

#: src/dev/devlog.md:1520
msgid "Using more direct and readable code"
msgstr ""

#: src/dev/devlog.md:1522
msgid "More consistent codebase that follows established design principles"
msgstr ""

#: src/dev/devlog.md:1523
msgid "Type-safe implementation"
msgstr ""

#: src/dev/devlog.md:1524
msgid "Clearer intent with inline comments"
msgstr ""

#: src/dev/devlog.md:1525
msgid "Better alignment with the unified Term definition approach"
msgstr ""

#: src/dev/devlog.md:1527
msgid "2025-04-27"
msgstr ""

#: src/dev/devlog.md:1529
msgid "LexerV2 Refactoring and Plan Cleanup"
msgstr ""

#: src/dev/devlog.md:1531
msgid "**LexerV2 Code Refinements**:"
msgstr ""

#: src/dev/devlog.md:1532
msgid ""
"Introduced `peek` method in `LexerState` to look ahead without consuming "
"tokens, simplifying logic."
msgstr ""

#: src/dev/devlog.md:1533
msgid ""
"Refactored `parseAtom` to use `peek` for cleaner handling of empty objects "
"`{}` vs block/object start."
msgstr ""

#: src/dev/devlog.md:1534
msgid ""
"Introduced `withModifiedState` helper in `LexerState` to encapsulate "
"temporary state changes (like `newLineAfterBlockMeansEnds`), simplifying "
"`parseBlock`."
msgstr ""

#: src/dev/devlog.md:1535
msgid "Minor cleanup in `expectedError` using f-interpolators."
msgstr ""

#: src/dev/devlog.md:1537
msgid "**Parser Plan Update**:"
msgstr "**è§£æå™¨è¨ˆåŠƒæ›´æ–°**ï¼š"

#: src/dev/devlog.md:1538
msgid ""
"Marked Phase 2 (Advanced Features) as fully complete in `parser-plan.md`."
msgstr ""

#: src/dev/devlog.md:1539
msgid ""
"Marked \"V1/V2 Semantic Consistency\", \"Object Expressions\", and \"Block "
"Termination\" priorities as complete."
msgstr ""

#: src/dev/devlog.md:1540
msgid ""
"Updated `parser-implementation.md` to reflect completed status of these "
"features."
msgstr ""

#: src/dev/devlog.md:1541
msgid ""
"Consolidated completed tasks from planning/implementation docs into this "
"devlog entry."
msgstr ""

#: src/dev/devlog.md:1542
msgid ""
"Current focus remains on Phase 3: Error Handling (Recovery, Messages, Debug "
"Info), Source Maps, Test Migration, and Performance Optimization."
msgstr ""

#: src/dev/devlog.md:1546
msgid "`docs/src/dev/parser-plan.md`"
msgstr ""

#: src/dev/devlog.md:1547
msgid "`docs/src/dev/parser-implementation.md`"
msgstr ""

#: src/dev/effects-implementation-plan.md:3 src/dev/effects-system.md:3
#: src/dev/tyck-improvement-proposal.md:3 src/dev/type-checking-system.md:3
#: src/dev/union_types_progress.md:3
msgid "NOTE THAT THIS DOCUMENT IS OUTDATED AS RELEVANT CODE IS BEING REWRITTEN"
msgstr ""

#: src/dev/effects-implementation-plan.md:5
msgid "Goal"
msgstr ""

#: src/dev/effects-implementation-plan.md:7
msgid ""
"Enable type checking for the simplest effects example in `tests/tyck/effects-"
"basic.chester.todo` by implementing the necessary compiler components for "
"the built-in effects system."
msgstr ""

#: src/dev/effects-implementation-plan.md:9 src/dev/typescript-backend.md:14
msgid "Current Status"
msgstr ""

#: src/dev/effects-implementation-plan.md:11
msgid ""
"We have a basic effects syntax design specified in `docs/src/dev/effects-"
"system.md`"
msgstr ""

#: src/dev/effects-implementation-plan.md:12
msgid ""
"A simple test file `tests/tyck/effects-basic.chester.todo` exists but "
"doesn't type check yet"
msgstr ""

#: src/dev/effects-implementation-plan.md:13
msgid "Some of the infrastructure for effects already exists in the codebase"
msgstr ""

#: src/dev/effects-implementation-plan.md:15 src/dev/typescript-backend.md:20
msgid "Implementation Tasks"
msgstr ""

#: src/dev/effects-implementation-plan.md:17
msgid "1. Parser Enhancements"
msgstr ""

#: src/dev/effects-implementation-plan.md:19
msgid ""
"Add parsing support for the `/` effect annotation syntax in function types"
msgstr ""

#: src/dev/effects-implementation-plan.md:20
msgid "Parse built-in effect names (`IO`, `State`, etc.) as identifiers"
msgstr ""

#: src/dev/effects-implementation-plan.md:21
msgid "Parse effect combinations using the `&` operator"
msgstr ""

#: src/dev/effects-implementation-plan.md:22
msgid ""
"Generate AST nodes that correctly represent effects in function signatures"
msgstr ""

#: src/dev/effects-implementation-plan.md:25
msgid "// Example parser implementation:"
msgstr ""

#: src/dev/effects-implementation-plan.md:27
msgid "// Parse function signature..."
msgstr ""

#: src/dev/effects-implementation-plan.md:29
msgid "// Check for effect annotation"
msgstr ""

#: src/dev/effects-implementation-plan.md:30
msgid "\"/\""
msgstr ""

#: src/dev/effects-implementation-plan.md:40
msgid "2. Built-in Effects Registry"
msgstr ""

#: src/dev/effects-implementation-plan.md:42
msgid "Define a registry for built-in effect types"
msgstr ""

#: src/dev/effects-implementation-plan.md:43
msgid "Implement recognition of built-in effects like `IO` and `State`"
msgstr ""

#: src/dev/effects-implementation-plan.md:44
msgid ""
"Add a mechanism to validate that effect identifiers refer to built-in effects"
msgstr ""

#: src/dev/effects-implementation-plan.md:47
msgid "// Example registry:"
msgstr ""

#: src/dev/effects-implementation-plan.md:49
msgid "\"IO\""
msgstr ""

#: src/dev/effects-implementation-plan.md:50
msgid "\"State\""
msgstr ""

#: src/dev/effects-implementation-plan.md:51
msgid "\"Exception\""
msgstr ""

#: src/dev/effects-implementation-plan.md:52
msgid "\"NonTermination\""
msgstr ""

#: src/dev/effects-implementation-plan.md:60
msgid "3. Type Representation"
msgstr ""

#: src/dev/effects-implementation-plan.md:62
msgid "Enhance the `Effects` class to handle built-in effects"
msgstr ""

#: src/dev/effects-implementation-plan.md:63
msgid "Implement function type representation that includes effects"
msgstr ""

#: src/dev/effects-implementation-plan.md:64
msgid "Support effect combinations (union of effects)"
msgstr ""

#: src/dev/effects-implementation-plan.md:67
msgid "// Example Effects class:"
msgstr ""

#: src/dev/effects-implementation-plan.md:77
msgid "4. Type Checking"
msgstr ""

#: src/dev/effects-implementation-plan.md:79
msgid "Implement effect checking during function definition"
msgstr ""

#: src/dev/effects-implementation-plan.md:80
msgid "Verify that function bodies only use effects that are declared"
msgstr ""

#: src/dev/effects-implementation-plan.md:81
msgid "Track effect requirements in the function call chain"
msgstr ""

#: src/dev/effects-implementation-plan.md:82
msgid "Ensure effects are properly propagated from callee to caller"
msgstr ""

#: src/dev/effects-implementation-plan.md:85
msgid "// Example type checker for function calls:"
msgstr ""

#: src/dev/effects-implementation-plan.md:89
msgid "// Check argument types..."
msgstr ""

#: src/dev/effects-implementation-plan.md:91
msgid "// Extract function effects"
msgstr ""

#: src/dev/effects-implementation-plan.md:94
msgid "// Ensure the current context allows these effects"
msgstr ""

#: src/dev/effects-implementation-plan.md:97
msgid "// Return function's return type with effects"
msgstr ""

#: src/dev/effects-implementation-plan.md:102
msgid "5. Effect Propagation"
msgstr ""

#: src/dev/effects-implementation-plan.md:104
msgid "Implement a mechanism to accumulate effects from function calls"
msgstr ""

#: src/dev/effects-implementation-plan.md:105
msgid "Ensure effects are propagated up the call chain"
msgstr ""

#: src/dev/effects-implementation-plan.md:106
msgid "Handle effect combinations correctly"
msgstr ""

#: src/dev/effects-implementation-plan.md:109
msgid "// Example propagation:"
msgstr ""

#: src/dev/effects-implementation-plan.md:111
msgid "// Combine effects from caller and callee"
msgstr ""

#: src/dev/effects-implementation-plan.md:116
msgid "6. Error Reporting"
msgstr ""

#: src/dev/effects-implementation-plan.md:118
msgid "Add clear error messages for effect-related type errors"
msgstr ""

#: src/dev/effects-implementation-plan.md:119
msgid "Report when a function uses unauthorized effects"
msgstr ""

#: src/dev/effects-implementation-plan.md:120
msgid "Report when effect types are invalid or unknown"
msgstr ""

#: src/dev/effects-implementation-plan.md:123
msgid "// Example error generation:"
msgstr ""

#: src/dev/effects-implementation-plan.md:125
msgid ""
"s\"Function uses effect '$effect' but it is not declared in the function "
"signature\""
msgstr ""

#: src/dev/effects-implementation-plan.md:130
msgid "Implementation Order"
msgstr ""

#: src/dev/effects-implementation-plan.md:132
msgid "**First Phase: Basic Type Representation**"
msgstr ""

#: src/dev/effects-implementation-plan.md:133
msgid "Enhance the AST and type system to represent effects"
msgstr ""

#: src/dev/effects-implementation-plan.md:134
msgid "Implement the built-in effects registry"
msgstr ""

#: src/dev/effects-implementation-plan.md:135
msgid "Add effect annotations to function types"
msgstr ""

#: src/dev/effects-implementation-plan.md:137
msgid "**Second Phase: Parser Integration**"
msgstr ""

#: src/dev/effects-implementation-plan.md:138
msgid "Update the parser to handle effect annotations"
msgstr ""

#: src/dev/effects-implementation-plan.md:139
msgid "Parse effect combinations"
msgstr ""

#: src/dev/effects-implementation-plan.md:140
msgid "Generate correct AST nodes with effects"
msgstr ""

#: src/dev/effects-implementation-plan.md:142
msgid "**Third Phase: Type Checking**"
msgstr ""

#: src/dev/effects-implementation-plan.md:143
msgid "Implement basic effect checking for function bodies"
msgstr ""

#: src/dev/effects-implementation-plan.md:144
msgid "Add effect validation in function calls"
msgstr ""

#: src/dev/effects-implementation-plan.md:145
msgid "Ensure effects are correctly propagated"
msgstr ""

#: src/dev/effects-implementation-plan.md:147
msgid "**Fourth Phase: Error Handling**"
msgstr ""

#: src/dev/effects-implementation-plan.md:148
msgid "Add descriptive error messages"
msgstr ""

#: src/dev/effects-implementation-plan.md:149
msgid "Implement suggestions for fixing effect-related errors"
msgstr ""

#: src/dev/effects-implementation-plan.md:151
msgid "**Fifth Phase: Testing**"
msgstr ""

#: src/dev/effects-implementation-plan.md:152
msgid "Convert the `.todo` test to a regular test file"
msgstr ""

#: src/dev/effects-implementation-plan.md:153
msgid "Add additional tests for more complex effect scenarios"
msgstr ""

#: src/dev/effects-implementation-plan.md:154
msgid "Verify compatibility with existing code"
msgstr ""

#: src/dev/effects-implementation-plan.md:156
msgid "Timeline"
msgstr ""

#: src/dev/effects-implementation-plan.md:158
msgid "Days 1-2: First Phase implementation"
msgstr ""

#: src/dev/effects-implementation-plan.md:159
msgid "Days 3-4: Second Phase implementation"
msgstr ""

#: src/dev/effects-implementation-plan.md:160
msgid "Days 5-7: Third Phase implementation"
msgstr ""

#: src/dev/effects-implementation-plan.md:161
msgid "Days 8-9: Fourth Phase implementation"
msgstr ""

#: src/dev/effects-implementation-plan.md:162
msgid "Day 10: Testing and refinement"
msgstr ""

#: src/dev/effects-implementation-plan.md:164
#: src/dev/tyck-improvement-proposal.md:103 src/dev/typescript-backend.md:183
msgid "Success Criteria"
msgstr ""

#: src/dev/effects-implementation-plan.md:166
msgid ""
"The `tests/tyck/effects-basic.chester.todo` file can be renamed to `tests/"
"tyck/effects-basic.chester` and passes type checking"
msgstr ""

#: src/dev/effects-implementation-plan.md:167
msgid "The type checker correctly enforces effect constraints"
msgstr ""

#: src/dev/effects-implementation-plan.md:168
msgid "Effect propagation works as expected in nested function calls"
msgstr ""

#: src/dev/effects-implementation-plan.md:169
msgid "Pure functions don't require effect annotations"
msgstr ""

#: src/dev/effects-implementation-plan.md:170
msgid "Clear error messages are provided for effect-related type errors"
msgstr ""

#: src/dev/effects-system.md:7
msgid ""
"The Chester language includes a built-in effect system that enables tracking "
"and controlling side effects. This document outlines the design and "
"implementation of this system."
msgstr ""

#: src/dev/effects-system.md:9
msgid "Core Concepts"
msgstr ""

#: src/dev/effects-system.md:11
msgid ""
"**Effect**: A built-in type in the language that represents a capability to "
"perform a specific kind of operation."
msgstr ""

#: src/dev/effects-system.md:12
msgid ""
"**Effect Values**: Built-in values of type `Effect` (e.g., `IO`, `State`, "
"`Exception`)."
msgstr ""

#: src/dev/effects-system.md:13
msgid ""
"**Effect Requirements**: Functions declare which effects they may use with "
"the `/ Effect` syntax."
msgstr ""

#: src/dev/effects-system.md:14
msgid ""
"**Effect Propagation**: Effect requirements automatically propagate up the "
"call chain."
msgstr ""

#: src/dev/effects-system.md:15
msgid ""
"**Pure Functions**: Functions without effect annotations are pure (no side "
"effects)."
msgstr ""

#: src/dev/effects-system.md:17
msgid "Syntax"
msgstr ""

#: src/dev/effects-system.md:19
msgid "Function Declaration with Effects"
msgstr ""

#: src/dev/effects-system.md:26
msgid ""
"```\n"
"// Function with IO effect\n"
"def print(message: String): Unit / IO = ()\n"
"\n"
"// Function with multiple effects\n"
"def readAndWrite(): String / (IO & State) = { ... }\n"
"```"
msgstr ""

#: src/dev/effects-system.md:34
msgid "Effect Propagation"
msgstr ""

#: src/dev/effects-system.md:36
msgid ""
"When a function calls another function with effects, those effects must be "
"declared in the caller's signature:"
msgstr ""

#: src/dev/effects-system.md:38
msgid ""
"```\n"
"def hello(): Unit / IO = {\n"
"  print(\"Hello\")  // print has IO effect, so hello needs IO too\n"
"}\n"
"```"
msgstr ""

#: src/dev/effects-system.md:44
msgid "Built-in Effects"
msgstr ""

#: src/dev/effects-system.md:46
msgid "The language provides several built-in effects:"
msgstr ""

#: src/dev/effects-system.md:48
msgid "**IO**: Input/output operations (file I/O, console I/O, etc.)"
msgstr ""

#: src/dev/effects-system.md:49
msgid "**State**: Mutable state operations"
msgstr ""

#: src/dev/effects-system.md:50
msgid "**Exception**: Operations that may throw exceptions"
msgstr ""

#: src/dev/effects-system.md:51
msgid "**NonTermination**: Operations that may not terminate"
msgstr ""

#: src/dev/effects-system.md:53
msgid "Implementation Notes"
msgstr ""

#: src/dev/effects-system.md:55
msgid "The effect system is implemented through:"
msgstr ""

#: src/dev/effects-system.md:57
msgid ""
"**Type Checking**: Functions are verified to declare all effects they use."
msgstr ""

#: src/dev/effects-system.md:58
msgid ""
"**Effect Propagation**: Functions automatically require any effects used by "
"functions they call."
msgstr ""

#: src/dev/effects-system.md:59
msgid ""
"**Effect Handling**: The runtime system ensures effects are properly handled."
msgstr ""

#: src/dev/effects-system.md:61
msgid "Future Extensions"
msgstr ""

#: src/dev/effects-system.md:63
msgid "Potential future extensions include:"
msgstr ""

#: src/dev/effects-system.md:65
msgid "User-defined effects"
msgstr ""

#: src/dev/effects-system.md:66
msgid "Effect polymorphism"
msgstr ""

#: src/dev/effects-system.md:67
msgid "Effect inference"
msgstr ""

#: src/dev/effects-system.md:68
msgid "Effect handlers for controlling effect execution"
msgstr ""

#: src/dev/effects-system.md:70
msgid "Example Usage"
msgstr ""

#: src/dev/effects-system.md:72
msgid ""
"```\n"
"// Function with an IO effect requirement\n"
"def print(message: String): Unit / IO = ()\n"
"\n"
"// This function automatically inherits the IO effect\n"
"def hello(): Unit / IO = {\n"
"  print(\"Hello\")\n"
"}\n"
"\n"
"// Pure function with no effects\n"
"def pure(): Integer = 123\n"
"```"
msgstr ""

#: src/dev/elaboration-system.md:3
msgid "Introduction"
msgstr ""

#: src/dev/elaboration-system.md:5
msgid "Chester features two elaboration systems for type checking:"
msgstr ""

#: src/dev/elaboration-system.md:7
msgid ""
"**Original Type Checking Logic (`chester.tyck`)**: The constraint-based type "
"checking system using propagator networks"
msgstr ""

#: src/dev/elaboration-system.md:8
msgid ""
"**New Elaboration System (`chester.elab`)**: A modernized, more modular "
"approach to elaboration with a dedicated solver"
msgstr ""

#: src/dev/elaboration-system.md:10
msgid ""
"This document explains both systems, their differences, and provides "
"guidance on how to work with the new elaboration system."
msgstr ""

#: src/dev/elaboration-system.md:12
#, fuzzy
msgid "Architectural Comparison"
msgstr "æ¶æ§‹"

#: src/dev/elaboration-system.md:14
msgid "Original System (`chester.tyck`)"
msgstr ""

#: src/dev/elaboration-system.md:16
msgid ""
"The original type checking system is built around propagator networks with "
"cells and constraints:"
msgstr ""

#: src/dev/elaboration-system.md:18
msgid "Uses `TyckPropagator` for constraint propagation"
msgstr ""

#: src/dev/elaboration-system.md:19
msgid ""
"Has a monolithic `Elaborater` class with specialized components "
"(`ElaboraterBlock`, `ElaboraterFunction`, etc.)"
msgstr ""

#: src/dev/elaboration-system.md:20
msgid "Relies on `CellId` references for tracking types"
msgstr ""

#: src/dev/elaboration-system.md:21
msgid "Uses a stateful approach for tracking and resolving constraints"
msgstr ""

#: src/dev/elaboration-system.md:23
msgid "New System (`chester.elab`)"
msgstr ""

#: src/dev/elaboration-system.md:25
msgid ""
"The new elaboration system takes a fundamentally different approach to type "
"checking:"
msgstr ""

#: src/dev/elaboration-system.md:27
msgid ""
"**Constraint-based Solver**: Uses a dedicated solver architecture for "
"tracking and resolving typing constraints"
msgstr ""

#: src/dev/elaboration-system.md:28
msgid ""
"**Modular Handler System**: Each elaboration concern is handled by a "
"dedicated, composable handler"
msgstr ""

#: src/dev/elaboration-system.md:29
msgid ""
"**Cell-based Representation**: Uses cells to represent type variables and "
"constraints in a more structured way"
msgstr ""

#: src/dev/elaboration-system.md:30
msgid ""
"**More Precise Types**: Infers more specific types (e.g., `IntTerm` instead "
"of `IntegerTerm`)"
msgstr ""

#: src/dev/elaboration-system.md:31
msgid ""
"**Handler-driven Architecture**: Components like `BlockElabHandler` and "
"`ListOfHandler` encapsulate specific elaboration logic"
msgstr ""

#: src/dev/elaboration-system.md:33
msgid "Key Components of the New System"
msgstr ""

#: src/dev/elaboration-system.md:35
msgid "1. Core Interfaces"
msgstr ""

#: src/dev/elaboration-system.md:37
msgid ""
"**Elab Trait** (`Elab.scala`) serves as the primary interface for "
"elaboration operations. It provides three key methods:"
msgstr ""

#: src/dev/elaboration-system.md:39
msgid ""
"`elab`: Elaborates an expression against a given type, returning a cell "
"containing the elaborated term"
msgstr ""

#: src/dev/elaboration-system.md:40
msgid ""
"`infer`: Infers both the term and type for an expression, returning them as "
"a pair"
msgstr ""

#: src/dev/elaboration-system.md:41
msgid ""
"`inferType`: Specializes in type-checking expressions that should be types "
"themselves"
msgstr ""

#: src/dev/elaboration-system.md:43
msgid ""
"All these methods require appropriate context, effects tracking, and solver "
"operations to function."
msgstr ""

#: src/dev/elaboration-system.md:45
msgid ""
"**DefaultElab Implementation** provides the core elaboration logic for "
"different expression types. It uses pattern matching to handle different "
"kinds of expressions, dispatching each to an appropriate constraint handler:"
msgstr ""

#: src/dev/elaboration-system.md:47
msgid "Integer literals are handled by the IntegerLit constraint"
msgstr ""

#: src/dev/elaboration-system.md:48
msgid "String literals are handled by the StringLit constraint"
msgstr ""

#: src/dev/elaboration-system.md:49
msgid "List expressions are handled by the ListOf constraint"
msgstr ""

#: src/dev/elaboration-system.md:50
msgid "Blocks are handled by the BlockElab constraint"
msgstr ""

#: src/dev/elaboration-system.md:52
msgid ""
"For each expression type, a corresponding constraint is created and passed "
"to the solver through SolverOps."
msgstr ""

#: src/dev/elaboration-system.md:54
msgid "2. Entry Point"
msgstr ""

#: src/dev/elaboration-system.md:56
msgid ""
"**DefaultElaborator** (`Elaborator.scala`) is the main entry point for using "
"the new elaboration system. It's configured with:"
msgstr ""

#: src/dev/elaboration-system.md:58
msgid "A default Elab implementation (DefaultElabImpl)"
msgstr ""

#: src/dev/elaboration-system.md:59
msgid "A SolverFactory (ConcurrentSolverFactory)"
msgstr ""

#: src/dev/elaboration-system.md:60
msgid "A handler configuration (DefaultSolverConf)"
msgstr ""

#: src/dev/elaboration-system.md:62
msgid ""
"This setup provides the `inferPure()` method that is used by the REPL and "
"tests as the primary entry point for type checking expressions."
msgstr ""

#: src/dev/elaboration-system.md:64
msgid "3. Constraint Handlers"
msgstr ""

#: src/dev/elaboration-system.md:66
msgid ""
"The system uses a handler-based architecture where each type of constraint "
"has a dedicated handler:"
msgstr ""

#: src/dev/elaboration-system.md:68
msgid ""
"**Literal Handlers**: `IntegerLitHandler`, `StringLitHandler`, "
"`SymbolLitHandler`"
msgstr ""

#: src/dev/elaboration-system.md:69
msgid "**Block Handler**: `BlockElabHandler` for elaborating code blocks"
msgstr ""

#: src/dev/elaboration-system.md:70
msgid "**List Handler**: `ListOfHandler` for list expressions"
msgstr ""

#: src/dev/elaboration-system.md:71
msgid ""
"**Unification Handlers**: `UnifyHandler`, `UnifyMultipleHandler` for type "
"compatibility"
msgstr ""

#: src/dev/elaboration-system.md:72
msgid ""
"**Type Handlers**: `IsTypeHandler` for type checking, `SimplifyUnionHandler` "
"for union types"
msgstr ""

#: src/dev/elaboration-system.md:74
msgid ""
"Each handler implements the `Handler` trait with a `run` method that "
"processes a specific type of constraint."
msgstr ""

#: src/dev/elaboration-system.md:76
msgid "4. Operations Interface"
msgstr ""

#: src/dev/elaboration-system.md:78
msgid ""
"**ElabOps** (`ElabOps.scala`) provides operations for error reporting and "
"semantic collection:"
msgstr ""

#: src/dev/elaboration-system.md:82
msgid "// Delegated reporter methods"
msgstr ""

#: src/dev/elaboration-system.md:87 src/dev/type-checking-system.md:171
msgid "Current Implementation Status"
msgstr ""

#: src/dev/elaboration-system.md:89
msgid "Features Supported"
msgstr ""

#: src/dev/elaboration-system.md:91
msgid "The new elaboration system currently supports:"
msgstr ""

#: src/dev/elaboration-system.md:93
msgid "Basic literals (integers, strings, symbols)"
msgstr ""

#: src/dev/elaboration-system.md:94
msgid ""
"Lists (including heterogeneous and nested lists with correct union typing)"
msgstr ""

#: src/dev/elaboration-system.md:95
msgid "Code blocks with statements and expressions"
msgstr ""

#: src/dev/elaboration-system.md:96
msgid "Type unification and compatibility checking"
msgstr ""

#: src/dev/elaboration-system.md:97
msgid "Pure expressions (without effects)"
msgstr ""

#: src/dev/elaboration-system.md:99
#, fuzzy
msgid "REPL Integration"
msgstr "Web API é›†æˆ"

#: src/dev/elaboration-system.md:101
msgid ""
"The REPL engine now uses the new elaboration system by default, as seen in "
"`REPLEngine.scala`:"
msgstr ""

#: src/dev/elaboration-system.md:103
msgid ""
"The REPL implementation includes a toggle (`useNewElab`) set to true by "
"default that allows switching between the old and new elaboration systems. "
"When enabled, the typeCheck method creates a reporter and ElabOps, then "
"calls DefaultElaborator.inferPure() to type check expressions. The results "
"are wrapped in a TyckResult0 object to maintain compatibility with the old "
"system's result format."
msgstr ""

#: src/dev/elaboration-system.md:105
msgid ""
"This implementation allows seamless switching between the old and new "
"elaboration systems, with the new system as the default."
msgstr ""

#: src/dev/elaboration-system.md:107
msgid "Test Coverage"
msgstr ""

#: src/dev/elaboration-system.md:109
msgid ""
"Test coverage for the new system is implemented in "
"`ElabLiteralAndListTest.scala`, which verifies:"
msgstr ""

#: src/dev/elaboration-system.md:111
msgid "**Integer literals**: Correctly elaborated to `IntTerm` with `IntType`"
msgstr ""

#: src/dev/elaboration-system.md:112
msgid ""
"**Heterogeneous lists**: Elaborated to `ListTerm` with a union type for "
"elements"
msgstr ""

#: src/dev/elaboration-system.md:113
msgid "**Empty lists**: Properly typed as `ListTerm[NothingType]`"
msgstr ""

#: src/dev/elaboration-system.md:114
msgid ""
"**Nested lists**: Correctly handle nested list structures and their type "
"relationships"
msgstr ""

#: src/dev/elaboration-system.md:116
msgid "These tests demonstrate the system's ability to:"
msgstr ""

#: src/dev/elaboration-system.md:117
msgid ""
"Infer precise types (using `IntTerm` instead of the more general "
"`IntegerTerm`)"
msgstr ""

#: src/dev/elaboration-system.md:118
msgid "Handle heterogeneity through proper union type creation"
msgstr ""

#: src/dev/elaboration-system.md:119
msgid "Maintain correct type relationships in nested structures"
msgstr ""

#: src/dev/elaboration-system.md:121
msgid "Using the New Elaboration System"
msgstr ""

#: src/dev/elaboration-system.md:123
msgid "Basic Usage"
msgstr ""

#: src/dev/elaboration-system.md:125
msgid ""
"The following example shows how to use the new elaboration system to type "
"check an expression:"
msgstr ""

#: src/dev/elaboration-system.md:127
msgid "To use the new elaboration system, you'll need to:"
msgstr ""

#: src/dev/elaboration-system.md:129
msgid "Parse an expression using ChesterReaderV2 or another parser"
msgstr ""

#: src/dev/elaboration-system.md:130
msgid "Create a reporter and ElabOps for error collection"
msgstr ""

#: src/dev/elaboration-system.md:131
msgid ""
"Call DefaultElaborator.inferPure() to obtain a Judge containing the "
"elaborated term and type"
msgstr ""

#: src/dev/elaboration-system.md:132
msgid "Check for errors and access the elaborated term and inferred type"
msgstr ""

#: src/dev/elaboration-system.md:134
msgid ""
"This process will properly handle parsing and type checking of various "
"expressions, including heterogeneous lists that will be typed with "
"appropriate union types."
msgstr ""

#: src/dev/elaboration-system.md:136
msgid "Extending the System with New Expression Types"
msgstr ""

#: src/dev/elaboration-system.md:138
msgid ""
"To add support for a new expression type, you need to follow these steps:"
msgstr ""

#: src/dev/elaboration-system.md:140 src/dev/elaboration-system.md:144
msgid "1. Define a Constraint Kind"
msgstr ""

#: src/dev/elaboration-system.md:142
msgid "Create a Kind object for your constraint:"
msgstr ""

#: src/dev/elaboration-system.md:146
msgid ""
"Create a Kind object in the `chester.elab` package that defines the type of "
"your constraint. This serves as a unique identifier for your constraint type "
"in the system."
msgstr ""

#: src/dev/elaboration-system.md:148
msgid "2. Create a Constraint Class"
msgstr ""

#: src/dev/elaboration-system.md:150
msgid "Define a constraint class for your expression type that takes:"
msgstr ""

#: src/dev/elaboration-system.md:151
msgid "Your expression type as a parameter"
msgstr ""

#: src/dev/elaboration-system.md:152
msgid "The target type cell"
msgstr ""

#: src/dev/elaboration-system.md:153
msgid "Required implicit parameters (effects, elab, ops, ctx)"
msgstr ""

#: src/dev/elaboration-system.md:155
msgid ""
"The constraint class should extend the `Constraint` abstract class with your "
"Kind."
msgstr ""

#: src/dev/elaboration-system.md:157
msgid "3. Implement a Handler"
msgstr ""

#: src/dev/elaboration-system.md:159
msgid ""
"Create a handler that processes your constraint by implementing the "
"`Handler` trait. The handler needs to:"
msgstr ""

#: src/dev/elaboration-system.md:160
msgid "Override the `run` method to implement the elaboration logic"
msgstr ""

#: src/dev/elaboration-system.md:161
msgid "Create appropriate cells for your results"
msgstr ""

#: src/dev/elaboration-system.md:162
msgid "Connect your result to the target type using constraints like `Unify`"
msgstr ""

#: src/dev/elaboration-system.md:163
msgid ""
"Optionally implement defaulting behavior for when type information is "
"incomplete"
msgstr ""

#: src/dev/elaboration-system.md:165
msgid "4. Register the Handler"
msgstr ""

#: src/dev/elaboration-system.md:167
msgid ""
"Add your handler to `DefaultSolverConf.scala` so the system knows how to "
"process your constraint. This involves adding your handler to the list of "
"handlers in the `DefaultSolverConf` value."
msgstr ""

#: src/dev/elaboration-system.md:169
msgid "5. Update DefaultElab"
msgstr ""

#: src/dev/elaboration-system.md:171
msgid ""
"Finally, extend the `elab()` method in `DefaultElab` to handle your "
"expression type by adding a pattern matching case for your expression type "
"that calls your constraint."
msgstr ""

#: src/dev/elaboration-system.md:173
msgid "Example: Adding Support for Boolean Literals"
msgstr ""

#: src/dev/elaboration-system.md:175
msgid ""
"A practical example would be adding support for boolean literals, which "
"would require:"
msgstr ""

#: src/dev/elaboration-system.md:177
msgid "Defining a `BooleanLit` Kind to identify the boolean literal constraint"
msgstr ""

#: src/dev/elaboration-system.md:178
msgid ""
"Creating a `BooleanLit` constraint class that takes a BooleanLiteral "
"expression and target type"
msgstr ""

#: src/dev/elaboration-system.md:179
msgid "Implementing a `BooleanLitHandler` that:"
msgstr ""

#: src/dev/elaboration-system.md:180
msgid "Creates a BooleanTerm with the appropriate value"
msgstr ""

#: src/dev/elaboration-system.md:181
msgid "Adds a cell containing that term"
msgstr ""

#: src/dev/elaboration-system.md:182
msgid "Creates a BooleanType cell"
msgstr ""

#: src/dev/elaboration-system.md:183
msgid "Unifies the target type with the boolean type"
msgstr ""

#: src/dev/elaboration-system.md:184
msgid "Connects the boolean term to the output cell"
msgstr ""

#: src/dev/elaboration-system.md:185
msgid "Registering the handler in DefaultSolverConf"
msgstr ""

#: src/dev/elaboration-system.md:186
msgid ""
"Adding a case for BooleanLiteral expressions in the DefaultElab.elab method"
msgstr ""

#: src/dev/elaboration-system.md:188
msgid "Transition Guidelines"
msgstr ""

#: src/dev/elaboration-system.md:190
msgid ""
"While both systems currently coexist, the development focus is transitioning "
"to the new `chester.elab` system. Follow these guidelines when working with "
"the codebase:"
msgstr ""

#: src/dev/elaboration-system.md:192
#, fuzzy
msgid "For New Development"
msgstr "é–‹ç™¼æ—¥èªŒ"

#: src/dev/elaboration-system.md:194
msgid ""
"Use `DefaultElaborator.inferPure()` as the primary entry point for new "
"typechecking code"
msgstr ""

#: src/dev/elaboration-system.md:195
msgid "Implement new features and extensions in the `chester.elab` package"
msgstr ""

#: src/dev/elaboration-system.md:196
msgid "Add handlers for new expression types following the pattern shown above"
msgstr ""

#: src/dev/elaboration-system.md:197
msgid "Write tests specifically against the new elaboration system"
msgstr ""

#: src/dev/elaboration-system.md:199
msgid "For Maintenance of Existing Code"
msgstr ""

#: src/dev/elaboration-system.md:201
msgid ""
"When fixing bugs in the existing `chester.tyck` system, consider if the fix "
"should also be applied to `chester.elab`"
msgstr ""

#: src/dev/elaboration-system.md:202
msgid ""
"Document cross-references between equivalent functionality in both systems"
msgstr ""

#: src/dev/elaboration-system.md:203
msgid "Gradually migrate test cases to support the new system"
msgstr ""

#: src/dev/elaboration-system.md:207
msgid ""
"Use `ElabLiteralAndListTest.scala` as a reference for test structure and "
"pattern"
msgstr ""

#: src/dev/elaboration-system.md:208
msgid "Create test cases that work with both systems to ensure compatibility"
msgstr ""

#: src/dev/elaboration-system.md:209
msgid ""
"The REPL's toggle (`useNewElab`) allows easy switching between systems for "
"comparison"
msgstr ""

#: src/dev/elaboration-system.md:211 src/guide/statements.md:85
msgid "Best Practices"
msgstr ""

#: src/dev/elaboration-system.md:213
msgid "1. Preserve Original Terms"
msgstr ""

#: src/dev/elaboration-system.md:215
msgid ""
"Consistent with the existing guidelines for the original elaboration system:"
msgstr ""

#: src/dev/elaboration-system.md:217
msgid "The elaboration system should preserve the original structure of terms"
msgstr ""

#: src/dev/elaboration-system.md:218
msgid "Avoid reduction during elaboration"
msgstr ""

#: src/dev/elaboration-system.md:219
msgid "Keep source code structure intact in elaborated results"
msgstr ""

#: src/dev/elaboration-system.md:222
msgid "2. Error Reporting"
msgstr ""

#: src/dev/elaboration-system.md:224
msgid "Use the `ElabOps` reporter for consistent error messages"
msgstr ""

#: src/dev/elaboration-system.md:225
msgid "Provide detailed type information in error messages"
msgstr ""

#: src/dev/elaboration-system.md:226
msgid "Match the error format of the original system for consistency"
msgstr ""

#: src/dev/elaboration-system.md:227
msgid "Include source position information when available"
msgstr ""

#: src/dev/elaboration-system.md:228
msgid "Use internationalized messages (with `t\"\"` string templates)"
msgstr ""

#: src/dev/elaboration-system.md:230
msgid "3. Testing"
msgstr ""

#: src/dev/elaboration-system.md:233
msgid "Verify the structure of elaborated terms"
msgstr ""

#: src/dev/elaboration-system.md:234
msgid ""
"Check inferred types carefully, especially for complex cases like union types"
msgstr ""

#: src/dev/elaboration-system.md:235
msgid "Test with heterogeneous data to verify union type handling"
msgstr ""

#: src/dev/elaboration-system.md:236
msgid ""
"Ensure tests cover edge cases like empty collections and nested structures"
msgstr ""

#: src/dev/elaboration-system.md:238
msgid "Current Limitations and Future Work"
msgstr ""

#: src/dev/elaboration-system.md:240
msgid ""
"The new elaboration system is still under development and doesn't yet "
"support the full range of Chester language features. Current limitations "
"include:"
msgstr ""

#: src/dev/elaboration-system.md:242
msgid "Limited support for complex expressions and statements"
msgstr ""

#: src/dev/elaboration-system.md:243
msgid ""
"Incomplete handling of advanced type features like traits and interfaces"
msgstr ""

#: src/dev/elaboration-system.md:244
msgid "Partial support for effects system"
msgstr ""

#: src/dev/elaboration-system.md:245
msgid "Incomplete support for pattern matching"
msgstr ""

#: src/dev/elaboration-system.md:247
msgid "Future development should focus on:"
msgstr ""

#: src/dev/elaboration-system.md:249
msgid "Extending the system to support all Chester language features"
msgstr ""

#: src/dev/elaboration-system.md:250
msgid "Improving error messages and diagnostics"
msgstr ""

#: src/dev/elaboration-system.md:251
msgid "Enhancing performance and error recovery"
msgstr ""

#: src/dev/elaboration-system.md:252
msgid "Eventually replacing the original system entirely"
msgstr ""

#: src/dev/intellij-idea.md:3
msgid "use nightly update of scala plugin"
msgstr ""

#: src/dev/intellij-idea.md:4
msgid "use \"Compiler\" for scala2"
msgstr ""

#: src/dev/intellij-idea.md:5
msgid ""
"in sbt settings, Create separate modules for main and test; Use separate "
"compiler output paths"
msgstr ""

#: src/dev/js2py.md:5
msgid ""
"This document outlines the process for converting JavaScript code generated "
"from Scala.js into Python-accessible modules. This approach allows Chester "
"functionality written in Scala to be available within Python environments."
msgstr ""

#: src/dev/js2py.md:7
msgid "Process Flow"
msgstr ""

#: src/dev/js2py.md:9
msgid "The conversion process follows these steps:"
msgstr ""

#: src/dev/js2py.md:11
msgid ""
"**Compile Scala.js to JavaScript** - Use the `sbt jsForPython/fastLinkJS` "
"SBT task to compile Scala code to JavaScript"
msgstr ""

#: src/dev/js2py.md:12
msgid ""
"**Bundle with Rollup** - Use Rollup to combine the generated JavaScript with "
"any needed glue code into a single module"
msgstr ""

#: src/dev/js2py.md:13
msgid ""
"**Convert to Python** - Use js2py to make the JavaScript functionality "
"accessible from Python"
msgstr ""

#: src/dev/js2py.md:15
msgid "Step-by-Step Implementation"
msgstr ""

#: src/dev/js2py.md:17
msgid "1. Scala.js Compilation"
msgstr ""

#: src/dev/js2py.md:19
msgid ""
"The `jsForPython` project in `build.sbt` is configured to compile Scala code "
"to ECMAScript modules with the `.mjs` extension:"
msgstr ""

#: src/dev/js2py.md:25 src/dev/js2py.md:28
msgid "\"js-for-python\""
msgstr ""

#: src/dev/js2py.md:33
msgid "// Enable ECMAScript module output."
msgstr ""

#: src/dev/js2py.md:35
msgid "// Use .mjs extension."
msgstr ""

#: src/dev/js2py.md:36
msgid "\"%s.mjs\""
msgstr ""

#: src/dev/js2py.md:41
msgid "To compile the Scala.js code, run:"
msgstr ""

#: src/dev/js2py.md:47
msgid ""
"This produces JavaScript files in the `js-for-python/js/target/` directory."
msgstr ""

#: src/dev/js2py.md:49
msgid "2. Bundling with Rollup"
msgstr ""

#: src/dev/js2py.md:51
msgid ""
"The `rollup.config.mjs` file defines how to bundle the generated JavaScript:"
msgstr ""

#: src/dev/js2py.md:54
msgid "'@rollup/plugin-node-resolve'"
msgstr ""

#: src/dev/js2py.md:55
msgid "'@rollup/plugin-commonjs'"
msgstr ""

#: src/dev/js2py.md:56
msgid "'@rollup/plugin-babel'"
msgstr ""

#: src/dev/js2py.md:59
msgid "'index.js'"
msgstr ""

#: src/dev/js2py.md:61
msgid "'dist/bundle.js'"
msgstr ""

#: src/dev/js2py.md:62
msgid "'cjs'"
msgstr ""

#: src/dev/js2py.md:71
msgid "'bundled'"
msgstr ""

#: src/dev/js2py.md:73
msgid "'@babel/preset-env'"
msgstr ""

#: src/dev/js2py.md:73
msgid "\"18\""
msgstr ""

#: src/dev/js2py.md:80
msgid ""
"To bundle the JavaScript code, create an `index.js` file that imports the "
"generated `.mjs` files, then run:"
msgstr ""

#: src/dev/js2py.md:83
msgid "# Only need to run this once to install dependencies\n"
msgstr ""

#: src/dev/js2py.md:87
msgid "This produces a bundled JavaScript file at `dist/bundle.js`."
msgstr ""

#: src/dev/js2py.md:89
msgid "3. JavaScript to Python with js2py"
msgstr ""

#: src/dev/js2py.md:91
msgid "Python Environment Setup with UV"
msgstr ""

#: src/dev/js2py.md:93
msgid ""
"We use the `uv` package manager for Python dependencies due to its improved "
"performance and reliability. All Python-related work should be done in the "
"`js-for-python` directory, which contains a `.python-version` file "
"specifying Python 3.11:"
msgstr ""

#: src/dev/js2py.md:96
msgid "# Navigate to the js-for-python directory\n"
msgstr ""

#: src/dev/js2py.md:98
msgid "# Create a virtual environment with the specified Python version\n"
msgstr ""

#: src/dev/js2py.md:101
msgid "# Activate the virtual environment\n"
msgstr ""

#: src/dev/js2py.md:103
msgid ""
"# On Unix/macOS\n"
"# or\n"
"# .venv\\Scripts\\activate  # On Windows\n"
msgstr ""

#: src/dev/js2py.md:106
msgid "# Install dependencies using requirements.txt\n"
msgstr ""

#: src/dev/js2py.md:111
msgid "Automated Translation Process"
msgstr ""

#: src/dev/js2py.md:113
msgid ""
"The `js2py_build.py` script in the `python` directory automates the "
"translation process:"
msgstr ""

#: src/dev/js2py.md:116
msgid "# Usage\n"
msgstr ""

#: src/dev/js2py.md:117
msgid "# Translates the bundle.js to chester.py\n"
msgstr ""

#: src/dev/js2py.md:118
msgid "# Forces retranslation even if chester.py exists\n"
msgstr ""

#: src/dev/js2py.md:121
msgid "This script performs the following steps:"
msgstr ""

#: src/dev/js2py.md:122
msgid "Verifies the bundle.js file exists"
msgstr ""

#: src/dev/js2py.md:123
msgid "Preprocesses the JavaScript to handle js2py compatibility issues"
msgstr ""

#: src/dev/js2py.md:124
msgid "Translates the JavaScript to Python using js2py.translate_file()"
msgstr ""

#: src/dev/js2py.md:125
msgid "Outputs the result to `python/chester.py`"
msgstr ""

#: src/dev/js2py.md:127
msgid "Usage Guidelines"
msgstr ""

#: src/dev/js2py.md:129
msgid "Expose Scala functions using `@JSExportTopLevel`:"
msgstr ""

#: src/dev/js2py.md:131
msgid "\"functionName\""
msgstr ""

#: src/dev/js2py.md:133
msgid "// Implementation"
msgstr ""

#: src/dev/js2py.md:137
msgid "Bundle only what's necessary to minimize final bundle size."
msgstr ""

#: src/dev/js2py.md:139
msgid "Access the Chester functionality from Python:"
msgstr ""

#: src/dev/js2py.md:142
msgid "# Import the Chester module\n"
msgstr ""

#: src/dev/js2py.md:145
msgid "# Access functions via the Chester global object\n"
msgstr ""

#: src/dev/js2py.md:149
msgid "Testing"
msgstr ""

#: src/dev/js2py.md:151
msgid "The project includes two test scripts:"
msgstr ""

#: src/dev/js2py.md:153
msgid "1. test_js2py.py"
msgstr ""

#: src/dev/js2py.md:155
msgid "Tests basic js2py functionality with a simple JavaScript example. It:"
msgstr ""

#: src/dev/js2py.md:156
msgid "Translates example.js to Python"
msgstr ""

#: src/dev/js2py.md:157
msgid "Imports and uses the translated module"
msgstr ""

#: src/dev/js2py.md:158
msgid "Tests various js2py features"
msgstr ""

#: src/dev/js2py.md:159
msgid "Tests the Chester JS -> Python bridge"
msgstr ""

#: src/dev/js2py.md:161 src/dev/js2py.md:173
msgid "To run:"
msgstr ""

#: src/dev/js2py.md:166
msgid "2. test_chester.py"
msgstr ""

#: src/dev/js2py.md:168
msgid "Tests the generated Chester Python module. It:"
msgstr ""

#: src/dev/js2py.md:169
msgid "Checks if the chester.py module exists and generates it if needed"
msgstr ""

#: src/dev/js2py.md:170
msgid "Imports the module and tests available functions"
msgstr ""

#: src/dev/js2py.md:171
msgid "Reports any errors"
msgstr ""

#: src/dev/js2py.md:178
msgid "Complete Testing Sequence"
msgstr ""

#: src/dev/js2py.md:180
msgid "To fully test the JavaScript to Python conversion:"
msgstr ""

#: src/dev/js2py.md:183
msgid "# 1. Compile Scala.js to JavaScript\n"
msgstr ""

#: src/dev/js2py.md:185
msgid "# 2. Bundle with Rollup\n"
msgstr ""

#: src/dev/js2py.md:188
msgid "# First time only\n"
msgstr ""

#: src/dev/js2py.md:190
msgid "# 3. Set up Python environment\n"
msgstr ""

#: src/dev/js2py.md:195
msgid "# 4. Test js2py and simple JavaScript\n"
msgstr ""

#: src/dev/js2py.md:198
msgid "# 5. Test Chester module\n"
msgstr ""

#: src/dev/js2py.md:203
msgid "Project Structure"
msgstr ""

#: src/dev/js2py.md:205
msgid "Current project structure:"
msgstr ""

#: src/dev/js2py.md:225
msgid "Troubleshooting"
msgstr ""

#: src/dev/js2py.md:227
msgid ""
"**CommonJS vs ESM**: Ensure module formats are compatible between Scala.js "
"output and Rollup configuration."
msgstr ""

#: src/dev/js2py.md:228
msgid ""
"**js2py limitations**: js2py has limited ECMAScript compatibility; avoid "
"advanced JS features."
msgstr ""

#: src/dev/js2py.md:229
msgid ""
"**Bundle size**: Large bundles may impact Python startup time; optimize "
"bundle size when possible."
msgstr ""

#: src/dev/js2py.md:230
msgid ""
"**Python version compatibility**: js2py works best with Python 3.8-3.11. "
"We're currently using Python 3.11."
msgstr ""

#: src/dev/js2py.md:231
msgid ""
"**Special character handling**: js2py doesn't support functions with special "
"characters in their names (like `$`) when accessing them directly. Use "
"`getattr()` instead:"
msgstr ""

#: src/dev/js2py.md:233
msgid "# Instead of: module.$function()\n"
msgstr ""

#: src/dev/js2py.md:234
msgid "\"$function\""
msgstr ""

#: src/dev/js2py.md:236
msgid ""
"**Object serialization issues**: When encountering \"Cannot convert object "
"to primitive value\" errors, explicitly use string conversion:"
msgstr ""

#: src/dev/js2py.md:238
msgid "// Instead of: \"text\" + object\n"
msgstr ""

#: src/dev/js2py.md:239
msgid "\"text\""
msgstr ""

#: src/dev/reader.md:3
msgid ""
"Design of Chester's parsers (\"readers\") that transform source code into "
"abstract syntax trees."
msgstr ""

#: src/dev/reader.md:7
msgid "Chester currently has two parser implementations:"
msgstr ""

#: src/dev/reader.md:9
msgid "**ReaderV1**: The original parser using FastParse combinators"
msgstr ""

#: src/dev/reader.md:10
msgid ""
"**ReaderV2**: The newer implementation using a token-based state machine"
msgstr ""

#: src/dev/reader.md:12
msgid ""
"Both parsers produce semantically identical ASTs using different internal "
"approaches."
msgstr ""

#: src/dev/reader.md:14
msgid "Core Design Principles"
msgstr ""

#: src/dev/reader.md:16
msgid ""
"**Context-Free Parsing**: Uniform rules for all expressions; identifiers "
"treated consistently"
msgstr ""

#: src/dev/reader.md:17
msgid "**Separation of Concerns**: Parse syntax without imposing semantics"
msgstr ""

#: src/dev/reader.md:18
msgid ""
"**Uniform Symbol Treatment**: No special keywords - just identifiers and "
"operators"
msgstr ""

#: src/dev/reader.md:19
msgid ""
"**Flat Operator Sequences**: Operator precedence handled later in the "
"semantic phase"
msgstr ""

#: src/dev/reader.md:20
msgid "**Newline Significance**: `}\\n` terminates expressions in blocks"
msgstr ""

#: src/dev/reader.md:21
msgid "**Block Return Values**: Last expression in a block is its return value"
msgstr ""

#: src/dev/reader.md:23
msgid "ReaderV1 Implementation"
msgstr ""

#: src/dev/reader.md:25
msgid ""
"ReaderV1 uses the FastParse library to implement a parser combinator "
"approach."
msgstr ""

#: src/dev/reader.md:27 src/dev/reader.md:60
msgid "Key Components"
msgstr ""

#: src/dev/reader.md:29
msgid ""
"**TokenParsers**: Small parsers for basic lexemes (identifiers, literals, "
"operators)"
msgstr ""

#: src/dev/reader.md:30
msgid ""
"**Combinators**: Composable functions that build larger parsers from smaller "
"ones"
msgstr ""

#: src/dev/reader.md:31
msgid ""
"**ParsingContext**: Tracks parsing state (e.g., whether currently in an "
"operator sequence)"
msgstr ""

#: src/dev/reader.md:32
msgid "**ExprMeta**: Metadata handling for source positions and comments"
msgstr ""

#: src/dev/reader.md:34 src/dev/reader.md:68
msgid "Characteristics"
msgstr ""

#: src/dev/reader.md:36
msgid "Declarative grammar definitions"
msgstr ""

#: src/dev/reader.md:37
msgid "FastParse-based error reporting"
msgstr ""

#: src/dev/reader.md:38
msgid "Recursive descent parsing model"
msgstr ""

#: src/dev/reader.md:40 src/dev/reader.md:78
msgid "Implementation Structure"
msgstr ""

#: src/dev/reader.md:42
msgid "ReaderV1 consists of:"
msgstr ""

#: src/dev/reader.md:44
msgid ""
"**Expression Parsers**: Methods like `parseExpr`, `parseAtom`, and "
"`parseOperator` form the core of the parser. They use FastParse combinators "
"to build complex parsers from simpler ones."
msgstr ""

#: src/dev/reader.md:46
msgid ""
"**Context Tracking**: A `ParsingContext` object tracks the current parsing "
"state, including whether we're in an operator sequence, a block, or other "
"specialized contexts."
msgstr ""

#: src/dev/reader.md:48
msgid ""
"**Source Position Tracking**: Dedicated methods map character positions to "
"line/column positions for error reporting, with special handling for UTF-16 "
"surrogate pairs."
msgstr ""

#: src/dev/reader.md:50
msgid ""
"**Whitespace and Comment Handling**: Dedicated parsers for whitespace, line "
"endings, and comments ensure these elements are preserved in the AST."
msgstr ""

#: src/dev/reader.md:52
msgid ""
"**Parser Extensions**: Custom extension methods for FastParse parsers add "
"support for metadata attachment, relaxed parsing, and error recovery."
msgstr ""

#: src/dev/reader.md:54
msgid ""
"**Parser Composition**: The implementation composes smaller parsers into "
"larger ones, following FastParse's combinator approach."
msgstr ""

#: src/dev/reader.md:56
msgid "ReaderV2 Implementation"
msgstr ""

#: src/dev/reader.md:58
msgid ""
"ReaderV2 uses a custom tokenizer and a state machine-based approach for "
"parsing, with significant improvements to block termination detection and "
"object expression parsing."
msgstr ""

#: src/dev/reader.md:62
msgid ""
"**Lexer**: Converts source code into a stream of tokens for efficient parsing"
msgstr ""

#: src/dev/reader.md:63
msgid ""
"**ReaderState**: Tracks current token position, history, and pending "
"whitespace/comments"
msgstr ""

#: src/dev/reader.md:64
msgid ""
"**ReaderContext**: Contains context flags like `newLineAfterBlockMeansEnds` "
"for parsing decisions"
msgstr ""

#: src/dev/reader.md:65
msgid ""
"**Token**: Represents tokens like identifiers, operators, literals, with "
"source position information"
msgstr ""

#: src/dev/reader.md:66
msgid ""
"**Token Handlers**: Specialized methods for parsing different token types "
"and structures"
msgstr ""

#: src/dev/reader.md:70
msgid "Pre-tokenization for efficient token stream processing"
msgstr ""

#: src/dev/reader.md:71
msgid "Separate lexing and parsing phases for cleaner code organization"
msgstr ""

#: src/dev/reader.md:72
msgid "Context-aware parsing with explicit state tracking"
msgstr ""

#: src/dev/reader.md:73
msgid "Enhanced UTF-16 aware Unicode and emoji handling"
msgstr ""

#: src/dev/reader.md:74
msgid "Robust block termination detection with the `}\\n` pattern"
msgstr ""

#: src/dev/reader.md:75
msgid "Comprehensive object expression support with multiple key types"
msgstr ""

#: src/dev/reader.md:76
msgid "Optimized comment handling and attachment"
msgstr ""

#: src/dev/reader.md:80
msgid "ReaderV2 consists of:"
msgstr ""

#: src/dev/reader.md:82
msgid ""
"**Two-Phase Parsing**: Separates tokenization from parsing, with a dedicated "
"Tokenizer creating a stream of tokens before parsing begins."
msgstr ""

#: src/dev/reader.md:84
msgid ""
"**State Management**: The parser maintains state through two complementary "
"objects:"
msgstr ""

#: src/dev/reader.md:85
msgid ""
"**ReaderState**: Tracks token position, history, and pending whitespace/"
"comments"
msgstr ""

#: src/dev/reader.md:86
msgid ""
"**ReaderContext**: Contains context flags like `newLineAfterBlockMeansEnds` "
"for syntactic decisions"
msgstr ""

#: src/dev/reader.md:87
msgid ""
"Together they enable precise tracking of parser state and contextual "
"information"
msgstr ""

#: src/dev/reader.md:89
msgid ""
"**Context-Aware Processing**: Context flags enable important syntactic "
"decisions like proper block termination with the `}\\n` pattern, while "
"maintaining uniform symbol treatment."
msgstr ""

#: src/dev/reader.md:91
msgid ""
"**Optimized Comment Handling**: Non-recursive methods like `skipComments()` "
"and `pullComments()` efficiently manage comment attachment, replacing the "
"previous recursive approach."
msgstr ""

#: src/dev/reader.md:93
msgid ""
"**Robust Block Termination**: The special `}\\n` pattern detection is "
"implemented in the `checkForRBraceNewlinePattern()` method, which uses the "
"`newLineAfterBlockMeansEnds` flag from ReaderContext to determine when "
"blocks should end."
msgstr ""

#: src/dev/reader.md:95
msgid "**Enhanced Object Expressions**: Support for multiple key types:"
msgstr ""

#: src/dev/reader.md:99
msgid "Both `=` and `=>` operators in object clauses"
msgstr ""

#: src/dev/reader.md:101
msgid ""
"**Error Handling**: The parser produces structured `ParseError` objects with "
"detailed source position information and recovery mechanisms."
msgstr ""

#: src/dev/reader.md:103
msgid ""
"**Bottom-Up Construction**: Parsing builds expressions from atoms and then "
"extends them through continuation-based parsing in `parseRest()`."
msgstr ""

#: src/dev/reader.md:105
msgid "Key Similarities Between Implementations"
msgstr ""

#: src/dev/reader.md:107
msgid "Both parsers:"
msgstr ""

#: src/dev/reader.md:109
msgid "Track source positions for error reporting"
msgstr ""

#: src/dev/reader.md:110
msgid "Preserve comments in the AST"
msgstr ""

#: src/dev/reader.md:111
msgid "Handle the `}\\n` block termination pattern"
msgstr ""

#: src/dev/reader.md:112
msgid "Produce flat operator sequences without precedence handling"
msgstr ""

#: src/dev/reader.md:113
msgid "Parse the same language syntax"
msgstr ""

#: src/dev/reader.md:114
msgid "Use context tracking for parsing decisions"
msgstr ""

#: src/dev/reader.md:115
msgid "Generate identical AST structures"
msgstr ""

#: src/dev/reader.md:117
msgid "Key Differences Between Implementations"
msgstr ""

#: src/dev/reader.md:119
msgid "Feature"
msgstr ""

#: src/dev/reader.md:119
msgid "ReaderV1"
msgstr ""

#: src/dev/reader.md:119
msgid "ReaderV2"
msgstr ""

#: src/dev/reader.md:121
msgid "**Parsing Approach**"
msgstr ""

#: src/dev/reader.md:121
msgid "Parser combinators (FastParse)"
msgstr ""

#: src/dev/reader.md:121
msgid "Token-based state machine"
msgstr ""

#: src/dev/reader.md:122
msgid "**Error Recovery**"
msgstr ""

#: src/dev/reader.md:122
msgid "Limited"
msgstr ""

#: src/dev/reader.md:122
msgid "Enhanced with token-based recovery"
msgstr ""

#: src/dev/reader.md:123
msgid "**Token Creation**"
msgstr ""

#: src/dev/reader.md:123
msgid "On-demand during parsing"
msgstr ""

#: src/dev/reader.md:123
msgid "Separate tokenization phase"
msgstr ""

#: src/dev/reader.md:124
msgid "**State Handling**"
msgstr ""

#: src/dev/reader.md:124
msgid "Implicit in parse context"
msgstr ""

#: src/dev/reader.md:124
msgid "Explicit in ReaderState"
msgstr ""

#: src/dev/reader.md:125
msgid "**Code Structure**"
msgstr ""

#: src/dev/reader.md:125
msgid "Grammar-centric"
msgstr ""

#: src/dev/reader.md:125
msgid "Process-centric"
msgstr ""

#: src/dev/reader.md:126
msgid "**Performance**"
msgstr ""

#: src/dev/reader.md:126
msgid "Good"
msgstr ""

#: src/dev/reader.md:126
msgid "Better (especially on large files)"
msgstr ""

#: src/dev/reader.md:127
msgid "**Unicode Support**"
msgstr ""

#: src/dev/reader.md:127
msgid "Basic"
msgstr ""

#: src/dev/reader.md:127
msgid "Enhanced with better UTF-16 handling"
msgstr ""

#: src/dev/reader.md:129
msgid "Testing Infrastructure"
msgstr ""

#: src/dev/reader.md:131
msgid ""
"Chester's test framework validates parser correctness and compatibility "
"between V1 and V2 implementations. This framework, defined in `reader/shared/"
"src/test/scala/chester/reader/parseAndCheck.scala`, provides several key "
"testing functions:"
msgstr ""

#: src/dev/reader.md:133
msgid "Core Testing Functions"
msgstr ""

#: src/dev/reader.md:135
msgid "**Parser-Specific Testing**:"
msgstr ""

#: src/dev/reader.md:136
msgid ""
"`parseV1(input)`: Parses input with V1 parser only and returns the result"
msgstr ""

#: src/dev/reader.md:137
msgid ""
"`parseV2(input)`: Parses input with V2 parser only and returns the result"
msgstr ""

#: src/dev/reader.md:138
msgid ""
"`parseAndCheckV1(input, expected)`: Tests V1 parser against expected output"
msgstr ""

#: src/dev/reader.md:139
msgid ""
"`parseAndCheckV2(input, expected)`: Tests V2 parser against expected output"
msgstr ""

#: src/dev/reader.md:141
msgid "**Cross-Parser Verification**:"
msgstr ""

#: src/dev/reader.md:142
msgid ""
"`parseAndCheckBoth(input, expected)`: Tests both parsers and ensures they "
"produce identical results"
msgstr ""

#: src/dev/reader.md:143
msgid "Tests backward compatibility and feature parity"
msgstr ""

#: src/dev/reader.md:145
msgid "**Top-Level Parsing**:"
msgstr ""

#: src/dev/reader.md:146
msgid ""
"`parseTopLevelV1/V2` and `parseAndCheckTopLevelV1/V2/Both`: Similar "
"functions for testing top-level parsing"
msgstr ""

#: src/dev/reader.md:147
msgid "Handle file-level parsing with multiple expressions"
msgstr ""

#: src/dev/reader.md:149
msgid "Error Reporting"
msgstr ""

#: src/dev/reader.md:151
msgid "The testing framework provides error reporting with:"
msgstr ""

#: src/dev/reader.md:153
msgid "Detailed error messages showing exact failure position"
msgstr ""

#: src/dev/reader.md:154
msgid "Visual pointer to error location in source code"
msgstr ""

#: src/dev/reader.md:155
msgid "Context-aware error descriptions"
msgstr ""

#: src/dev/reader.md:156
msgid "Comparison between expected and actual AST structures"
msgstr ""

#: src/dev/reader.md:158
msgid "Serialization Verification"
msgstr ""

#: src/dev/reader.md:160
msgid ""
"The framework also tests that parsed expressions can be correctly serialized "
"and deserialized:"
msgstr ""

#: src/dev/reader.md:162
msgid "Verifies JSON serialization with `read[Expr](write[Expr](value))`"
msgstr ""

#: src/dev/reader.md:163
msgid ""
"Confirms binary serialization with `readBinary[Expr](writeBinary[Expr]"
"(value))`"
msgstr ""

#: src/dev/reader.md:164
msgid "Ensures AST structures maintain integrity through serialization cycles"
msgstr ""

#: src/dev/reader.md:166
msgid "Test Organization"
msgstr ""

#: src/dev/reader.md:168
msgid "Parser tests are organized into several categories:"
msgstr ""

#: src/dev/reader.md:170
msgid "**Expression Tests**: Verify parsing of individual expression types"
msgstr ""

#: src/dev/reader.md:171
msgid "**Integration Tests**: Test combined language features"
msgstr ""

#: src/dev/reader.md:172
msgid "**Regression Tests**: Ensure previously fixed issues don't reoccur"
msgstr ""

#: src/dev/reader.md:173
msgid "**Migration Tests**: Track progress in supporting V1 features in V2"
msgstr ""

#: src/dev/reader.md:175
msgid "File-Based Testing"
msgstr ""

#: src/dev/reader.md:177
msgid ""
"In addition to the core testing functions, Chester implements file-based "
"integration tests:"
msgstr ""

#: src/dev/reader.md:179
msgid ""
"**FileParserTest.scala**: Tests ReaderV2 against a suite of test files in "
"`tests/parser` directory"
msgstr ""

#: src/dev/reader.md:180
msgid ""
"**FileParserTestV1.scala**: Tests ReaderV1 against the same test suite for "
"comparison"
msgstr ""

#: src/dev/reader.md:182
msgid "These file-based tests:"
msgstr ""

#: src/dev/reader.md:183
msgid "Ensure consistency when parsing complete Chester files"
msgstr ""

#: src/dev/reader.md:184
msgid "Verify parser behavior across a wide range of syntax combinations"
msgstr ""

#: src/dev/reader.md:185
msgid "Automatically generate expected output for regression testing"
msgstr ""

#: src/dev/reader.md:186
msgid "Maintain backward compatibility during parser evolution"
msgstr ""

#: src/dev/reader.md:188
msgid "Future Development"
msgstr ""

#: src/dev/reader.md:190
msgid ""
"ReaderV2 is the focus of ongoing development, with priorities including:"
msgstr ""

#: src/dev/reader.md:192
msgid "Completing error recovery implementation"
msgstr ""

#: src/dev/reader.md:193
msgid "Adding source maps support"
msgstr ""

#: src/dev/reader.md:194
msgid "Migrating any remaining V1-only tests"
msgstr ""

#: src/dev/reader.md:195
msgid "Expanding test coverage"
msgstr ""

#: src/dev/reader.md:196
msgid "Optimizing token handling for better performance"
msgstr ""

#: src/dev/reader.md:198
msgid "See [devlog.md](devlog.md) for chronological implementation details."
msgstr ""

#: src/dev/scalablytyped-bindings.md:3
msgid ""
"This document provides information about where to find and how to use the "
"ScalablyTyped bindings in the Chester project."
msgstr ""

#: src/dev/scalablytyped-bindings.md:5
msgid "Where to Find the Bindings"
msgstr ""

#: src/dev/scalablytyped-bindings.md:7
msgid ""
"The ScalablyTyped bindings for external libraries like `ts-morph` are "
"generated during the build process and stored in the following locations:"
msgstr ""

#: src/dev/scalablytyped-bindings.md:9
msgid "Generated Source Files"
msgstr ""

#: src/dev/scalablytyped-bindings.md:11
msgid "The actual Scala source files for the bindings are located at:"
msgstr ""

#: src/dev/scalablytyped-bindings.md:17
msgid "Within this directory:"
msgstr ""

#: src/dev/scalablytyped-bindings.md:18
msgid "`mod/` directory contains all the main classes and traits"
msgstr ""

#: src/dev/scalablytyped-bindings.md:19
msgid "`anon/` directory contains anonymous types"
msgstr ""

#: src/dev/scalablytyped-bindings.md:20
msgid ""
"`tsMorphBooleans.scala`, `tsMorphInts.scala`, etc. contain constants and "
"types"
msgstr ""

#: src/dev/scalablytyped-bindings.md:22
msgid "Important Files for ts-morph"
msgstr ""

#: src/dev/scalablytyped-bindings.md:24
msgid "Key files for working with ts-morph:"
msgstr ""

#: src/dev/scalablytyped-bindings.md:26
msgid "`mod/SourceFile.scala` - Contains the SourceFile class definition"
msgstr ""

#: src/dev/scalablytyped-bindings.md:27
msgid ""
"`mod/StatementedNode.scala` - Contains methods for accessing interfaces, "
"classes, and type aliases"
msgstr ""

#: src/dev/scalablytyped-bindings.md:28
msgid ""
"`mod/Project.scala` - Contains the Project class for creating and working "
"with projects"
msgstr ""

#: src/dev/scalablytyped-bindings.md:30
msgid "Using the Bindings in Code"
msgstr ""

#: src/dev/scalablytyped-bindings.md:32
msgid "There are two approaches to using ts-morph from Scala.js:"
msgstr ""

#: src/dev/scalablytyped-bindings.md:34
msgid "Approach 1: Using ScalablyTyped Bindings Directly"
msgstr ""

#: src/dev/scalablytyped-bindings.md:36
msgid "To use the ScalablyTyped bindings in your code:"
msgstr ""

#: src/dev/scalablytyped-bindings.md:38
msgid "Import the correct namespace:"
msgstr ""

#: src/dev/scalablytyped-bindings.md:43
msgid ""
"When working with SourceFile to access interfaces, classes, and type "
"aliases, note that:"
msgstr ""

#: src/dev/scalablytyped-bindings.md:44
msgid "`SourceFile` does not directly extend `StatementedNode`"
msgstr ""

#: src/dev/scalablytyped-bindings.md:45
msgid ""
"Use methods like `getInterfaces()`, `getClasses()`, and `getTypeAliases()` "
"from the appropriate trait"
msgstr ""

#: src/dev/scalablytyped-bindings.md:46
msgid ""
"Convert JavaScript arrays to Scala lists using `js.Array.from(...).toList`"
msgstr ""

#: src/dev/scalablytyped-bindings.md:48
msgid "Example access pattern:"
msgstr ""

#: src/dev/scalablytyped-bindings.md:55
msgid "Approach 2: Using Direct JavaScript Interop"
msgstr ""

#: src/dev/scalablytyped-bindings.md:57
msgid ""
"For simpler integration, especially when facing type mismatches or method "
"access issues, you can use direct JavaScript evaluation:"
msgstr ""

#: src/dev/scalablytyped-bindings.md:64
msgid ""
"// Use direct JavaScript interop with triple quotes for multiline JavaScript"
msgstr ""

#: src/dev/scalablytyped-bindings.md:65
msgid ""
"s\"\"\"\n"
"    function analyze(filePath) {\n"
"      const { Project } = require(\"ts-morph\");\n"
"      \n"
"      try {\n"
"        const project = new Project();\n"
"        const sourceFile = project.addSourceFileAtPath(filePath);\n"
"        \n"
"        // Use native JavaScript APIs directly\n"
"        const interfaces = sourceFile.getInterfaces().map(interface => ({\n"
"          name: interface.getName(),\n"
"          // ... other properties\n"
"        }));\n"
"        \n"
"        return JSON.stringify(interfaces);\n"
"      } catch (e) {\n"
"        return JSON.stringify({ error: e.message });\n"
"      }\n"
"    }\n"
"    \n"
"    analyze(\"${"
msgstr ""

#: src/dev/scalablytyped-bindings.md:85
msgid ""
"}\");\n"
"  \"\"\""
msgstr ""

#: src/dev/scalablytyped-bindings.md:90
msgid "This approach:"
msgstr ""

#: src/dev/scalablytyped-bindings.md:91
msgid "Avoids type mismatches and casting issues"
msgstr ""

#: src/dev/scalablytyped-bindings.md:92
msgid "Uses native JavaScript directly"
msgstr ""

#: src/dev/scalablytyped-bindings.md:93
msgid "Returns results as JSON strings"
msgstr ""

#: src/dev/scalablytyped-bindings.md:94
msgid "Escapes Scala-JavaScript interpolation issues using triple quotes"
msgstr ""

#: src/dev/scalablytyped-bindings.md:96
msgid "Common Gotchas"
msgstr ""

#: src/dev/scalablytyped-bindings.md:98
msgid ""
"**Array Conversion**: JavaScript arrays need to be converted to Scala "
"collections using `js.Array.from(...).toList`"
msgstr ""

#: src/dev/scalablytyped-bindings.md:100
msgid ""
"**Method Names**: Some method names in the bindings may differ from the "
"original TypeScript API"
msgstr ""

#: src/dev/scalablytyped-bindings.md:102
msgid ""
"**Inheritance Hierarchy**: The inheritance hierarchy in the bindings may not "
"match the TypeScript original exactly"
msgstr ""

#: src/dev/scalablytyped-bindings.md:104
msgid ""
"**Type Conversion**: Sometimes explicit type conversion is needed when "
"working with the bindings"
msgstr ""

#: src/dev/scalablytyped-bindings.md:106
msgid ""
"**String Interpolation**: When using direct JavaScript eval, use Scala "
"triple quotes (`\"\"\"`) and properly escape JavaScript template literals (`$"
"{...}` to `$${...}`)"
msgstr ""

#: src/dev/scalablytyped-bindings.md:108
#, fuzzy
msgid "Rebuilding Bindings"
msgstr "let ç¹«çµ"

#: src/dev/scalablytyped-bindings.md:110
msgid "If you need to rebuild the ScalablyTyped bindings:"
msgstr ""

#: src/dev/scalablytyped-bindings.md:112
msgid "Run `sbt \"jsTypings/stImport\"` to regenerate the bindings"
msgstr ""

#: src/dev/scalablytyped-bindings.md:113
msgid "For troubleshooting binding generation, check `jsTypings/stOutputs`"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:5
msgid ""
"This document outlines specific proposed improvements to Chester's type "
"checking system, focusing on dependent types, union and intersection types, "
"and the integration between the reducer and type checker."
msgstr ""

#: src/dev/tyck-improvement-proposal.md:7
msgid "1. Overview and Background"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:9
msgid ""
"Chester's type system is based on a constraint propagation network where:"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:10
msgid "Type constraints are represented by **propagators**"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:11
msgid "**Cells** hold type information and track their propagators"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:12
msgid "Two types of propagator connections:"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:13
msgid "**Reading**: Propagators that read from a cell"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:14
msgid "**Zonking**: Propagators that can write to or resolve a cell"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:16
msgid ""
"Recent improvements have focused on enhancing support for dependent types, "
"which require:"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:17
msgid "Types that can depend on terms"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:18
msgid "Variable bindings in types with alpha-equivalence checking"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:19
msgid "Sophisticated reduction strategies for type equality"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:21
msgid "2. Current Status and Progress"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:23
msgid ""
"**Note**: Many key improvements have been completed and documented in the "
"devlog entries. Refer to `docs/src/dev/devlog.md` for details on completed "
"improvements, particularly those related to type system enhancements, trait "
"implementation, and the new AutoConnect propagator."
msgstr ""

#: src/dev/tyck-improvement-proposal.md:25
msgid "3. Remaining Issues and Implementation Plan"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:27
msgid "3.1 âœ… Union Type Subtyping Implementation"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:29
#: src/dev/tyck-improvement-proposal.md:42
msgid "**Status: COMPLETED**"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:31
msgid ""
"The union type implementation has been completed with full support for the "
"pipe operator (`|`) syntax and proper subtyping relationships. All "
"components have been implemented as documented in the devlog."
msgstr ""

#: src/dev/tyck-improvement-proposal.md:33
msgid "Completed implementations include:"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:34
msgid "Union-to-Union subtyping (`A|B <: C|D`)"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:35
msgid "Specific-to-Union subtyping (`A <: B|C`)"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:36
msgid "Union-to-Specific subtyping (`A|B <: C`)"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:37
msgid "Cell coverage mechanisms for union types"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:38
msgid "Proper type checking for union types in all contexts"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:40
msgid "3.2 âœ… Removal of the EnsureCellCoverage Hack"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:44
msgid ""
"The `EnsureCellCoverage` hack has been replaced with a proper `AutoConnect` "
"propagator that establishes meaningful type relationships. See the devlog "
"for implementation details."
msgstr ""

#: src/dev/tyck-improvement-proposal.md:46
msgid "Key improvements include:"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:47
msgid "Analysis of term structure to create proper type connections"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:48
msgid "Smart handling of union and intersection types"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:49
msgid "Specialized support for function calls and their arguments"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:50
msgid "Default value support for truly unconstrained type variables"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:51
msgid "Complete removal of all `EnsureCellCoverage` instances"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:53
msgid "All success criteria have been met:"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:54
msgid "All cells are covered by meaningful propagators with actual logic"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:55
msgid "No explicit `EnsureCellCoverage` instances in the codebase"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:56
msgid "Union types and other complex types work correctly"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:57
msgid "Type errors are detected and reported accurately"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:58
msgid "Tests pass with proper constraint checking"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:59
msgid "Improved code clarity and maintainability"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:61
msgid "3.3 Enhanced Type-Level Function Application Reduction"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:63
msgid "Current Limitation"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:65
msgid ""
"The current type checker supports basic type-level function applications, "
"but has limited handling of nested or recursive function applications in "
"type-level contexts. When complex type-level expressions involve multiple "
"nested function calls, the reducer may not properly evaluate them during "
"type checking, leading to:"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:67
msgid "Type errors due to incomplete reduction of nested function applications"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:68
msgid "Reduced flexibility when using type-level functions in complex ways"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:69
msgid "Unclear error messages when type-level function applications fail"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:71 src/dev/typescript-backend.md:82
#: src/dev/typescript-backend.md:120
msgid "Implementation Plan"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:73
msgid "The implementation requires focused changes to:"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:75
msgid "**DefaultReducer Enhancement**:"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:76
msgid "Improve handling of nested type-level function applications"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:77
msgid "Implement recursive handling of type-level function results"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:78
msgid "Ensure consistent reduction behavior for composed functions"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:80
msgid "**Type Checking Integration**:"
msgstr "**é¡å‹æª¢æŸ¥æ•´åˆ**ï¼š"

#: src/dev/tyck-improvement-proposal.md:81
msgid ""
"Further enhance the `tryUnify` method to handle complex function call terms"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:82
msgid "Ensure proper cell coverage for nested function applications"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:83
msgid "Add guards to prevent pattern matching conflicts"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:85
msgid "Testable Example"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:87
msgid ""
"```chester\n"
"// Test enhanced type-level function application\n"
"record A(a: Integer);\n"
"record B(b: String);\n"
"\n"
"// Basic identity function for types\n"
"def idType(x: Type): Type = x;\n"
"\n"
"// Function composition at the type level\n"
"def composeTypes(f: Type -> Type, g: Type -> Type, x: Type): Type = "
"f(g(x));\n"
"\n"
"// Test basic composition\n"
"let aT = composeTypes(idType, idType, A);\n"
"def getA(x: aT): Integer = x.a;  // Should work via reduction\n"
"```"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:105
msgid "Nested function applications are properly reduced during type checking"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:106
msgid "Field access on types produced by composed functions works correctly"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:107
msgid "The original function applications are preserved in elaborated results"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:108
msgid "No \"cells not covered by any propagator\" errors occur during zonking"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:110
msgid "4. Testing Strategy"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:112
msgid "4.1 Create Specialized Tests for Dependent Types"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:114
msgid "Implement tests that verify:"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:115
msgid "Function types with type dependencies"
msgstr "å¸¶æœ‰é¡å‹ä¾è³´çš„å‡½æ•¸é¡å‹"

#: src/dev/tyck-improvement-proposal.md:116
msgid "Equality of types with different variable names but same structure"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:117
msgid "Union and intersection types with alpha-equivalent components"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:119
msgid "4.2 Union Type Testing Cases"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:121
msgid "Completed test cases:"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:123
msgid ""
"```chester\n"
"// Widening (Success)\n"
"def f(x: Integer): Integer | String = x;\n"
"f(42);\n"
"```"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:129
msgid "Additional test cases needed:"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:131
msgid ""
"```chester\n"
"// Nested Union Types\n"
"def complex(x: (Integer | String) | Boolean): (Integer | String) | Boolean = "
"x;\n"
"\n"
"// Union with parametric types\n"
"def generic<T>(x: T | String): T | String = x;\n"
"\n"
"// Intersection with union\n"
"def mixed(x: (A & B) | C): (A & B) | C = x;\n"
"```"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:142
msgid "5. Implementation Steps"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:144
msgid "5.1 Phase 1: Core Type System Improvements"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:146
msgid "**Status**: Most core improvements have been completed."
msgstr ""

#: src/dev/tyck-improvement-proposal.md:148
msgid "Completed improvements (see devlog for details):"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:149
msgid "âœ… Enhanced Type Structure Reduction in DefaultReducer"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:150
msgid "âœ… Alpha-Equivalence Checking in TyckPropagator"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:151
msgid "âœ… Enhanced Type Level Comparison"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:152
msgid "âœ… Cell Coverage Mechanisms with AutoConnect propagator"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:153
msgid "âœ… Union Type Subtyping Implementation"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:154
msgid "âœ… Basic Trait Implementation"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:156
msgid "Remaining items to complete:"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:157
msgid "Add more complex test cases for nested union types"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:158
msgid ""
"Complete enhanced type-level function application for complex nested cases"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:159
msgid "Add test cases for complex type-level functions"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:161
msgid "5.2 Phase 2: Advanced Type Features"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:162
msgid "Test with complex type-level function examples"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:163
msgid "Verify all success criteria are met"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:164
msgid "Add more test cases for edge cases"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:165
msgid "Document implementation details and usage patterns"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:167
msgid "6. Design Principles to Follow"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:169
msgid "6.1 Term Preservation"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:171
msgid "Never reduce during elaboration"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:172
msgid "Only use reduction for type-level comparisons"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:173
msgid "Preserve source structure for better error reporting"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:175
msgid "6.2 Reduction Strategy"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:176
msgid "Only reduce during type equality checking"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:178
msgid "Use proper reduction context from current context"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:179
msgid "Never reflect internal reductions in output"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:181
msgid "6.3 Documentation"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:182
msgid "Keep this document updated with implementation progress"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:183
msgid "Document design decisions and trade-offs"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:184
msgid "Maintain clear test cases for each feature"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:186
msgid "7. Success Criteria"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:188
msgid "All tests pass, including the specialized dependent type tests"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:189
msgid "The type checking system correctly handles:"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:190
msgid "Complex dependent type scenarios"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:191
msgid "Intersection type comparisons"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:192
msgid "Union type subtyping"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:193
msgid "Type-level function applications"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:194
msgid ""
"Documentation clearly explains dependent type concepts and usage patterns"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:195
msgid "Meta variables in complex types resolve correctly"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:197
msgid "8. Running Tests"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:199
msgid ""
"To run the tests for the type checker specifically, use the following SBT "
"command:"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:202
msgid "# Run the FilesTyckTest suite to test the type checking system\n"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:206
msgid ""
"âš ï¸ **IMPORTANT WARNING**: Do NOT use the `-z` test filter option (e.g., `sbt "
"\"rootJVM/testOnly -- -z pattern\"`) as it is broken and produces unreliable "
"results. Instead, run the entire test suite and review the results."
msgstr ""

#: src/dev/tyck-improvement-proposal.md:208
msgid "8.5 Quick Test Guide"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:210
msgid "Basic Test Cases By Feature"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:212
msgid ""
"Below are minimal test cases for each feature that can be used for quick "
"verification. Create these in separate `.chester` files in the `tests/tyck/` "
"directory to validate implementation."
msgstr ""

#: src/dev/tyck-improvement-proposal.md:214
msgid "1. Union Type Tests"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:216
msgid ""
"```chester\n"
"// FILE: union_basic.chester\n"
"// Tests basic union type assignment\n"
"let a: Integer | String = 42;\n"
"let b: Integer | String = \"hello\";\n"
"```"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:223
msgid ""
"```chester\n"
"// FILE: union_function.chester\n"
"// Tests function with union type parameters and return\n"
"def identity(x: Integer | String): Integer | String = x;\n"
"let a = identity(42);\n"
"let b = identity(\"hello\");\n"
"```"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:231
msgid ""
"```chester\n"
"// FILE: union_specific.chester\n"
"// Tests union-to-specific subtyping\n"
"def expectNumber(x: Number): Number = x;\n"
"let a: Integer | Float = 42;\n"
"expectNumber(a);  // Should succeed if Integer|Float <: Number\n"
"```"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:239
msgid "2. Trait Tests"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:241
msgid ""
"```chester\n"
"// FILE: trait_basic.chester\n"
"// Tests basic trait implementation\n"
"trait Showable {\n"
"  def show: String;\n"
"}\n"
"\n"
"record Person(name: String, age: Integer) <: Showable {\n"
"  def show: String = name;\n"
"}\n"
"\n"
"let p = Person(\"Alice\", 30);\n"
"let s: Showable = p;\n"
"let name = s.show;\n"
"```"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:257
msgid ""
"```chester\n"
"// FILE: trait_field.chester\n"
"// Tests trait field access\n"
"trait HasName {\n"
"  def name: String;\n"
"}\n"
"\n"
"record User(name: String, email: String) <: HasName;\n"
"\n"
"def getName(x: HasName): String = x.name;\n"
"let u = User(\"Bob\", \"bob@example.com\");\n"
"getName(u);\n"
"```"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:271
msgid "3. Type-Level Function Tests"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:273
msgid ""
"```chester\n"
"// FILE: type_function.chester\n"
"// Tests type-level function application\n"
"def idType(x: Type): Type = x;\n"
"\n"
"record Point(x: Integer, y: Integer);\n"
"let pointType = idType(Point);\n"
"\n"
"def makePoint(p: pointType): pointType = p;\n"
"let p = Point(1, 2);\n"
"makePoint(p);\n"
"```"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:286
msgid "Running Individual Test Cases"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:288
msgid "To run a specific test file:"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:291
msgid "# Compile and run a specific test file\n"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:292
msgid "\"rootJVM/testOnly chester.tyck.FilesTyckTest -- -only add.chester\""
msgstr ""

#: src/dev/tyck-improvement-proposal.md:295
msgid "Test Verification Checklist"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:297
msgid "For each test case, verify:"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:299
msgid "âœ… Compilation succeeds without errors"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:300
msgid "âœ… Type checks pass correctly"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:301
msgid "âœ… No \"cells not covered by any propagator\" errors"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:302
msgid ""
"âœ… Error messages are clear and helpful when intentional errors are "
"introduced"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:304
msgid "9. âœ… Trait Implementation Plan"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:306
#: src/dev/tyck-improvement-proposal.md:322
msgid "**Status: BASIC IMPLEMENTATION COMPLETED**"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:308
msgid ""
"Basic trait implementation has been completed and documented in the "
"development log. See the devlog for implementation details."
msgstr ""

#: src/dev/tyck-improvement-proposal.md:310
msgid "Future Enhancements for Traits"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:312
msgid ""
"While basic trait functionality is working, the following enhancements are "
"planned for future implementation:"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:314
msgid "Complete field requirement verification for traits"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:315
msgid "Multiple trait inheritance support"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:316
msgid "Trait method and default implementations"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:317
msgid "More comprehensive trait test cases"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:318
msgid "Advanced trait composition patterns"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:320
msgid "10. âœ… Detailed Plan for Complex Union Types"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:324
msgid ""
"Many of the planned union type improvements have been completed and "
"documented in the devlog. The implementation includes proper handling of "
"union subtyping and cell coverage through the new AutoConnect propagator."
msgstr ""

#: src/dev/tyck-improvement-proposal.md:326
msgid "Future Work for Complex Union Types"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:328
msgid ""
"To further extend support for complex union types (nested unions, unions "
"with generic types), the following detailed technical steps are still needed:"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:330
msgid "**Enhance Parser and Desalter Support**:"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:331
msgid "Improve handling of parenthesized union types"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:332
msgid "Add special handling for union types with generic parameters"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:333
msgid "Support deeper nested union types"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:335
msgid "**Strengthen Type Checking for Advanced Cases**:"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:336
msgid "Enhance handling of nested unions by \"flattening\" when appropriate"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:337
msgid "Improve error reporting for complex union scenarios"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:338
msgid "Update unification to handle multi-level nested unions properly"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:340
msgid "**Expand the Test Suite**:"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:341
msgid "Add specific unit tests for each subtyping scenario"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:342
msgid "Test nested unions with different depths"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:343
msgid "Test unions with different combinations of types"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:344
msgid "Test function types with union parameters and return types"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:345
msgid "Test generic type parameters with union bounds"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:346
msgid ""
"Test more complex scenarios combining unions, intersections, and generic "
"types"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:348
msgid "Success Metrics"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:350
msgid "The implementation will be considered successful when:"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:352
msgid "All test cases pass without errors"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:353
msgid "The type checker correctly handles complex nested unions"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:354
msgid "No \"cells not covered\" exceptions occur"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:355
msgid "Type error messages are clear and help identify the issue"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:356
msgid "The implementation can scale to handle arbitrarily complex union types"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:358
msgid "11. Experimental Implementation Notes: Union Type Improvements"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:360
msgid ""
"During an experimental implementation attempt to fix union type handling, "
"the following specific changes were made to improve union type subtyping and "
"prevent cell coverage errors:"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:362
msgid "11.1 Union-to-Specific Type Relationship Changes"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:364
msgid ""
"The key issue identified was in how union types were converted to specific "
"types (e.g., `Integer | String` to `Integer`):"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:366
msgid "**Original Implementation Issues:**"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:367
msgid ""
"In `TyckPropagator.scala`, the `unionSpecificCompatible` method only checked "
"if ANY component of the union was compatible with the specific type"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:368
msgid ""
"This allowed unsound expressions like `def f(x: Integer | String): Integer = "
"x` to type-check"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:370
msgid "**Specific Changes Made:**"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:371
msgid ""
"Modified `unionSpecificCompatible` method to check if ALL union components "
"are compatible with the specific type"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:372
msgid ""
"Changed the implementation logic from `unionTypes.exists(compatible)` to `!"
"unionTypes.exists(!compatible)`"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:373
msgid ""
"Added explicit error reporting in `handleUnionSpecific` method within the "
"`Unify` case class"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:374
msgid ""
"Enhanced debug output to include step-by-step component compatibility checks"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:375
msgid ""
"Modified `Elaborater.unify` method's union case to properly handle specific-"
"to-union compatibility"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:377
msgid "11.2 DefaultValuePropagator Implementation"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:379
msgid "To solve the \"cells not covered by any propagator\" errors:"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:381
msgid "**Specific Implementation Changes:**"
msgstr "**å…·é«”å¯¦ç¾è®Šæ›´**ï¼š"

#: src/dev/tyck-improvement-proposal.md:382
msgid ""
"Rewritten `ensureDefaultValue[T]` method (line ~1087 in "
"`TyckPropagator.scala`):"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:383
msgid "Added explicit `state.addPropagator` call to add a dedicated propagator"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:384
msgid "Added explicit `state.fill` call to ensure cells have values"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:385
msgid "Added diagnostic logging to track cell state"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:387
msgid "Created a new `DefaultValuePropagator[T]` case class with:"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:388
msgid "Set `score = 100` to give it high priority"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:389
msgid "Implemented `run`, `defaulting`, and `naiveFallbackZonk` methods"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:390
msgid ""
"Added proper cell tracking with `readingCells`, `writingCells`, and "
"`defaultingCells`"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:391
msgid ""
"Added custom `identify` method returning `Some(id)` to prevent propagator "
"removal"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:393
msgid "11.3 Infinite Recursion Prevention"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:395
msgid "Specific changes to break cyclic dependencies:"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:397
msgid "In `UnionOf` propagator:"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:398
msgid "Removed recursive calls to `unify` that could cause infinite loops"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:399
msgid "Used early returns and simplified value checking logic"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:400
msgid "Added guard conditions before recursive propagator creation"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:402
msgid "In the `handleUnionSpecific` method:"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:403
msgid ""
"Used `ensureDefaultValue` for each union component instead of creating "
"linked propagators"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:404
msgid ""
"Added filtered component selection before creating propagator connections"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:405
msgid ""
"Used explicit value discarding with statements like `val _ = "
"ensureDefaultValue(unionType)`"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:407
msgid "11.4 Test File Updates"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:409
msgid "Specific file changes:"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:410
msgid ""
"Moved `tests/tyck-fails/union-subtype-fail.chester.todo` to active status by "
"removing `.todo` extension"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:411
msgid ""
"Updated the expected behavior of `def f(x: Integer | String): Integer = x` "
"to correctly fail"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:412
msgid ""
"Modified `tests/tyck/simple-union.chester.todo` to ensure it properly tests "
"union widening"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:414
msgid "11.5 Key Identifier Changes for Future Reference"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:416
msgid "The most significant method and identifier changes were:"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:417
msgid "`unionSpecificCompatible`: Changed compatibility check logic"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:418
msgid "`handleUnionSpecific`: Rewrote to handle ALL union components"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:419
msgid "`ensureDefaultValue`: Enhanced with propagator creation"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:420
msgid "Added new `DefaultValuePropagator` class"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:421
msgid "Modified `Unify.defaulting` case for union handling"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:422
msgid "Updated union component debug logging using `Debug.debugPrint`"
msgstr ""

#: src/dev/tyck-improvement-proposal.md:424
msgid ""
"These changes collectively represent an approach to fixing union type "
"subtyping that ensures sound type checking while preventing \"cells not "
"covered\" errors through improved propagator management."
msgstr ""

#: src/dev/type-checking-system.md:5
msgid "Quick Start Guide"
msgstr ""

#: src/dev/type-checking-system.md:7
msgid ""
"Chester's type checking system is powered by a **propagator network** - a "
"constraint-based approach that allows for complex type relationships."
msgstr ""

#: src/dev/type-checking-system.md:9
msgid "Simple Visual Overview"
msgstr ""

#: src/dev/type-checking-system.md:38
msgid "Key Concepts in 30 Seconds"
msgstr ""

#: src/dev/type-checking-system.md:40
msgid "**Cells** - Hold type information and track connections to propagators"
msgstr ""

#: src/dev/type-checking-system.md:41
msgid ""
"**Propagators** - Define constraints between cells and propagate type "
"information"
msgstr ""

#: src/dev/type-checking-system.md:42
msgid ""
"**Network** - The collection of cells and propagators that work together"
msgstr ""

#: src/dev/type-checking-system.md:44
msgid "When type checking:"
msgstr ""

#: src/dev/type-checking-system.md:45
msgid "Cells store type information (like \"this variable has type Integer\")"
msgstr ""

#: src/dev/type-checking-system.md:46
msgid ""
"Propagators enforce constraints (like \"parameter type must match argument "
"type\")"
msgstr ""

#: src/dev/type-checking-system.md:47
msgid ""
"When a cell value changes, connected propagators activate to propagate that "
"change"
msgstr ""

#: src/dev/type-checking-system.md:49
msgid ""
"This reactive network allows complex type relationships (like union types) "
"to be modeled effectively."
msgstr ""

#: src/dev/type-checking-system.md:53
msgid "1. Core Components"
msgstr ""

#: src/dev/type-checking-system.md:55
msgid "**Cells (`HoldCell`)**"
msgstr ""

#: src/dev/type-checking-system.md:56
msgid "Hold type information and state"
msgstr ""

#: src/dev/type-checking-system.md:57
msgid "Track propagator connections:"
msgstr ""

#: src/dev/type-checking-system.md:60
msgid "// Current value"
msgstr ""

#: src/dev/type-checking-system.md:61
msgid "// Change tracking"
msgstr ""

#: src/dev/type-checking-system.md:67
msgid "**Propagators**"
msgstr ""

#: src/dev/type-checking-system.md:68
msgid "Base trait defining propagator behavior:"
msgstr ""

#: src/dev/type-checking-system.md:79
msgid "2. Key Propagator Types"
msgstr ""

#: src/dev/type-checking-system.md:81
msgid "**Unify Propagator**"
msgstr ""

#: src/dev/type-checking-system.md:82
msgid "Handles type unification and subtyping"
msgstr ""

#: src/dev/type-checking-system.md:83
msgid "Special cases for:"
msgstr ""

#: src/dev/type-checking-system.md:84
msgid "Meta variables"
msgstr ""

#: src/dev/type-checking-system.md:85
msgid "Union types"
msgstr ""

#: src/dev/type-checking-system.md:86
msgid "Intersection types"
msgstr ""

#: src/dev/type-checking-system.md:87
msgid "List types"
msgstr ""

#: src/dev/type-checking-system.md:88
msgid "Record types"
msgstr ""

#: src/dev/type-checking-system.md:90
msgid "**UnionOf Propagator**"
msgstr ""

#: src/dev/type-checking-system.md:91
msgid "Manages union type construction"
msgstr ""

#: src/dev/type-checking-system.md:92
msgid "Handles:"
msgstr ""

#: src/dev/type-checking-system.md:93
msgid "Component type collection"
msgstr ""

#: src/dev/type-checking-system.md:94
msgid "Meta variable resolution"
msgstr ""

#: src/dev/type-checking-system.md:95
msgid "Type compatibility checks"
msgstr ""

#: src/dev/type-checking-system.md:97
msgid "**LiteralType Propagator**"
msgstr ""

#: src/dev/type-checking-system.md:98
msgid "Handles literal type inference"
msgstr "è™•ç†å­—é¢å€¼é¡å‹æ¨æ–·"

#: src/dev/type-checking-system.md:99
msgid "Manages type constraints for literals"
msgstr ""

#: src/dev/type-checking-system.md:101
msgid "3. Propagation Process"
msgstr ""

#: src/dev/type-checking-system.md:103
msgid "**Registration**"
msgstr ""

#: src/dev/type-checking-system.md:106
msgid "// 1. Create propagator holder"
msgstr ""

#: src/dev/type-checking-system.md:109
msgid "// 2. Register with reading cells"
msgstr ""

#: src/dev/type-checking-system.md:114
msgid "// 3. Register with zonking cells"
msgstr ""

#: src/dev/type-checking-system.md:119
msgid "// 4. Initial run"
msgstr ""

#: src/dev/type-checking-system.md:126
msgid "**Execution**"
msgstr ""

#: src/dev/type-checking-system.md:133
msgid "// Run reading propagators"
msgstr ""

#: src/dev/type-checking-system.md:144
msgid "3. Union Type Subtyping"
msgstr ""

#: src/dev/type-checking-system.md:146
msgid ""
"Chester supports union types (`A|B`) with a sophisticated subtyping "
"relationship managed by the propagator network. The subtyping rules are "
"implemented in the `unify` method in `Elaborater.scala`."
msgstr ""

#: src/dev/type-checking-system.md:148
msgid "Union Subtyping Rules"
msgstr ""

#: src/dev/type-checking-system.md:150
msgid "**Union-to-Union Subtyping**: `(A|B) <: (C|D)`"
msgstr ""

#: src/dev/type-checking-system.md:151
msgid ""
"For each type in the right union, at least one type in the left union must "
"accept it"
msgstr ""

#: src/dev/type-checking-system.md:152
msgid ""
"Implemented by creating propagator connections between compatible component "
"types"
msgstr ""

#: src/dev/type-checking-system.md:154
msgid "**Specific-to-Union Subtyping**: `A <: (B|C)`"
msgstr ""

#: src/dev/type-checking-system.md:155
msgid ""
"A specific type can be used where a union is expected if it's compatible "
"with any union member"
msgstr ""

#: src/dev/type-checking-system.md:156
msgid "Example: Passing an `Integer` to a function expecting `Integer|String`"
msgstr ""

#: src/dev/type-checking-system.md:158
msgid "**Union-to-Specific Subtyping**: `(A|B) <: C`"
msgstr ""

#: src/dev/type-checking-system.md:159
msgid ""
"A union can be assigned to a specific type if all union members are "
"compatible with that type"
msgstr ""

#: src/dev/type-checking-system.md:160
msgid ""
"Example: Returning an `Integer|Float` from a function that promises to "
"return `Number`"
msgstr ""

#: src/dev/type-checking-system.md:162
msgid "Implementation Challenges"
msgstr ""

#: src/dev/type-checking-system.md:164
msgid "The union type subtyping implementation addresses several challenges:"
msgstr ""

#: src/dev/type-checking-system.md:166
msgid ""
"**Cell Coverage**: Ensuring all cells (including component types) are "
"properly covered by propagators"
msgstr ""

#: src/dev/type-checking-system.md:167
msgid ""
"**Meta Variables in Unions**: Special handling for meta variables that "
"appear in unions"
msgstr ""

#: src/dev/type-checking-system.md:168
msgid ""
"**Early Return Prevention**: Avoiding early returns that could leave cells "
"uncovered"
msgstr ""

#: src/dev/type-checking-system.md:169
msgid ""
"**Component Tracking**: Ensuring each component of a union has proper "
"propagator connections"
msgstr ""

#: src/dev/type-checking-system.md:173
msgid ""
"The implementation of the core type system features has been completed with "
"recent significant enhancements. Major milestones include:"
msgstr ""

#: src/dev/type-checking-system.md:175
msgid "1. Cell Coverage Improvements (2025-04-21)"
msgstr ""

#: src/dev/type-checking-system.md:177
msgid ""
"The previously \"hacky\" approach to cell coverage has been completely "
"redesigned:"
msgstr ""

#: src/dev/type-checking-system.md:178
msgid "Removed the `AutoConnect` propagator and related indirection"
msgstr ""

#: src/dev/type-checking-system.md:179
msgid "Implemented direct type relationship handling during unification"
msgstr ""

#: src/dev/type-checking-system.md:180
msgid ""
"Created explicit relationships between types directly at creation/"
"unification points"
msgstr ""

#: src/dev/type-checking-system.md:181
msgid "Simplified codebase by removing several layers of indirection"
msgstr ""

#: src/dev/type-checking-system.md:182
msgid ""
"Maintained the same type checking capabilities with a cleaner implementation"
msgstr ""

#: src/dev/type-checking-system.md:184
msgid "2. Union Type Subtyping (2025-03-25)"
msgstr ""

#: src/dev/type-checking-system.md:186
msgid ""
"Union types are now fully implemented with support for all subtyping "
"relationships:"
msgstr ""

#: src/dev/type-checking-system.md:187
msgid ""
"**Union-to-Union**: `(A|B) <: (C|D)` with proper component compatibility"
msgstr ""

#: src/dev/type-checking-system.md:188
msgid ""
"**Specific-to-Union**: `A <: (B|C)` for cases like passing `Integer` to "
"`Integer|String`"
msgstr ""

#: src/dev/type-checking-system.md:189
msgid ""
"**Union-to-Specific**: `(A|B) <: C` for returning unions from specific "
"return type functions"
msgstr ""

#: src/dev/type-checking-system.md:191
msgid "3. Trait Implementation (2025-03-19)"
msgstr ""

#: src/dev/type-checking-system.md:193
msgid "Basic trait support is now available:"
msgstr ""

#: src/dev/type-checking-system.md:194
msgid "Empty traits and record extension using `<:` syntax"
msgstr ""

#: src/dev/type-checking-system.md:195
msgid "Trait-record subtyping relation in type system"
msgstr ""

#: src/dev/type-checking-system.md:196
msgid "`TraitTypeTerm` representation with proper error reporting"
msgstr ""

#: src/dev/type-checking-system.md:197
msgid "Context tracking for trait processing"
msgstr ""

#: src/dev/type-checking-system.md:199
msgid "Remaining Challenges"
msgstr ""

#: src/dev/type-checking-system.md:201
#, fuzzy
msgid "**Type-Level Computation**"
msgstr "**é¡å‹è¨»è§£æª¢æŸ¥**ï¼š"

#: src/dev/type-checking-system.md:202
msgid "Further improvements to recursive type-level function applications"
msgstr ""

#: src/dev/type-checking-system.md:203
msgid "Advanced dependent types with multiple levels of abstraction"
msgstr ""

#: src/dev/type-checking-system.md:204
msgid "More comprehensive testing of type-level computation"
msgstr ""

#: src/dev/type-checking-system.md:206
msgid "**Advanced Trait Features**"
msgstr ""

#: src/dev/type-checking-system.md:207 src/dev/type-checking-system.md:269
msgid "Complete field requirement verification"
msgstr ""

#: src/dev/type-checking-system.md:208 src/dev/type-checking-system.md:270
msgid "Multiple trait inheritance"
msgstr ""

#: src/dev/type-checking-system.md:209 src/dev/type-checking-system.md:271
msgid "Trait methods and default implementations"
msgstr ""

#: src/dev/type-checking-system.md:210
msgid "Trait-to-trait inheritance constraints"
msgstr ""

#: src/dev/type-checking-system.md:212
msgid "Testing Strategy"
msgstr ""

#: src/dev/type-checking-system.md:214
msgid "1. Coverage Tests"
msgstr ""

#: src/dev/type-checking-system.md:215
msgid "Test basic cell coverage"
msgstr ""

#: src/dev/type-checking-system.md:216
msgid "Test union type component coverage"
msgstr ""

#: src/dev/type-checking-system.md:217
msgid "Test meta variable coverage"
msgstr ""

#: src/dev/type-checking-system.md:219
#, fuzzy
msgid "2. State Tests"
msgstr "ç¬¬ 2 ç« ï¼šèªå¥"

#: src/dev/type-checking-system.md:220
msgid "Test propagator lifecycle"
msgstr ""

#: src/dev/type-checking-system.md:221
msgid "Test union type state"
msgstr ""

#: src/dev/type-checking-system.md:222
msgid "Test meta variable resolution"
msgstr ""

#: src/dev/type-checking-system.md:224
msgid "3. Integration Tests"
msgstr ""

#: src/dev/type-checking-system.md:225
msgid "Test complex type scenarios"
msgstr ""

#: src/dev/type-checking-system.md:226
msgid "Test error handling"
msgstr ""

#: src/dev/type-checking-system.md:227
msgid "Test performance"
msgstr ""

#: src/dev/type-checking-system.md:229
msgid "Trait Implementation"
msgstr ""

#: src/dev/type-checking-system.md:231
msgid ""
"Chester's type system now supports traits and record-trait subtyping "
"relationships through the `<:` syntax, with the following features "
"implemented:"
msgstr ""

#: src/dev/type-checking-system.md:233
msgid "1. Trait Definition and Implementation"
msgstr ""

#: src/dev/type-checking-system.md:236
msgid "// Define a trait"
msgstr ""

#: src/dev/type-checking-system.md:240
msgid "// Record implementing a trait"
msgstr ""

#: src/dev/type-checking-system.md:243
msgid "// Using the record with correct field"
msgstr ""

#: src/dev/type-checking-system.md:248
msgid "2. Trait Subtyping Rules"
msgstr ""

#: src/dev/type-checking-system.md:250
msgid "The type system implements several trait-related subtyping rules:"
msgstr ""

#: src/dev/type-checking-system.md:252
msgid ""
"**Record-Trait Subtyping**: Records that extend traits are considered "
"subtypes of those traits"
msgstr ""

#: src/dev/type-checking-system.md:253
msgid ""
"**Trait-Record Compatibility**: Traits can be used where their implementing "
"records are expected"
msgstr ""

#: src/dev/type-checking-system.md:254
msgid "**Trait-Trait Inheritance**: Traits can extend other traits"
msgstr ""

#: src/dev/type-checking-system.md:256
msgid "3. Implementation Components"
msgstr ""

#: src/dev/type-checking-system.md:258
msgid "The trait implementation consists of several key components:"
msgstr ""

#: src/dev/type-checking-system.md:260
msgid "**TraitTypeTerm** in `Term.scala` for trait type representation"
msgstr ""

#: src/dev/type-checking-system.md:261
msgid "**TraitStmtTerm** for trait definitions with optional bodies"
msgstr ""

#: src/dev/type-checking-system.md:262
msgid ""
"**processTraitStmt** in `ElaboraterBlock.scala` to handle trait declarations"
msgstr ""

#: src/dev/type-checking-system.md:263
msgid ""
"**checkTraitImplementation** in `TyckPropagator.scala` to verify trait "
"implementation"
msgstr ""

#: src/dev/type-checking-system.md:264
msgid ""
"Special context tracking with `withProcessingType` to handle trait bodies"
msgstr ""

#: src/dev/type-checking-system.md:266
msgid "4. Future Enhancements"
msgstr ""

#: src/dev/type-checking-system.md:268
msgid "Future work will focus on:"
msgstr ""

#: src/dev/type-checking-system.md:273
msgid "Best Practices for Cell Management"
msgstr ""

#: src/dev/type-checking-system.md:275
msgid "OnceCell Usage Guidelines"
msgstr ""

#: src/dev/type-checking-system.md:277
msgid ""
"The `OnceCell` implementation is a specialized cell type that enforces "
"single-assignment semantics. Proper usage requires careful attention to "
"avoid errors:"
msgstr ""

#: src/dev/type-checking-system.md:279
msgid "1. Cell Filling Best Practices"
msgstr ""

#: src/dev/type-checking-system.md:281
msgid ""
"**Always check before filling**: Before calling `fill()` on any cell, check "
"if it already has a value using `state.readUnstable(cell)`."
msgstr ""

#: src/dev/type-checking-system.md:282
msgid ""
"**Handle already-filled cells gracefully**: When a cell already has a value, "
"check if new value equals existing value."
msgstr ""

#: src/dev/type-checking-system.md:283
msgid ""
"**Use debug assertions**: Include debug prints for cell operations to trace "
"propagation flow."
msgstr ""

#: src/dev/type-checking-system.md:285
msgid "2. Propagator Implementation Guidelines"
msgstr ""

#: src/dev/type-checking-system.md:287
msgid ""
"**Declare cell dependencies correctly**: Ensure all propagators correctly "
"declare their reading and zonking cell dependencies."
msgstr ""

#: src/dev/type-checking-system.md:288
msgid ""
"**Implement naiveZonk correctly**: The `naiveZonk` method should return "
"appropriate dependencies for zonking."
msgstr ""

#: src/dev/type-checking-system.md:289
msgid ""
"**Be idempotent**: Propagator's `run` method should be idempotent - multiple "
"calls with the same input should produce the same output."
msgstr ""

#: src/dev/type-checking-system.md:291
msgid "3. Type-Level Function Handling"
msgstr ""

#: src/dev/type-checking-system.md:293
msgid "When implementing propagators that handle type-level functions:"
msgstr ""

#: src/dev/type-checking-system.md:295
msgid ""
"**Watch for recursive effects**: Type-level functions may cause recursive "
"propagation attempts"
msgstr ""

#: src/dev/type-checking-system.md:296
msgid ""
"**Avoid modifications during reduction**: When reducing for type equality, "
"don't modify the original terms"
msgstr ""

#: src/dev/type-checking-system.md:297
msgid ""
"**Use correct reduction mode**: Use `ReduceMode.TypeLevel` for reductions "
"needed for type equality checks"
msgstr ""

#: src/dev/typescript-backend.md:5
msgid ""
"This document outlines the implementation plan for a TypeScript backend in "
"the Chester compiler. The backend will take type-checked Chester code and "
"generate equivalent TypeScript code, leveraging the existing JavaScript AST "
"infrastructure."
msgstr ""

#: src/dev/typescript-backend.md:7
msgid "Goals"
msgstr ""

#: src/dev/typescript-backend.md:9
msgid ""
"Create a TypeScript code generator that uses the existing JavaScript AST"
msgstr ""

#: src/dev/typescript-backend.md:10
msgid "Ensure proper handling of Chester's type system in TypeScript output"
msgstr ""

#: src/dev/typescript-backend.md:11
msgid ""
"Support TypeScript-specific features like interfaces, type annotations, and "
"generics"
msgstr ""

#: src/dev/typescript-backend.md:12
msgid "Maintain type safety between Chester and TypeScript"
msgstr ""

#: src/dev/typescript-backend.md:16
msgid ""
"The JavaScript AST (`compiler/shared/src/main/scala/chester/targets/js/"
"AST.scala`) already includes TypeScript-specific nodes"
msgstr ""

#: src/dev/typescript-backend.md:17
msgid ""
"We need to implement the transformation from Chester's type-checked AST to "
"TypeScript AST"
msgstr ""

#: src/dev/typescript-backend.md:18
msgid "We need to implement a code generator for TypeScript"
msgstr ""

#: src/dev/typescript-backend.md:22
msgid "1. TypeScript AST Enhancements"
msgstr ""

#: src/dev/typescript-backend.md:24
msgid ""
"While the existing JavaScript AST includes TypeScript nodes, we may need to "
"extend it with additional TypeScript-specific features:"
msgstr ""

#: src/dev/typescript-backend.md:26
msgid "Ensure all TypeScript type annotations are properly represented"
msgstr ""

#: src/dev/typescript-backend.md:27
msgid ""
"Add support for TypeScript-specific syntax like `readonly`, `namespace`, etc."
msgstr ""

#: src/dev/typescript-backend.md:28
msgid "Implement TypeScript module system support"
msgstr ""

#: src/dev/typescript-backend.md:30
msgid "2. Chester to TypeScript Type Mapping"
msgstr ""

#: src/dev/typescript-backend.md:32
msgid "Create a mapping between Chester's type system and TypeScript types:"
msgstr ""

#: src/dev/typescript-backend.md:34
msgid "TypeScript Type"
msgstr ""

#: src/dev/typescript-backend.md:39
msgid "Unit"
msgstr ""

#: src/dev/typescript-backend.md:39
msgid "void"
msgstr ""

#: src/dev/typescript-backend.md:40
msgid "Type"
msgstr ""

#: src/dev/typescript-backend.md:40
msgid "any"
msgstr ""

#: src/dev/typescript-backend.md:41
msgid "Function"
msgstr ""

#: src/dev/typescript-backend.md:42
msgid "interface"
msgstr ""

#: src/dev/typescript-backend.md:43
msgid "Union"
msgstr ""

#: src/dev/typescript-backend.md:43
msgid "union type"
msgstr ""

#: src/dev/typescript-backend.md:44
msgid "Effect"
msgstr ""

#: src/dev/typescript-backend.md:44
msgid "(see below)"
msgstr ""

#: src/dev/typescript-backend.md:46
msgid "3. Effect System Handling"
msgstr ""

#: src/dev/typescript-backend.md:48
msgid ""
"For Chester's effect system, we have several options for TypeScript "
"representation:"
msgstr ""

#: src/dev/typescript-backend.md:50
msgid "**Type-based approach**: Represent effects as part of function types"
msgstr ""

#: src/dev/typescript-backend.md:56
msgid "**Comment-based approach**: Use TypeScript comments to document effects"
msgstr ""

#: src/dev/typescript-backend.md:62
msgid "**Runtime checking**: Implement runtime effect checking in TypeScript"
msgstr ""

#: src/dev/typescript-backend.md:67
msgid ""
"The recommended approach is #1, as it provides compile-time checking in "
"TypeScript."
msgstr ""

#: src/dev/typescript-backend.md:69
msgid "4. Code Generator Implementation"
msgstr ""

#: src/dev/typescript-backend.md:71
msgid "Implement a TypeScript code generator with the following components:"
msgstr ""

#: src/dev/typescript-backend.md:73
msgid "**AST Transformer**: Convert Chester AST to TypeScript AST"
msgstr ""

#: src/dev/typescript-backend.md:74
msgid "**Type Transformer**: Convert Chester types to TypeScript types"
msgstr ""

#: src/dev/typescript-backend.md:75
msgid "**Effect Transformer**: Handle effect annotations"
msgstr ""

#: src/dev/typescript-backend.md:76
msgid "**Code Emitter**: Generate TypeScript code from the AST"
msgstr ""

#: src/dev/typescript-backend.md:78
msgid "Code Emitter"
msgstr ""

#: src/dev/typescript-backend.md:80
msgid "Transforms the TypeScript AST into a valid TypeScript code string."
msgstr ""

#: src/dev/typescript-backend.md:84
msgid "The backend involves several key components:"
msgstr ""

#: src/dev/typescript-backend.md:86
msgid "1. AST Definition (`js.AST.scala`)"
msgstr ""

#: src/dev/typescript-backend.md:88
msgid ""
"Defines the structure of the target JavaScript/TypeScript Abstract Syntax "
"Tree (AST)."
msgstr ""

#: src/dev/typescript-backend.md:90
msgid "2. AST Transformer"
msgstr ""

#: src/dev/typescript-backend.md:92
msgid ""
"Converts the type-checked Chester **core AST** (`chester.syntax.core.Term`) "
"into the target `js.AST`."
msgstr ""

#: src/dev/typescript-backend.md:93
msgid ""
"**Node Mapping**: Map each relevant `core.Term` node to its equivalent "
"`js.AST` node(s)."
msgstr ""

#: src/dev/typescript-backend.md:94
msgid ""
"**Type Mapping**: Translate Chester types (including unions, records) to "
"TypeScript types."
msgstr ""

#: src/dev/typescript-backend.md:95
msgid ""
"**Effect Transformer**: Handle effect annotations (potentially via comments "
"or specific code structures)."
msgstr ""

#: src/dev/typescript-backend.md:97
msgid "3. Code Emitter"
msgstr ""

#: src/dev/typescript-backend.md:99
msgid "Transforms the `js.AST` into a valid TypeScript code string."
msgstr ""

#: src/dev/typescript-backend.md:101
msgid "Current Status (as of YYYY-MM-DD)"
msgstr ""

#: src/dev/typescript-backend.md:103
msgid ""
"The basic AST node definitions (`js.AST.scala`) exist in `compiler/shared/"
"src/main/scala/chester/targets/js/`."
msgstr ""

#: src/dev/typescript-backend.md:104
msgid ""
"A placeholder backend object (`Backend.scala`) has been created in the same "
"directory (`chester.targets.js` package). It expects "
"`chester.syntax.core.Term` as input and contains basic transformation logic "
"for some nodes, but needs refinement and completion."
msgstr ""

#: src/dev/typescript-backend.md:105
msgid ""
"The AST Transformer logic within `Backend.scala` is incomplete and requires "
"verification against the actual `core.Term` structure."
msgstr ""

#: src/dev/typescript-backend.md:106
msgid "The detailed Code Emitter logic **has not yet been implemented**."
msgstr ""

#: src/dev/typescript-backend.md:107
msgid ""
"The integration of this backend into the main compilation pipeline or test "
"infrastructure needs to be done."
msgstr ""

#: src/dev/typescript-backend.md:109
msgid "Challenges"
msgstr ""

#: src/dev/typescript-backend.md:111
msgid ""
"Mapping Chester's type system (including union types, structural types) to "
"TypeScript's type system."
msgstr ""

#: src/dev/typescript-backend.md:112
msgid ""
"Handling effects and ensuring the generated code respects them (perhaps via "
"comments or specific function signatures)."
msgstr ""

#: src/dev/typescript-backend.md:114
msgid "5. Integration with Compiler Pipeline"
msgstr ""

#: src/dev/typescript-backend.md:116
msgid "Add a TypeScript target option to the compiler"
msgstr ""

#: src/dev/typescript-backend.md:117
msgid "Integrate the TypeScript backend with the existing compilation pipeline"
msgstr ""

#: src/dev/typescript-backend.md:118
msgid "Ensure proper error handling and reporting"
msgstr ""

#: src/dev/typescript-backend.md:122
msgid "**Phase 1: Basic TypeScript Generation**"
msgstr ""

#: src/dev/typescript-backend.md:123
msgid "Implement basic AST transformation"
msgstr ""

#: src/dev/typescript-backend.md:124
msgid "Handle primitive types and simple functions"
msgstr ""

#: src/dev/typescript-backend.md:125
msgid "Generate valid TypeScript code without effects"
msgstr ""

#: src/dev/typescript-backend.md:127
msgid "**Phase 2: Advanced Type Features**"
msgstr ""

#: src/dev/typescript-backend.md:128
msgid "Implement generics"
msgstr ""

#: src/dev/typescript-backend.md:129
msgid "Handle record types and interfaces"
msgstr ""

#: src/dev/typescript-backend.md:130
msgid "Support union and intersection types"
msgstr ""

#: src/dev/typescript-backend.md:132
msgid "**Phase 3: Effect System Integration**"
msgstr ""

#: src/dev/typescript-backend.md:133
msgid "Implement effect type representation"
msgstr ""

#: src/dev/typescript-backend.md:134
msgid "Handle effect propagation in TypeScript"
msgstr ""

#: src/dev/typescript-backend.md:135
msgid "Ensure effect safety in generated code"
msgstr ""

#: src/dev/typescript-backend.md:137
msgid "**Phase 4: Optimization and Refinement**"
msgstr ""

#: src/dev/typescript-backend.md:138
msgid "Optimize generated TypeScript code"
msgstr ""

#: src/dev/typescript-backend.md:139
msgid "Improve readability of output"
msgstr ""

#: src/dev/typescript-backend.md:140
msgid "Add source mapping for debugging"
msgstr ""

#: src/dev/typescript-backend.md:142
msgid "Example Transformation"
msgstr ""

#: src/dev/typescript-backend.md:144
msgid "Chester Input:"
msgstr "Chester è¼¸å…¥ï¼š"

#: src/dev/typescript-backend.md:145
msgid ""
"```\n"
"// Function with an effect\n"
"def print(message: String) : Unit / IO = ()\n"
"\n"
"// Function that uses the effect\n"
"def hello() : Unit / IO = {\n"
"  print(\"Hello\")\n"
"}\n"
"\n"
"// Pure function (no effects)\n"
"def pure() : Integer = 123\n"
"```"
msgstr ""

#: src/dev/typescript-backend.md:158
msgid "TypeScript Output:"
msgstr ""

#: src/dev/typescript-backend.md:159
msgid ""
"```typescript\n"
"// Function with an effect\n"
"function print(message: string): IOEffect<void> {\n"
"  // Implementation\n"
"  return undefined as IOEffect<void>;\n"
"}\n"
"\n"
"// Function that uses the effect\n"
"function hello(): IOEffect<void> {\n"
"  print(\"Hello\");\n"
"  return undefined as IOEffect<void>;\n"
"}\n"
"\n"
"// Pure function (no effects)\n"
"function pure(): number {\n"
"  return 123;\n"
"}\n"
"\n"
"// Effect type definitions\n"
"type Effect = { readonly __effect: unique symbol };\n"
"type IOEffect<T> = T & { readonly __io: unique symbol };\n"
"type StateEffect<T> = T & { readonly __state: unique symbol };\n"
"```"
msgstr ""

#: src/dev/typescript-backend.md:185
msgid ""
"The TypeScript backend can generate valid TypeScript code from Chester "
"programs"
msgstr ""

#: src/dev/typescript-backend.md:186
msgid ""
"The generated TypeScript code maintains the type safety of the original "
"Chester code"
msgstr ""

#: src/dev/typescript-backend.md:187
msgid "Effects are properly represented and checked in the TypeScript output"
msgstr ""

#: src/dev/typescript-backend.md:188
msgid "The TypeScript code is readable and follows TypeScript best practices"
msgstr ""

#: src/dev/union_types_progress.md:5
msgid ""
"This document outlines the implementation and current state of union types "
"in Chester."
msgstr ""

#: src/dev/union_types_progress.md:7
msgid "Current State"
msgstr ""

#: src/dev/union_types_progress.md:9
msgid ""
"Union types are now fully implemented in Chester with both parsing and type "
"checking support. The implementation can handle all three key subtyping "
"relationships: union-to-union, specific-to-union, and union-to-specific."
msgstr ""

#: src/dev/union_types_progress.md:11
#, fuzzy
msgid "Implementation Overview"
msgstr "å¯¦ä½œæ–¹æ³•"

#: src/dev/union_types_progress.md:13
msgid "The following components have been implemented to support union types:"
msgstr ""

#: src/dev/union_types_progress.md:15
msgid "1. Parser & Desalting (`Desalt.scala`)"
msgstr ""

#: src/dev/union_types_progress.md:17
msgid ""
"**Union Type Parsing**: Implemented in the `desugar` method to handle union "
"type expressions:"
msgstr ""

#: src/dev/union_types_progress.md:18
msgid "Detects `|` operators in type expressions"
msgstr ""

#: src/dev/union_types_progress.md:19
msgid "Creates a `UnionTypeExpr` node with component types"
msgstr ""

#: src/dev/union_types_progress.md:20
msgid "Handles nested union types properly"
msgstr ""

#: src/dev/union_types_progress.md:21
msgid "Preserves source position information for error reporting"
msgstr ""

#: src/dev/union_types_progress.md:22
msgid "Respects operator precedence and grouping"
msgstr ""

#: src/dev/union_types_progress.md:24
msgid "The parser now correctly recognizes syntax like:"
msgstr ""

#: src/dev/union_types_progress.md:25
msgid ""
"```chester\n"
"// Simple union type\n"
"function accept(value: Integer | String) { ... }\n"
"\n"
"// Nested union types\n"
"function process(data: Integer | String | (Array | Object)) { ... }\n"
"\n"
"// Union in type annotation\n"
"let value: Integer | String = \"hello\";\n"
"```"
msgstr ""

#: src/dev/union_types_progress.md:36
msgid "2. Type Elaboration (`Elaborater.scala`)"
msgstr ""

#: src/dev/union_types_progress.md:38
msgid ""
"**Union Type Elaboration**: Implemented handling for union type expressions "
"in the type checking system:"
msgstr ""

#: src/dev/union_types_progress.md:39
msgid "Elaborate each component type in the union"
msgstr ""

#: src/dev/union_types_progress.md:40
msgid "Create proper `Union` term with component types"
msgstr ""

#: src/dev/union_types_progress.md:41
msgid "Register appropriate propagators for type constraints"
msgstr ""

#: src/dev/union_types_progress.md:42
msgid "Maintain connections between union types and components"
msgstr ""

#: src/dev/union_types_progress.md:44
msgid ""
"**Union Type Unification**: Implemented support for all three subtyping "
"relationships:"
msgstr ""

#: src/dev/union_types_progress.md:45
msgid ""
"**Union-to-Union**: `(A|B) <: (C|D)` with proper component compatibility "
"checks"
msgstr ""

#: src/dev/union_types_progress.md:46
msgid ""
"**Specific-to-Union**: `A <: (B|C)` for cases like passing `Integer` to a "
"parameter of type `Integer|String`"
msgstr ""

#: src/dev/union_types_progress.md:47
msgid ""
"**Union-to-Specific**: `(A|B) <: C` for returning a union from a function "
"with specific return type"
msgstr ""

#: src/dev/union_types_progress.md:49
msgid ""
"**Type-Level Functions with Union Types**: Added support for type-level "
"functions that:"
msgstr ""

#: src/dev/union_types_progress.md:50
msgid "Return union types"
msgstr ""

#: src/dev/union_types_progress.md:51
msgid "Accept union types as arguments"
msgstr ""

#: src/dev/union_types_progress.md:52
msgid "Process union components correctly"
msgstr ""

#: src/dev/union_types_progress.md:54
msgid "The implementation enables code patterns like:"
msgstr ""

#: src/dev/union_types_progress.md:56
msgid ""
"```chester\n"
"// Accepting a union type parameter\n"
"def process(value: Integer | String): String = {\n"
"  match value {\n"
"    case i: Integer => i.toString()\n"
"    case s: String => s\n"
"  }\n"
"}\n"
"\n"
"// Returning a union type\n"
"def fetch(): Integer | String | Null = {\n"
"  if (hasData()) getData()\n"
"  else null\n"
"}\n"
"\n"
"// Union types in generic contexts\n"
"def firstOrDefault[T](list: List[T], default: T): T = {\n"
"  if (isEmpty(list)) default else first(list)\n"
"}\n"
"```"
msgstr ""

#: src/dev/union_types_progress.md:77
msgid "3. Type Propagator (`TyckPropagator.scala`)"
msgstr ""

#: src/dev/union_types_progress.md:79
msgid ""
"**UnionOf Propagator Implementation**: Implemented the `UnionOf` propagator "
"to handle union type constraints:"
msgstr ""

#: src/dev/union_types_progress.md:80
msgid "Manages relationships between union types and their components"
msgstr ""

#: src/dev/union_types_progress.md:81
msgid "Enforces proper subtyping relationships with union types"
msgstr ""

#: src/dev/union_types_progress.md:82
msgid "Handles cell coverage for all union components"
msgstr ""

#: src/dev/union_types_progress.md:83
msgid "Ensures proper zonking of union types"
msgstr ""

#: src/dev/union_types_progress.md:85
msgid ""
"**Enhanced Type Compatibility for Union Types**: Implemented union type "
"compatibility with three key cases:"
msgstr ""

#: src/dev/union_types_progress.md:87
msgid "**Union-to-Union Compatibility**:"
msgstr ""

#: src/dev/union_types_progress.md:90
msgid "// For union-to-union subtyping, we check component compatibility"
msgstr ""

#: src/dev/union_types_progress.md:91
msgid ""
"// with complex rules for determining when unions are subtypes of each other"
msgstr ""

#: src/dev/union_types_progress.md:95
msgid "**Term-to-Union Compatibility**:"
msgstr ""

#: src/dev/union_types_progress.md:98
msgid "// For term-to-union subtyping, we check if the term is compatible"
msgstr ""

#: src/dev/union_types_progress.md:99
msgid "// with any type in the union"
msgstr ""

#: src/dev/union_types_progress.md:103
msgid "**Union-to-Term Compatibility**:"
msgstr ""

#: src/dev/union_types_progress.md:106
msgid "// For union-to-term subtyping, we check if all types in the union"
msgstr ""

#: src/dev/union_types_progress.md:107
msgid "// are compatible with the term"
msgstr ""

#: src/dev/union_types_progress.md:111
msgid ""
"**Cell Coverage Implementation**: Added comprehensive cell coverage "
"mechanisms:"
msgstr ""

#: src/dev/union_types_progress.md:112
msgid "Direct connections between union types and their components"
msgstr ""

#: src/dev/union_types_progress.md:113
msgid "Self-coverage for component types"
msgstr ""

#: src/dev/union_types_progress.md:114
msgid "Enhanced zonking capabilities for union types"
msgstr ""

#: src/dev/union_types_progress.md:115
msgid "Prevention of early returns that could leave cells uncovered"
msgstr ""

#: src/dev/union_types_progress.md:117
msgid "4. Test Framework and Validation"
msgstr ""

#: src/dev/union_types_progress.md:119
msgid ""
"**Comprehensive Test Suite**: Added a complete set of tests to validate "
"union type functionality:"
msgstr ""

#: src/dev/union_types_progress.md:120
msgid "Basic union type syntax tests"
msgstr ""

#: src/dev/union_types_progress.md:121
msgid "Union type subtyping tests (all three relationship types)"
msgstr ""

#: src/dev/union_types_progress.md:122
msgid "Union type pattern matching tests"
msgstr ""

#: src/dev/union_types_progress.md:123
#, fuzzy
msgid "Function with union type parameters and return values"
msgstr "å¸¶æœ‰é¡å‹ä¾è³´çš„å‡½æ•¸é¡å‹"

#: src/dev/union_types_progress.md:124
msgid "Cell coverage tests for union types"
msgstr ""

#: src/dev/union_types_progress.md:125
msgid "Edge cases and error handling tests"
msgstr ""

#: src/dev/union_types_progress.md:127
#, fuzzy
msgid "**Test Files**:"
msgstr "**æ¸¬è©¦ç‹€æ…‹**ï¼š"

#: src/dev/union_types_progress.md:128
msgid "`tests/tyck/simplest_union.chester`: Basic union type functionality"
msgstr ""

#: src/dev/union_types_progress.md:129
msgid "`tests/tyck/union-subtype.chester`: Union subtyping relationships"
msgstr ""

#: src/dev/union_types_progress.md:130
msgid ""
"`tests/tyck/union-pattern-matching.chester`: Pattern matching with union "
"types"
msgstr ""

#: src/dev/union_types_progress.md:131
msgid ""
"Various integration tests using union types with other language features"
msgstr ""

#: src/dev/union_types_progress.md:133
msgid "Current Status and Future Work"
msgstr ""

#: src/dev/union_types_progress.md:135
msgid "Completed"
msgstr ""

#: src/dev/union_types_progress.md:137
msgid "âœ… Parser support for union type syntax"
msgstr ""

#: src/dev/union_types_progress.md:138
msgid "âœ… Type elaboration for union types"
msgstr ""

#: src/dev/union_types_progress.md:139
msgid "âœ… Full union type subtyping relationships"
msgstr ""

#: src/dev/union_types_progress.md:140
msgid "âœ… Cell coverage mechanisms for union types"
msgstr ""

#: src/dev/union_types_progress.md:141
msgid "âœ… Error reporting for union type mismatch errors"
msgstr ""

#: src/dev/union_types_progress.md:142
msgid "âœ… Integration with trait types and interfaces"
msgstr ""

#: src/dev/union_types_progress.md:143
#, fuzzy
msgid "âœ… Pattern matching with union types"
msgstr "æ¨¡å¼åŒ¹é…å’Œé¡å‹ä½¿ç”¨"

#: src/dev/union_types_progress.md:145
msgid "Future Enhancements"
msgstr ""

#: src/dev/union_types_progress.md:147
msgid "More comprehensive error messages for specific union type errors"
msgstr ""

#: src/dev/union_types_progress.md:148
msgid "Performance optimizations for complex union types"
msgstr ""

#: src/dev/union_types_progress.md:149
msgid "Enhanced type inference with union types"
msgstr ""

#: src/dev/union_types_progress.md:150
msgid "Integration with effect system"
msgstr ""

#: src/dev/union_types_progress.md:151
msgid "Compiler backend optimizations for union types"
msgstr ""

#: src/dev/union_types_progress.md:155
msgid "Main implementation files:"
msgstr ""

#: src/dev/union_types_progress.md:156
msgid "`Desalt.scala` (parser implementation)"
msgstr ""

#: src/dev/union_types_progress.md:157
msgid "`Elaborater.scala` (type checking implementation)"
msgstr ""

#: src/dev/union_types_progress.md:158
msgid "`TyckPropagator.scala` (propagator implementation)"
msgstr ""

#: src/dev/union_types_progress.md:159
msgid "`Term.scala` (union type representation)"
msgstr ""

#: src/dev/union_types_progress.md:161
msgid "Test files:"
msgstr ""

#: src/dev/union_types_progress.md:162
msgid "`tests/tyck/simplest_union.chester`"
msgstr ""

#: src/dev/union_types_progress.md:163
msgid "`tests/tyck/union-subtype.chester`"
msgstr ""

#: src/dev/union_types_progress.md:164
msgid "Other integration test files"
msgstr ""

#: src/dev/union_types_progress.md:166
#, fuzzy
msgid "Related documentation:"
msgstr "**æ§‹å»ºæ–‡æª”**ï¼š"

#: src/dev/union_types_progress.md:167
#, fuzzy
msgid "Type checking system documentation"
msgstr "**é¡å‹æª¢æŸ¥æ•´åˆ**ï¼š"

#: src/dev/union_types_progress.md:168
msgid "Trait implementation documentation"
msgstr ""

#: src/guide/Record.md:3
msgid ""
"Chester provides a concise and powerful syntax for defining records, which "
"are similar to structs or classes in other languages. Records in Chester are "
"immutable by default and provide a convenient way to group related data."
msgstr ""
"Chester æä¾›äº†ç°¡æ½”è€Œå¼·å¤§çš„èªæ³•ä¾†å®šç¾©è¨˜éŒ„ï¼ˆrecordsï¼‰ï¼Œé€™é¡ä¼¼æ–¼å…¶ä»–èªè¨€ä¸­çš„çµæ§‹"
"é«”ï¼ˆstructsï¼‰æˆ–é¡ï¼ˆclassesï¼‰ã€‚Chester ä¸­çš„è¨˜éŒ„é è¨­æ˜¯ä¸å¯è®Šçš„ï¼Œä¸¦æä¾›äº†ä¸€ç¨®ä¾¿"
"æ·çš„æ–¹å¼ä¾†çµ„ç¹”ç›¸é—œæ•¸æ“šã€‚"

#: src/guide/Record.md:5
msgid "Basic Record Syntax"
msgstr "è¨˜éŒ„çš„åŸºæœ¬èªæ³•"

#: src/guide/Record.md:7
msgid "The basic syntax for defining a record in Chester is as follows:"
msgstr "Chester ä¸­å®šç¾©è¨˜éŒ„çš„åŸºæœ¬èªæ³•å¦‚ä¸‹ï¼š"

#: src/guide/Record.md:13
msgid "Here's a simple example of a `Person` record:"
msgstr "ä»¥ä¸‹æ˜¯ä¸€å€‹ç°¡å–®çš„ `Person` è¨˜éŒ„ç¯„ä¾‹ï¼š"

#: src/guide/Record.md:19
msgid "Using Records"
msgstr "ä½¿ç”¨è¨˜éŒ„"

#: src/guide/Record.md:21
msgid ""
"Once defined, you can create instances of records and access their fields:"
msgstr "ä¸€æ—¦å®šç¾©ï¼Œå°±å¯ä»¥å‰µå»ºè¨˜éŒ„çš„å¯¦ä¾‹ä¸¦è¨ªå•å®ƒå€‘çš„å­—æ®µï¼š"

#: src/guide/Record.md:23
msgid ""
"```chester,playground,editable\n"
"let alice = Person(\"Alice\", 30);\n"
"println(alice.name);  // Outputs: Alice\n"
"println(alice.age);   // Outputs: 30\n"
"```"
msgstr ""
"```chester,playground,editable\n"
"let alice = Person(\"Alice\", 30);\n"
"println(alice.name);  // è¼¸å‡º: Alice\n"
"println(alice.age);   // è¼¸å‡º: 30\n"
"```"

#: src/guide/statements.md:3
msgid "Scope of `let` and `def`"
msgstr "let å’Œ def çš„ç¯„åœ"

#: src/guide/statements.md:5
msgid ""
"In Chester, `let` and `def` are used to declare bindings, but they differ in "
"how they handle scoping and forward references. Understanding these "
"differences is crucial for writing correct and efficient Chester programs."
msgstr ""
"åœ¨ Chester ä¸­ï¼Œlet å’Œ def ç”¨æ–¼å®£å‘Šç¹«çµï¼Œä½†å®ƒå€‘åœ¨è™•ç†ç¯„åœå’Œå‰å‘å¼•ç”¨æ™‚æœ‰æ‰€ä¸"
"åŒã€‚äº†è§£é€™äº›å·®ç•°å°æ–¼æ’°å¯«æ­£ç¢ºä¸”é«˜æ•ˆçš„ Chester ç¨‹å¼è‡³é—œé‡è¦ã€‚"

#: src/guide/statements.md:7
msgid "`let` Bindings"
msgstr "let ç¹«çµ"

#: src/guide/statements.md:9
msgid ""
"**Local Scope**: `let` bindings are only visible **after** their declaration "
"within the current block."
msgstr "**å€åŸŸç¯„åœ**ï¼šlet ç¹«çµåƒ…åœ¨å®£å‘Šå¾Œåœ¨ç•¶å‰å¡Šä¸­å¯è¦‹ã€‚"

#: src/guide/statements.md:10
msgid ""
"**No Forward References**: You cannot reference a `let` binding before it's "
"declared."
msgstr "**ä¸å…è¨±å‰å‘å¼•ç”¨**ï¼šä½ ä¸èƒ½åœ¨å®£å‘Šä¹‹å‰å¼•ç”¨ let ç¹«çµã€‚"

#: src/guide/statements.md:11
msgid ""
"**Type Inference**: If no type annotation is provided, the compiler infers "
"the type from the binding's body."
msgstr "**é¡å‹æ¨æ–·**ï¼šå¦‚æœæ²’æœ‰æä¾›é¡å‹è¨»è§£ï¼Œç·¨è­¯å™¨æœƒå¾ç¹«çµçš„ä¸»é«”æ¨æ–·é¡å‹ã€‚"

#: src/guide/statements.md:13 src/guide/statements.md:33
msgid "**Example:**"
msgstr "**ç¯„ä¾‹**ï¼š"

#: src/guide/statements.md:15
msgid ""
"```chester,playground,editable\n"
"// Correct usage of 'let'\n"
"let x = 5;\n"
"let y = x; // 'x' is defined before use\n"
"```"
msgstr ""
"```chester,playground,editable\n"
"// æ­£ç¢ºä½¿ç”¨ let\n"
"let x = 5;\n"
"let y = x; // 'x' åœ¨ä½¿ç”¨å‰å·²å®šç¾©\n"
"```"

#: src/guide/statements.md:21
msgid ""
"```chester,playground,editable\n"
"// Incorrect usage of 'let'\n"
"let y = x + 2; // Error: 'x' is not defined yet\n"
"let x = 5;\n"
"```"
msgstr ""

#: src/guide/statements.md:27
msgid "`def` Bindings"
msgstr ""

#: src/guide/statements.md:29
msgid ""
"**Global Scope**: `def` bindings are visible throughout the entire block, "
"even before their declaration."
msgstr "**å…¨åŸŸç¯„åœ**ï¼šdef ç¹«çµåœ¨æ•´å€‹å¡Šä¸­å¯è¦‹ï¼Œç”šè‡³åœ¨å®£å‘Šä¹‹å‰ã€‚"

#: src/guide/statements.md:30
msgid ""
"**Allows Forward References**: You can reference a `def` binding before it's "
"declared."
msgstr "**å…è¨±å‰å‘å¼•ç”¨**ï¼šä½ å¯ä»¥åœ¨å®£å‘Šä¹‹å‰å¼•ç”¨ def ç¹«çµã€‚"

#: src/guide/statements.md:31
msgid ""
"**Type Annotation Required for Forward References**: If you use a `def` "
"binding before its declaration, you must provide a type annotation."
msgstr "**éœ€è¦é¡å‹è¨»è§£**ï¼šå¦‚æœä½ åœ¨å®£å‘Šä¹‹å‰ä½¿ç”¨ def ç¹«çµï¼Œå¿…é ˆæä¾›é¡å‹è¨»è§£ã€‚"

#: src/guide/statements.md:35
msgid ""
"```chester,playground,editable\n"
"// Correct usage of 'def' with type annotation\n"
"def y = square(5); // 'square' is used before its declaration\n"
"\n"
"def square(n: Int) = n * n; // Type annotation for 'n' is required\n"
"```"
msgstr ""
"```chester,playground,editable\n"
"// æ­£ç¢ºä½¿ç”¨ def ä¸¦æä¾›é¡å‹è¨»è§£\n"
"def y = square(5); // 'square' åœ¨ä½¿ç”¨å‰å·²å®£å‘Š\n"
"\n"
"def square(n: Int) = n * n; // éœ€è¦é¡å‹è¨»è§£\n"
"```"

#: src/guide/statements.md:42
msgid ""
"```chester,playground,editable\n"
"// Incorrect usage of 'def' without type annotation\n"
"def y = increment(5); // 'increment' is used before its declaration\n"
"\n"
"def increment(n) = n + 1; // Error: Missing type annotation for 'n'\n"
"```"
msgstr ""

#: src/guide/statements.md:49
msgid "Summary of Scoping Rules"
msgstr "ç¯„åœè¦å‰‡æ‘˜è¦"

#: src/guide/statements.md:51
msgid "**`let` Bindings**:"
msgstr "**let ç¹«çµ**ï¼š"

#: src/guide/statements.md:52
msgid "Visible only after their declaration within the current block."
msgstr "åƒ…åœ¨ç•¶å‰å¡Šä¸­å®£å‘Šå¾Œå¯è¦‹ã€‚"

#: src/guide/statements.md:53
msgid "Do **not** allow forward references."
msgstr "ä¸å…è¨±å‰å‘å¼•ç”¨ã€‚"

#: src/guide/statements.md:54
msgid "Type annotations are optional if the type can be inferred."
msgstr "å¦‚æœé¡å‹å¯ä»¥æ¨æ–·ï¼Œå‰‡é¡å‹è¨»è§£æ˜¯å¯é¸çš„ã€‚"

#: src/guide/statements.md:56
msgid "**`def` Bindings**:"
msgstr "**def ç¹«çµ**ï¼š"

#: src/guide/statements.md:57
msgid "Visible throughout the entire block."
msgstr "åœ¨æ•´å€‹å¡Šä¸­å¯è¦‹ã€‚"

#: src/guide/statements.md:58
msgid "Allow forward references."
msgstr "å…è¨±å‰å‘å¼•ç”¨ã€‚"

#: src/guide/statements.md:59
msgid "Require type annotations when used before their declarations."
msgstr "åœ¨å®£å‘Šä¹‹å‰ä½¿ç”¨æ™‚éœ€è¦é¡å‹è¨»è§£ã€‚"

#: src/guide/statements.md:61
msgid "Compiler Behavior"
msgstr "ç·¨è­¯å™¨è¡Œç‚º"

#: src/guide/statements.md:63
msgid ""
"When processing a block, the Chester compiler handles `let` and `def` "
"bindings differently to manage scope and type checking."
msgstr ""
"ç•¶è™•ç†ä¸€å€‹å¡Šæ™‚ï¼ŒChester ç·¨è­¯å™¨æœƒä»¥ä¸åŒçš„æ–¹å¼è™•ç† let å’Œ def ç¹«çµï¼Œä»¥ç®¡ç†ç¯„åœ"
"å’Œé¡å‹æª¢æŸ¥ã€‚"

#: src/guide/statements.md:65
msgid "Processing `def` Bindings"
msgstr "è™•ç† def ç¹«çµ"

#: src/guide/statements.md:67
msgid "**Collection Phase**:"
msgstr "**æ”¶é›†éšæ®µ**ï¼š"

#: src/guide/statements.md:68
msgid ""
"The compiler collects all `def` bindings, noting their names, type "
"annotations, and identifiers."
msgstr "ç·¨è­¯å™¨æ”¶é›†æ‰€æœ‰ def ç¹«çµï¼Œè¨˜éŒ„å®ƒå€‘çš„åç¨±ã€é¡å‹è¨»è§£å’Œè­˜åˆ¥ç¬¦ã€‚"

#: src/guide/statements.md:69
msgid "It tracks forward references to detect usages before declarations."
msgstr "å®ƒè¿½è¹¤å‰å‘å¼•ç”¨ä»¥æª¢æ¸¬åœ¨å®£å‘Šä¹‹å‰çš„ç”¨æ³•ã€‚"

#: src/guide/statements.md:71
msgid "**Type Annotation Checks**:"
msgstr "**é¡å‹è¨»è§£æª¢æŸ¥**ï¼š"

#: src/guide/statements.md:72
msgid ""
"For forward-referenced `def` bindings without type annotations, the compiler "
"reports a `MissingTypeAnnotationError`."
msgstr ""
"å°æ–¼æ²’æœ‰é¡å‹è¨»è§£çš„å‰å‘å¼•ç”¨ def ç¹«çµï¼Œç·¨è­¯å™¨æœƒå ±å‘Š "
"`MissingTypeAnnotationError`ã€‚"

#: src/guide/statements.md:74
msgid "**Context Updates**:"
msgstr "**ä¸Šä¸‹æ–‡æ›´æ–°**ï¼š"

#: src/guide/statements.md:75
msgid ""
"The compiler adds placeholders or inferred types to the context, allowing "
"forward-referenced `def` bindings to be used."
msgstr "ç·¨è­¯å™¨å°‡ä½”ä½ç¬¦æˆ–æ¨æ–·çš„é¡å‹æ·»åŠ åˆ°ä¸Šä¸‹æ–‡ä¸­ï¼Œå…è¨±ä½¿ç”¨å‰å‘å¼•ç”¨ def ç¹«çµã€‚"

#: src/guide/statements.md:77
msgid "Processing `let` Bindings"
msgstr ""

#: src/guide/statements.md:79
msgid "**Sequential Processing**:"
msgstr ""

#: src/guide/statements.md:80
msgid "`let` bindings are processed in order of their appearance."
msgstr ""

#: src/guide/statements.md:81
msgid "Each `let` binding is added to the context **after** its declaration."
msgstr ""

#: src/guide/statements.md:82
msgid "**No Forward References**:"
msgstr ""

#: src/guide/statements.md:83
msgid "Referencing a `let` binding before its declaration results in an error."
msgstr ""

#: src/guide/statements.md:87
msgid ""
"Use `let` when you don't need to reference the binding before its "
"declaration."
msgstr ""

#: src/guide/statements.md:88
msgid ""
"Use `def` when you need forward references or are defining recursive "
"functions."
msgstr "ç•¶éœ€è¦å‰å‘å¼•ç”¨æˆ–å®šç¾©éæ­¸å‡½æ•¸æ™‚ä½¿ç”¨ defã€‚"

#: src/guide/statements.md:89
msgid ""
"Always provide type annotations for `def` bindings that are forward-"
"referenced to avoid compilation errors."
msgstr "ç‚ºäº†é¿å…ç·¨è­¯éŒ¯èª¤ï¼Œå§‹çµ‚ç‚ºå‰å‘å¼•ç”¨ def ç¹«çµæä¾›é¡å‹è¨»è§£ã€‚"

#: src/guide/statements.md:91
msgid ""
"By understanding these scoping rules, you can write more predictable and "
"maintainable Chester code."
msgstr "é€šéç†è§£é€™äº›ç¯„åœè¦å‰‡ï¼Œå¯ä»¥æ’°å¯«æ›´å¯é æ¸¬ä¸”å¯ç¶­è­·çš„ Chester ç¨‹å¼ã€‚"

#: src/guide/syntax-grammar.md:3
msgid ""
"**IMPORTANT NOTE:** This document provides only a rough description of the "
"Chester language syntax and might be highly incorrect or not fully aligned "
"with the current implementation. It should be used as a general guide rather "
"than a precise specification."
msgstr ""
"**é‡è¦æç¤ºï¼š** æœ¬æ–‡æª”åƒ…æä¾›Chesterèªè¨€èªæ³•çš„å¤§è‡´æè¿°ï¼Œå¯èƒ½é«˜åº¦ä¸æº–ç¢ºæˆ–èˆ‡ç•¶å‰"
"å¯¦ç¾ä¸å®Œå…¨ä¸€è‡´ã€‚æ‡‰å°‡å…¶ç”¨ä½œä¸€èˆ¬æŒ‡å—ï¼Œè€Œéç²¾ç¢ºçš„è¦ç¯„ã€‚"

#: src/guide/syntax-grammar.md:5
msgid ""
"This document attempts to describe the Chester language syntax using a BNF-"
"like notation."
msgstr "æœ¬æ–‡æª”å˜—è©¦ä½¿ç”¨é¡ä¼¼BNFçš„ç¬¦è™Ÿä¾†æè¿°Chesterèªè¨€èªæ³•ã€‚"

#: src/guide/syntax-grammar.md:7
msgid ""
"**Note:** Whitespace and comments (`// ...`) are generally allowed between "
"tokens and are not explicitly shown in the grammar rules unless significant "
"(like newlines in blocks)."
msgstr ""
"**æ³¨æ„ï¼š** ç©ºç™½å­—ç¬¦å’Œè¨»é‡‹ï¼ˆ`// ...`ï¼‰é€šå¸¸å…è¨±åœ¨æ¨™è¨˜ä¹‹é–“å‡ºç¾ï¼Œé™¤éæœ‰ç‰¹æ®Šæ„ç¾©"
"ï¼ˆå¦‚å€å¡Šä¸­çš„æ›è¡Œï¼‰ï¼Œå¦å‰‡åœ¨èªæ³•è¦å‰‡ä¸­ä¸æœƒæ˜ç¢ºé¡¯ç¤ºã€‚"

#: src/guide/syntax-grammar.md:9
msgid "Top Level"
msgstr "é ‚å±¤çµæ§‹"

#: src/guide/syntax-grammar.md:16
msgid ""
"_Note: In many contexts (like blocks or top-level), newlines can act as "
"statement separators similar to semicolons. The last expression in a block "
"acts as its return value unless followed by a semicolon._"
msgstr ""
"_æ³¨æ„ï¼šåœ¨è¨±å¤šä¸Šä¸‹æ–‡ï¼ˆå¦‚å€å¡Šæˆ–é ‚å±¤ï¼‰ä¸­ï¼Œæ›è¡Œå¯ä»¥åƒåˆ†è™Ÿä¸€æ¨£ä½œç‚ºèªå¥åˆ†éš”ç¬¦ã€‚å€å¡Š"
"ä¸­çš„æœ€å¾Œä¸€å€‹è¡¨é”å¼ä½œç‚ºå…¶è¿”å›å€¼ï¼Œé™¤éå¾Œè·Ÿåˆ†è™Ÿã€‚_"

#: src/guide/syntax-grammar.md:20
msgid ""
"```bnf\n"
"Expr ::= Atom | Expr Operator Expr | Operator Expr | Expr Operator\n"
"\n"
"Atom ::= ID\n"
"       | Literal\n"
"       | Tuple\n"
"       | List\n"
"       | Block\n"
"       | Object\n"
"       | Application\n"
"       | MethodCall\n"
"       | SymbolLookup\n"
"       | Keyword\n"
"\n"
"Tuple ::= '(' ExprList? ')'\n"
"List  ::= '[' ExprList? ']'\n"
"Block ::= '{' Statement* Expr? '}'\n"
"\n"
"ExprList ::= Expr (',' Expr)* ','?\n"
"\n"
"Application ::= GenericApplication | FunctionCall | BlockApplication | "
"CombinedApplication\n"
"GenericApplication ::= Atom '[' ExprList ']'\n"
"FunctionCall ::= Atom '(' ExprList? ')'\n"
"BlockApplication ::= Atom Block\n"
"CombinedApplication ::= GenericApplication FunctionCall\n"
"                      | GenericApplication BlockApplication\n"
"                      | FunctionCall BlockApplication\n"
"                      | GenericApplication FunctionCall BlockApplication\n"
"\n"
"MethodCall   ::= Atom '.' ID ('(' ExprList? ')')?  // Parentheses are "
"optional for field access\n"
"Attribute ::= '@' ID // NOT IMPLEMENTED YET\n"
"Keyword      ::= '#' ID (GenericApplication | FunctionCall)*\n"
"```"
msgstr ""

#: src/guide/syntax-grammar.md:54
msgid ""
"_Note: All identifiers are treated uniformly at the syntax level, with no "
"distinction between different kinds of identifiers. Operator precedence and "
"associativity are handled during semantic analysis, not in the grammar._"
msgstr ""

#: src/guide/syntax-grammar.md:56
msgid "Object Literals"
msgstr "ç‰©ä»¶å­—é¢å€¼"

#: src/guide/syntax-grammar.md:73
msgid "Literals"
msgstr "å­—é¢å€¼"

#: src/guide/syntax-grammar.md:75
msgid ""
"```bnf\n"
"Literal ::= INT_LITERAL\n"
"          | RAT_LITERAL\n"
"          | STRING_LITERAL\n"
"          | SYMBOL_LITERAL\n"
"\n"
"SYMBOL_LITERAL ::= \"'\" ID\n"
"```"
msgstr ""

#: src/guide/syntax-grammar.md:84
msgid "Terminals"
msgstr "çµ‚çµç¬¦"

#: src/guide/syntax-grammar.md:86
msgid ""
"```bnf\n"
"ID             ::= /* Starts with letter, _, or emoji; contains letters, "
"digits, _, emoji */\n"
"Operator       ::= /* Sequence of operator symbols like +, -, *, /, =, ->, "
"=>, :, ., etc. */\n"
"INT_LITERAL    ::= /* Integer in decimal, hex (0x...), or binary (0b...) "
"format */\n"
"RAT_LITERAL    ::= /* Rational/float literal (e.g., 1.2, 3.14e-5) */\n"
"STRING_LITERAL ::= /* Double-quoted string \"...\" with escapes */\n"
"Newline        ::= /* \\n or \\r\\n */\n"
"```"
msgstr ""

#: src/guide/syntax-grammar.md:95
msgid "Punctuation and Symbols (Terminals)"
msgstr "æ¨™é»ç¬¦è™Ÿå’Œç¬¦è™Ÿï¼ˆçµ‚çµç¬¦ï¼‰"

#: src/guide/trait-and-interface.md:3
msgid ""
"Chester provides two distinct mechanisms for defining abstract types: traits "
"and interfaces. While both serve to define contracts that other types can "
"implement, they differ in their subtyping behavior and intended use cases."
msgstr ""
"Chesteræä¾›äº†å…©ç¨®ä¸åŒçš„æ©Ÿåˆ¶ä¾†å®šç¾©æŠ½è±¡é¡å‹ï¼šç‰¹è³ª(traits)å’Œä»‹é¢(interfaces)ã€‚é›–"
"ç„¶å®ƒå€‘éƒ½ç”¨æ–¼å®šç¾©å…¶ä»–é¡å‹å¯ä»¥å¯¦ç¾çš„å¥‘ç´„ï¼Œä½†å®ƒå€‘åœ¨å­é¡å‹è¡Œç‚ºå’Œé æœŸç”¨ä¾‹æ–¹é¢æœ‰æ‰€"
"ä¸åŒã€‚"

#: src/guide/trait-and-interface.md:5
msgid "Traits: Nominal Subtyping"
msgstr "ç‰¹è³ªï¼šåç¾©å­é¡å‹"

#: src/guide/trait-and-interface.md:7
msgid ""
"Traits in Chester use nominal subtyping, which means that the name of the "
"type is significant in determining subtype relationships."
msgstr ""
"Chesterä¸­çš„ç‰¹è³ªä½¿ç”¨åç¾©å­é¡å‹(nominal subtyping)ï¼Œé€™æ„å‘³è‘—é¡å‹çš„åç¨±åœ¨ç¢ºå®šå­"
"é¡å‹é—œä¿‚æ™‚å¾ˆé‡è¦ã€‚"

#: src/guide/trait-and-interface.md:9
msgid "Here's an example of a trait definition in Chester:"
msgstr "ä»¥ä¸‹æ˜¯ Chester ä¸­çš„ç‰¹è³ªå®šç¾©ç¯„ä¾‹ï¼š"

#: src/guide/trait-and-interface.md:11
msgid ""
"```chester,playground,editable\n"
"trait Animal {\n"
"  def makeSound: String;\n"
"}\n"
"\n"
"object Dog <: Animal {\n"
"  override def makeSound: String = \"Woof!\";\n"
"}\n"
"```"
msgstr ""

#: src/guide/trait-and-interface.md:21
msgid ""
"In this example, `Dog` is explicitly declared as a subtype of `Animal` using "
"the `<:` operator. This relationship is based on the names of the types, not "
"just their structure."
msgstr ""
"åœ¨æ­¤ä¾‹ä¸­ï¼Œ`Dog` é€šéä½¿ç”¨ `<:` æ“ä½œç¬¦æ˜ç¢ºè²æ˜ç‚º `Animal` çš„å­é¡å‹ã€‚é€™ç¨®é—œä¿‚åŸº"
"æ–¼é¡å‹çš„åç¨±ï¼Œè€Œä¸åƒ…åƒ…æ˜¯å®ƒå€‘çš„çµæ§‹ã€‚"

#: src/guide/trait-and-interface.md:23
msgid "Interfaces: Structural Subtyping"
msgstr "ä»‹é¢ï¼šçµæ§‹å­é¡å‹"

#: src/guide/trait-and-interface.md:25
msgid ""
"Interfaces in Chester use structural subtyping, which means that subtype "
"relationships are determined by the structure (methods and properties) of "
"the types, regardless of their names."
msgstr ""
"Chesterä¸­çš„ä»‹é¢ä½¿ç”¨çµæ§‹å­é¡å‹(structural subtyping)ï¼Œé€™æ„å‘³è‘—å­é¡å‹é—œä¿‚æ˜¯ç”±é¡"
"å‹çš„çµæ§‹ï¼ˆæ–¹æ³•å’Œå±¬æ€§ï¼‰æ±ºå®šçš„ï¼Œè€Œä¸è€ƒæ…®å®ƒå€‘çš„åç¨±ã€‚"

#: src/guide/trait-and-interface.md:27
msgid "Here's an example of an interface definition:"
msgstr "ä»¥ä¸‹æ˜¯ä»‹é¢å®šç¾©çš„ç¯„ä¾‹ï¼š"

#: src/guide/trait-and-interface.md:29
msgid ""
"```chester,playground,editable\n"
"interface Soundmaker {\n"
"  def makeSound: String;\n"
"}\n"
"\n"
"object Cat {\n"
"  def makeSound: String = \"Meow!\";\n"
"}\n"
"\n"
"// Cat is implicitly a Soundmaker because it has a matching structure\n"
"def soundmaker: Soundmaker = Cat;\n"
"```"
msgstr ""

#: src/guide/trait-and-interface.md:42
msgid ""
"In this case, `Cat` is considered a subtype of `Soundmaker` because it has a "
"matching `makeSound` method, even though it wasn't explicitly declared as "
"such."
msgstr ""
"åœ¨é€™å€‹ä¾‹å­ä¸­ï¼Œ`Cat` è¢«è¦–ç‚º `Soundmaker` çš„å­é¡å‹ï¼Œå› ç‚ºå®ƒæœ‰ä¸€å€‹åŒ¹é…çš„ "
"`makeSound` æ–¹æ³•ï¼Œå³ä½¿å®ƒä¸¦æ²’æœ‰è¢«æ˜ç¢ºè²æ˜ç‚ºé€™æ¨£ã€‚"

#: src/guide/trait-and-interface.md:44
msgid "Design Inspiration"
msgstr "è¨­è¨ˆéˆæ„Ÿ"

#: src/guide/trait-and-interface.md:46
msgid ""
"This dual approach to abstract types is inspired by the Pony programming "
"language, as described in:"
msgstr "é€™ç¨®å°æŠ½è±¡é¡å‹çš„é›™é‡æ–¹æ³•å—åˆ° Pony ç¨‹å¼èªè¨€çš„å•Ÿç™¼ï¼Œå¦‚ä»¥ä¸‹æ–‡ç»æ‰€è¿°ï¼š"

#: src/guide/trait-and-interface.md:48
msgid ""
"Steed, G., & Drossopoulou, S. (2016). A principled design of capabilities in "
"Pony. URL: https://www.ponylang.io/media/papers/"
"a_prinicipled_design_of_capabilities_in_pony.pdf"
msgstr ""

#: src/guide/trait-and-interface.md:50
msgid ""
"The Pony language uses a similar distinction between traits (which they call "
"\"interfaces\") for nominal subtyping and \"structural types\" for "
"structural subtyping."
msgstr ""

#: src/guide/trait-and-interface.md:52
msgid "Choosing Between Traits and Interfaces"
msgstr "åœ¨ç‰¹è³ªå’Œä»‹é¢ä¹‹é–“é¸æ“‡"

#: src/guide/trait-and-interface.md:54
msgid ""
"Use traits when you want to create a named hierarchy of types and control "
"which types can be subtypes."
msgstr ""
"ç•¶æ‚¨æƒ³è¦å‰µå»ºå‘½åçš„é¡å‹å±¤æ¬¡çµæ§‹ä¸¦æ§åˆ¶å“ªäº›é¡å‹å¯ä»¥æˆç‚ºå­é¡å‹æ™‚ï¼Œè«‹ä½¿ç”¨ç‰¹è³ªã€‚"

#: src/guide/trait-and-interface.md:55
msgid ""
"Use interfaces when you want to define a contract that any type can "
"implicitly satisfy by implementing the required structure."
msgstr ""
"ç•¶æ‚¨æƒ³è¦å®šç¾©ä»»ä½•é¡å‹éƒ½å¯ä»¥é€šéå¯¦ç¾æ‰€éœ€çµæ§‹è€Œéš±å¼æ»¿è¶³çš„å¥‘ç´„æ™‚ï¼Œè«‹ä½¿ç”¨ä»‹é¢ã€‚"

#: src/guide/trait-and-interface.md:57
msgid ""
"This design gives Chester developers flexibility in how they structure their "
"code, allowing for both strict hierarchies and more flexible, duck-typed-"
"style programming where appropriate."
msgstr ""
"é€™ç¨®è¨­è¨ˆçµ¦äºˆChesteré–‹ç™¼è€…éˆæ´»æ€§ï¼Œä½¿ä»–å€‘èƒ½å¤ æ ¹æ“šéœ€è¦åŒæ™‚ä½¿ç”¨åš´æ ¼çš„é¡å‹å±¤æ¬¡çµæ§‹"
"å’Œæ›´éˆæ´»çš„é´¨å­é¡å‹é¢¨æ ¼ç·¨ç¨‹ã€‚"

#~ msgid "Union Types Progress"
#~ msgstr "è¯åˆé¡å‹é€²å±•"

#~ msgid "Platform-Specific Type System Implementation"
#~ msgstr "å¹³å°ç‰¹å®šé¡å‹ç³»çµ±å¯¦ç¾"

#~ msgid "\".chester\""
#~ msgstr "\".chester\""
